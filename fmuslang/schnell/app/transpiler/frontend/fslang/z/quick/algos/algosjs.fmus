--% index/fmus
.,d(/mk)
	%utama=__FILE__
	.gitignore,f(e=utama=C:/work/algos/Javascript/.gitignore)
	.gitpod.yml,f(e=utama=C:/work/algos/Javascript/.gitpod.yml)
	.prettierrc,f(e=utama=C:/work/algos/Javascript/.prettierrc)
	babel.config.cjs,f(e=utama=C:/work/algos/Javascript/babel.config.cjs)
	CONTRIBUTING.md,f(e=utama=C:/work/algos/Javascript/CONTRIBUTING.md)
	DIRECTORY.md,f(e=utama=C:/work/algos/Javascript/DIRECTORY.md)
	LICENSE,f(e=utama=C:/work/algos/Javascript/LICENSE)
	package.json,f(e=utama=C:/work/algos/Javascript/package.json)
	README.md,f(e=utama=C:/work/algos/Javascript/README.md)
	.github,d(/mk)
		CODEOWNERS,f(e=utama=C:/work/algos/Javascript/.github/CODEOWNERS)
		pull_request_template.md,f(e=utama=C:/work/algos/Javascript/.github/pull_request_template.md)
		stale.yml,f(e=utama=C:/work/algos/Javascript/.github/stale.yml)
		workflows,d(/mk)
			Ci.yml,f(e=utama=C:/work/algos/Javascript/.github/workflows/Ci.yml)
			Codespell.yml,f(e=utama=C:/work/algos/Javascript/.github/workflows/Codespell.yml)
			CommitAndPushDirectory.sh,f(e=utama=C:/work/algos/Javascript/.github/workflows/CommitAndPushDirectory.sh)
			UpdateDirectory.mjs,f(e=utama=C:/work/algos/Javascript/.github/workflows/UpdateDirectory.mjs)
			UpdateDirectory.yml,f(e=utama=C:/work/algos/Javascript/.github/workflows/UpdateDirectory.yml)
	Backtracking,d(/mk)
		AllCombinationsOfSizeK.js,f(e=utama=C:/work/algos/Javascript/Backtracking/AllCombinationsOfSizeK.js)
		GeneratePermutations.js,f(e=utama=C:/work/algos/Javascript/Backtracking/GeneratePermutations.js)
		KnightTour.js,f(e=utama=C:/work/algos/Javascript/Backtracking/KnightTour.js)
		NQueen.js,f(e=utama=C:/work/algos/Javascript/Backtracking/NQueen.js)
		RatInAMaze.js,f(e=utama=C:/work/algos/Javascript/Backtracking/RatInAMaze.js)
		Sudoku.js,f(e=utama=C:/work/algos/Javascript/Backtracking/Sudoku.js)
		SumOfSubset.js,f(e=utama=C:/work/algos/Javascript/Backtracking/SumOfSubset.js)
		tests,d(/mk)
			AllCombinationsOfSizeK.test.js,f(e=utama=C:/work/algos/Javascript/Backtracking/tests/AllCombinationsOfSizeK.test.js)
			GeneratePermutations.test.js,f(e=utama=C:/work/algos/Javascript/Backtracking/tests/GeneratePermutations.test.js)
			KnightTour.test.js,f(e=utama=C:/work/algos/Javascript/Backtracking/tests/KnightTour.test.js)
			NQueen.test.js,f(e=utama=C:/work/algos/Javascript/Backtracking/tests/NQueen.test.js)
			RatInAMaze.test.js,f(e=utama=C:/work/algos/Javascript/Backtracking/tests/RatInAMaze.test.js)
			Sudoku.test.js,f(e=utama=C:/work/algos/Javascript/Backtracking/tests/Sudoku.test.js)
			SumOfSubset.test.js,f(e=utama=C:/work/algos/Javascript/Backtracking/tests/SumOfSubset.test.js)
	Bit-Manipulation,d(/mk)
		BinaryCountSetBits.js,f(e=utama=C:/work/algos/Javascript/Bit-Manipulation/BinaryCountSetBits.js)
		IsPowerOfTwo.js,f(e=utama=C:/work/algos/Javascript/Bit-Manipulation/IsPowerOfTwo.js)
		NextPowerOfTwo.js,f(e=utama=C:/work/algos/Javascript/Bit-Manipulation/NextPowerOfTwo.js)
		SetBit.js,f(e=utama=C:/work/algos/Javascript/Bit-Manipulation/SetBit.js)
		test,d(/mk)
			IsPowerOfTwo.test.js,f(e=utama=C:/work/algos/Javascript/Bit-Manipulation/test/IsPowerOfTwo.test.js)
			NextPowerOfTwo.test.js,f(e=utama=C:/work/algos/Javascript/Bit-Manipulation/test/NextPowerOfTwo.test.js)
			SetBit.test.js,f(e=utama=C:/work/algos/Javascript/Bit-Manipulation/test/SetBit.test.js)
	Cache,d(/mk)
		LFUCache.js,f(e=utama=C:/work/algos/Javascript/Cache/LFUCache.js)
		LRUCache.js,f(e=utama=C:/work/algos/Javascript/Cache/LRUCache.js)
		Memoize.js,f(e=utama=C:/work/algos/Javascript/Cache/Memoize.js)
		test,d(/mk)
			LFUCache.test.js,f(e=utama=C:/work/algos/Javascript/Cache/test/LFUCache.test.js)
			LRUCache.test.js,f(e=utama=C:/work/algos/Javascript/Cache/test/LRUCache.test.js)
			Memoize.test.js,f(e=utama=C:/work/algos/Javascript/Cache/test/Memoize.test.js)
	Cellular-Automata,d(/mk)
		ConwaysGameOfLife.js,f(e=utama=C:/work/algos/Javascript/Cellular-Automata/ConwaysGameOfLife.js)
		test,d(/mk)
			ConwaysGameOfLife.test.js,f(e=utama=C:/work/algos/Javascript/Cellular-Automata/test/ConwaysGameOfLife.test.js)
	Ciphers,d(/mk)
		Atbash.js,f(e=utama=C:/work/algos/Javascript/Ciphers/Atbash.js)
		CaesarsCipher.js,f(e=utama=C:/work/algos/Javascript/Ciphers/CaesarsCipher.js)
		KeyFinder.js,f(e=utama=C:/work/algos/Javascript/Ciphers/KeyFinder.js)
		KeywordShiftedAlphabet.js,f(e=utama=C:/work/algos/Javascript/Ciphers/KeywordShiftedAlphabet.js)
		ROT13.js,f(e=utama=C:/work/algos/Javascript/Ciphers/ROT13.js)
		VigenereCipher.js,f(e=utama=C:/work/algos/Javascript/Ciphers/VigenereCipher.js)
		XORCipher.js,f(e=utama=C:/work/algos/Javascript/Ciphers/XORCipher.js)
	Conversions,d(/mk)
		ArbitraryBase.js,f(e=utama=C:/work/algos/Javascript/Conversions/ArbitraryBase.js)
		ArrayBufferToBase64.js,f(e=utama=C:/work/algos/Javascript/Conversions/ArrayBufferToBase64.js)
		Base64ToArrayBuffer.js,f(e=utama=C:/work/algos/Javascript/Conversions/Base64ToArrayBuffer.js)
		BinaryToDecimal.js,f(e=utama=C:/work/algos/Javascript/Conversions/BinaryToDecimal.js)
		BinaryToHex.js,f(e=utama=C:/work/algos/Javascript/Conversions/BinaryToHex.js)
		DateDayDifference.js,f(e=utama=C:/work/algos/Javascript/Conversions/DateDayDifference.js)
		DateToDay.js,f(e=utama=C:/work/algos/Javascript/Conversions/DateToDay.js)
		DecimalToBinary.js,f(e=utama=C:/work/algos/Javascript/Conversions/DecimalToBinary.js)
		DecimalToHex.js,f(e=utama=C:/work/algos/Javascript/Conversions/DecimalToHex.js)
		DecimalToOctal.js,f(e=utama=C:/work/algos/Javascript/Conversions/DecimalToOctal.js)
		DecimalToRoman.js,f(e=utama=C:/work/algos/Javascript/Conversions/DecimalToRoman.js)
		HexToBinary.js,f(e=utama=C:/work/algos/Javascript/Conversions/HexToBinary.js)
		HexToDecimal.js,f(e=utama=C:/work/algos/Javascript/Conversions/HexToDecimal.js)
		HexToRGB.js,f(e=utama=C:/work/algos/Javascript/Conversions/HexToRGB.js)
		LowerCaseConversion.js,f(e=utama=C:/work/algos/Javascript/Conversions/LowerCaseConversion.js)
		MeterToFeetConversion.js,f(e=utama=C:/work/algos/Javascript/Conversions/MeterToFeetConversion.js)
		OctToDecimal.js,f(e=utama=C:/work/algos/Javascript/Conversions/OctToDecimal.js)
		RailwayTimeConversion.js,f(e=utama=C:/work/algos/Javascript/Conversions/RailwayTimeConversion.js)
		RgbHsvConversion.js,f(e=utama=C:/work/algos/Javascript/Conversions/RgbHsvConversion.js)
		RGBToHex.js,f(e=utama=C:/work/algos/Javascript/Conversions/RGBToHex.js)
		RomanToDecimal.js,f(e=utama=C:/work/algos/Javascript/Conversions/RomanToDecimal.js)
		TemperatureConversion.js,f(e=utama=C:/work/algos/Javascript/Conversions/TemperatureConversion.js)
		TitleCaseConversion.js,f(e=utama=C:/work/algos/Javascript/Conversions/TitleCaseConversion.js)
		UpperCaseConversion.js,f(e=utama=C:/work/algos/Javascript/Conversions/UpperCaseConversion.js)
		test,d(/mk)
			ArrayBufferToBase64.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/ArrayBufferToBase64.test.js)
			Base64ToArrayBuffer.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/Base64ToArrayBuffer.test.js)
			BinaryToDecimal.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/BinaryToDecimal.test.js)
			BinaryToHex.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/BinaryToHex.test.js)
			DecimalToHex.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/DecimalToHex.test.js)
			DecimalToRoman.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/DecimalToRoman.test.js)
			HexToBinary.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/HexToBinary.test.js)
			MeterToFeetConversion.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/MeterToFeetConversion.test.js)
			RgbHsvConversion.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/RgbHsvConversion.test.js)
			RomanToDecimal.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/RomanToDecimal.test.js)
			TemperatureConversion.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/TemperatureConversion.test.js)
			TitleCaseConversion.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/TitleCaseConversion.test.js)
			UpperCaseConverstion.test.js,f(e=utama=C:/work/algos/Javascript/Conversions/test/UpperCaseConverstion.test.js)
	Data-Structures,d(/mk)
		Array,d(/mk)
			LocalMaximomPoint.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Array/LocalMaximomPoint.js)
			NumberOfLocalMaximumPoints.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Array/NumberOfLocalMaximumPoints.js)
			QuickSelect.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Array/QuickSelect.js)
			test,d(/mk)
				LocalMaximomPoint.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Array/test/LocalMaximomPoint.test.js)
				NumberOfLocalMaximumPoints.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Array/test/NumberOfLocalMaximumPoints.test.js)
				QuickSelect.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Array/test/QuickSelect.test.js)
		Graph,d(/mk)
			Graph.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Graph/Graph.js)
			Graph2.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Graph/Graph2.js)
			test,d(/mk)
				Graph2.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Graph/test/Graph2.test.js)
		Heap,d(/mk)
			MaxHeap.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Heap/MaxHeap.js)
			MinHeap.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Heap/MinHeap.js)
			MinPriorityQueue.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Heap/MinPriorityQueue.js)
			test,d(/mk)
				MinHeap.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Heap/test/MinHeap.test.js)
				MinPriorityQueue.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Heap/test/MinPriorityQueue.test.js)
		Linked-List,d(/mk)
			CycleDetection.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Linked-List/CycleDetection.js)
			DoublyLinkedList.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Linked-List/DoublyLinkedList.js)
			RotateListRight.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Linked-List/RotateListRight.js)
			SingleCircularLinkedList.js.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Linked-List/SingleCircularLinkedList.js.js)
			SinglyLinkedList.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Linked-List/SinglyLinkedList.js)
			test,d(/mk)
				SinglyLinkedList.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Linked-List/test/SinglyLinkedList.test.js)
		Queue,d(/mk)
			CircularQueue.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Queue/CircularQueue.js)
			Queue.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Queue/Queue.js)
			QueueUsing2Stacks.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Queue/QueueUsing2Stacks.js)
			test,d(/mk)
				Queue.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Queue/test/Queue.test.js)
				QueueUsing2Stacks.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Queue/test/QueueUsing2Stacks.test.js)
		Stack,d(/mk)
			Stack.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Stack/Stack.js)
			StackES6.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Stack/StackES6.js)
		Tree,d(/mk)
			AVLTree.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Tree/AVLTree.js)
			BinarySearchTree.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Tree/BinarySearchTree.js)
			Trie.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Tree/Trie.js)
		Vectors,d(/mk)
			Vector2.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Vectors/Vector2.js)
			test,d(/mk)
				Vector2.test.js,f(e=utama=C:/work/algos/Javascript/Data-Structures/Vectors/test/Vector2.test.js)
	Dynamic-Programming,d(/mk)
		ClimbingStairs.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/ClimbingStairs.js)
		CoinChange.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/CoinChange.js)
		EditDistance.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/EditDistance.js)
		FibonacciNumber.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/FibonacciNumber.js)
		FindMonthCalendar.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/FindMonthCalendar.js)
		KadaneAlgo.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/KadaneAlgo.js)
		LevenshteinDistance.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/LevenshteinDistance.js)
		LongestCommonSubsequence.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/LongestCommonSubsequence.js)
		LongestIncreasingSubsequence.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/LongestIncreasingSubsequence.js)
		LongestPalindromicSubsequence.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/LongestPalindromicSubsequence.js)
		LongestValidParentheses.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/LongestValidParentheses.js)
		MaxNonAdjacentSum.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/MaxNonAdjacentSum.js)
		MaxProductOfThree.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/MaxProductOfThree.js)
		MinimumCostPath.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/MinimumCostPath.js)
		NumberOfSubsetEqualToGivenSum.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/NumberOfSubsetEqualToGivenSum.js)
		RodCutting.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/RodCutting.js)
		Shuf.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/Shuf.js)
		SieveOfEratosthenes.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/SieveOfEratosthenes.js)
		SudokuSolver.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/SudokuSolver.js)
		TrappingRainWater.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/TrappingRainWater.js)
		TribonacciNumber.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/TribonacciNumber.js)
		ZeroOneKnapsack.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/ZeroOneKnapsack.js)
		Sliding-Window,d(/mk)
			LongestSubstringWithoutRepeatingCharacters.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/Sliding-Window/LongestSubstringWithoutRepeatingCharacters.js)
			PermutationinString.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/Sliding-Window/PermutationinString.js)
			test,d(/mk)
				LongestSubstringWithoutRepeatingCharacters.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/Sliding-Window/test/LongestSubstringWithoutRepeatingCharacters.test.js)
				PermutationinString.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/Sliding-Window/test/PermutationinString.test.js)
		tests,d(/mk)
			ClimbingStairs.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/ClimbingStairs.test.js)
			CoinChange.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/CoinChange.test.js)
			FibonacciNumber.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/FibonacciNumber.test.js)
			KadaneAlgo.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/KadaneAlgo.test.js)
			LongestCommonSubsequence.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/LongestCommonSubsequence.test.js)
			LongestPalindromicSubsequence.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/LongestPalindromicSubsequence.test.js)
			LongestValidParentheses.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/LongestValidParentheses.test.js)
			MaxProductOfThree.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/MaxProductOfThree.test.js)
			RodCutting.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/RodCutting.test.js)
			SieveOfEratosthenes.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/SieveOfEratosthenes.test.js)
			TrappingRainWater.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/TrappingRainWater.test.js)
			TribonacciNumber.test.js,f(e=utama=C:/work/algos/Javascript/Dynamic-Programming/tests/TribonacciNumber.test.js)
	Geometry,d(/mk)
		ConvexHullGraham.js,f(e=utama=C:/work/algos/Javascript/Geometry/ConvexHullGraham.js)
	Graphs,d(/mk)
		BellmanFord.js,f(e=utama=C:/work/algos/Javascript/Graphs/BellmanFord.js)
		BreadthFirstSearch.js,f(e=utama=C:/work/algos/Javascript/Graphs/BreadthFirstSearch.js)
		BreadthFirstShortestPath.js,f(e=utama=C:/work/algos/Javascript/Graphs/BreadthFirstShortestPath.js)
		ConnectedComponents.js,f(e=utama=C:/work/algos/Javascript/Graphs/ConnectedComponents.js)
		Density.js,f(e=utama=C:/work/algos/Javascript/Graphs/Density.js)
		DepthFirstSearchIterative.js,f(e=utama=C:/work/algos/Javascript/Graphs/DepthFirstSearchIterative.js)
		DepthFirstSearchRecursive.js,f(e=utama=C:/work/algos/Javascript/Graphs/DepthFirstSearchRecursive.js)
		Dijkstra.js,f(e=utama=C:/work/algos/Javascript/Graphs/Dijkstra.js)
		DijkstraSmallestPath.js,f(e=utama=C:/work/algos/Javascript/Graphs/DijkstraSmallestPath.js)
		FloydWarshall.js,f(e=utama=C:/work/algos/Javascript/Graphs/FloydWarshall.js)
		KruskalMST.js,f(e=utama=C:/work/algos/Javascript/Graphs/KruskalMST.js)
		NodeNeighbors.js,f(e=utama=C:/work/algos/Javascript/Graphs/NodeNeighbors.js)
		NumberOfIslands.js,f(e=utama=C:/work/algos/Javascript/Graphs/NumberOfIslands.js)
		PrimMST.js,f(e=utama=C:/work/algos/Javascript/Graphs/PrimMST.js)
		test,d(/mk)
			BellmanFord.test.js,f(e=utama=C:/work/algos/Javascript/Graphs/test/BellmanFord.test.js)
			BreadthFirstSearch.test.js,f(e=utama=C:/work/algos/Javascript/Graphs/test/BreadthFirstSearch.test.js)
			BreadthFirstShortestPath.test.js,f(e=utama=C:/work/algos/Javascript/Graphs/test/BreadthFirstShortestPath.test.js)
	Hashes,d(/mk)
		SHA1.js,f(e=utama=C:/work/algos/Javascript/Hashes/SHA1.js)
		SHA256.js,f(e=utama=C:/work/algos/Javascript/Hashes/SHA256.js)
	Maths,d(/mk)
		Abs.js,f(e=utama=C:/work/algos/Javascript/Maths/Abs.js)
		AliquotSum.js,f(e=utama=C:/work/algos/Javascript/Maths/AliquotSum.js)
		Area.js,f(e=utama=C:/work/algos/Javascript/Maths/Area.js)
		ArmstrongNumber.js,f(e=utama=C:/work/algos/Javascript/Maths/ArmstrongNumber.js)
		AverageMean.js,f(e=utama=C:/work/algos/Javascript/Maths/AverageMean.js)
		AverageMedian.js,f(e=utama=C:/work/algos/Javascript/Maths/AverageMedian.js)
		BinaryConvert.js,f(e=utama=C:/work/algos/Javascript/Maths/BinaryConvert.js)
		BinaryExponentiationIterative.js,f(e=utama=C:/work/algos/Javascript/Maths/BinaryExponentiationIterative.js)
		BinaryExponentiationRecursive.js,f(e=utama=C:/work/algos/Javascript/Maths/BinaryExponentiationRecursive.js)
		BisectionMethod.js,f(e=utama=C:/work/algos/Javascript/Maths/BisectionMethod.js)
		CheckKishnamurthyNumber.js,f(e=utama=C:/work/algos/Javascript/Maths/CheckKishnamurthyNumber.js)
		Coordinate.js,f(e=utama=C:/work/algos/Javascript/Maths/Coordinate.js)
		CoPrimeCheck.js,f(e=utama=C:/work/algos/Javascript/Maths/CoPrimeCheck.js)
		DecimalIsolate.js,f(e=utama=C:/work/algos/Javascript/Maths/DecimalIsolate.js)
		DegreeToRadian.js,f(e=utama=C:/work/algos/Javascript/Maths/DegreeToRadian.js)
		EulerMethod.js,f(e=utama=C:/work/algos/Javascript/Maths/EulerMethod.js)
		EulersTotient.js,f(e=utama=C:/work/algos/Javascript/Maths/EulersTotient.js)
		EulersTotientFunction.js,f(e=utama=C:/work/algos/Javascript/Maths/EulersTotientFunction.js)
		ExtendedEuclideanGCD.js,f(e=utama=C:/work/algos/Javascript/Maths/ExtendedEuclideanGCD.js)
		Factorial.js,f(e=utama=C:/work/algos/Javascript/Maths/Factorial.js)
		Factors.js,f(e=utama=C:/work/algos/Javascript/Maths/Factors.js)
		FareyApproximation.js,f(e=utama=C:/work/algos/Javascript/Maths/FareyApproximation.js)
		FermatPrimalityTest.js,f(e=utama=C:/work/algos/Javascript/Maths/FermatPrimalityTest.js)
		Fibonacci.js,f(e=utama=C:/work/algos/Javascript/Maths/Fibonacci.js)
		FigurateNumber.js,f(e=utama=C:/work/algos/Javascript/Maths/FigurateNumber.js)
		FindHcf.js,f(e=utama=C:/work/algos/Javascript/Maths/FindHcf.js)
		FindLcm.js,f(e=utama=C:/work/algos/Javascript/Maths/FindLcm.js)
		FindMin.js,f(e=utama=C:/work/algos/Javascript/Maths/FindMin.js)
		GetEuclidGCD.js,f(e=utama=C:/work/algos/Javascript/Maths/GetEuclidGCD.js)
		GridGet.js,f(e=utama=C:/work/algos/Javascript/Maths/GridGet.js)
		IsDivisible.js,f(e=utama=C:/work/algos/Javascript/Maths/IsDivisible.js)
		IsEven.js,f(e=utama=C:/work/algos/Javascript/Maths/IsEven.js)
		IsOdd.js,f(e=utama=C:/work/algos/Javascript/Maths/IsOdd.js)
		LeapYear.js,f(e=utama=C:/work/algos/Javascript/Maths/LeapYear.js)
		LinearSieve.js,f(e=utama=C:/work/algos/Javascript/Maths/LinearSieve.js)
		LucasSeries.js,f(e=utama=C:/work/algos/Javascript/Maths/LucasSeries.js)
		Mandelbrot.js,f(e=utama=C:/work/algos/Javascript/Maths/Mandelbrot.js)
		MatrixExponentiationRecursive.js,f(e=utama=C:/work/algos/Javascript/Maths/MatrixExponentiationRecursive.js)
		MatrixMultiplication.js,f(e=utama=C:/work/algos/Javascript/Maths/MatrixMultiplication.js)
		MeanSquareError.js,f(e=utama=C:/work/algos/Javascript/Maths/MeanSquareError.js)
		MidpointIntegration.js,f(e=utama=C:/work/algos/Javascript/Maths/MidpointIntegration.js)
		ModularBinaryExponentiationRecursive.js,f(e=utama=C:/work/algos/Javascript/Maths/ModularBinaryExponentiationRecursive.js)
		NumberOfDigits.js,f(e=utama=C:/work/algos/Javascript/Maths/NumberOfDigits.js)
		Palindrome.js,f(e=utama=C:/work/algos/Javascript/Maths/Palindrome.js)
		PascalTriangle.js,f(e=utama=C:/work/algos/Javascript/Maths/PascalTriangle.js)
		PerfectCube.js,f(e=utama=C:/work/algos/Javascript/Maths/PerfectCube.js)
		PerfectNumber.js,f(e=utama=C:/work/algos/Javascript/Maths/PerfectNumber.js)
		PerfectSquare.js,f(e=utama=C:/work/algos/Javascript/Maths/PerfectSquare.js)
		PermutationAndCombination.js,f(e=utama=C:/work/algos/Javascript/Maths/PermutationAndCombination.js)
		PiApproximationMonteCarlo.js,f(e=utama=C:/work/algos/Javascript/Maths/PiApproximationMonteCarlo.js)
		Polynomial.js,f(e=utama=C:/work/algos/Javascript/Maths/Polynomial.js)
		Pow.js,f(e=utama=C:/work/algos/Javascript/Maths/Pow.js)
		PowLogarithmic.js,f(e=utama=C:/work/algos/Javascript/Maths/PowLogarithmic.js)
		PrimeCheck.js,f(e=utama=C:/work/algos/Javascript/Maths/PrimeCheck.js)
		PrimeFactors.js,f(e=utama=C:/work/algos/Javascript/Maths/PrimeFactors.js)
		RadianToDegree.js,f(e=utama=C:/work/algos/Javascript/Maths/RadianToDegree.js)
		ReverseNumber.js,f(e=utama=C:/work/algos/Javascript/Maths/ReverseNumber.js)
		ReversePolishNotation.js,f(e=utama=C:/work/algos/Javascript/Maths/ReversePolishNotation.js)
		SieveOfEratosthenes.js,f(e=utama=C:/work/algos/Javascript/Maths/SieveOfEratosthenes.js)
		SimpsonIntegration.js,f(e=utama=C:/work/algos/Javascript/Maths/SimpsonIntegration.js)
		Softmax.js,f(e=utama=C:/work/algos/Javascript/Maths/Softmax.js)
		SquareRoot.js,f(e=utama=C:/work/algos/Javascript/Maths/SquareRoot.js)
		SumOfDigits.js,f(e=utama=C:/work/algos/Javascript/Maths/SumOfDigits.js)
		SumOfGeometricProgression.js,f(e=utama=C:/work/algos/Javascript/Maths/SumOfGeometricProgression.js)
		Volume.js,f(e=utama=C:/work/algos/Javascript/Maths/Volume.js)
		WhileLoopFactorial.js,f(e=utama=C:/work/algos/Javascript/Maths/WhileLoopFactorial.js)
		test,d(/mk)
			Abs.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Abs.test.js)
			AliquotSum.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/AliquotSum.test.js)
			Area.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Area.test.js)
			ArmstrongNumber.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/ArmstrongNumber.test.js)
			AverageMean.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/AverageMean.test.js)
			AverageMedian.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/AverageMedian.test.js)
			BInaryConvert.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/BInaryConvert.test.js)
			BinaryExponentiationIterative.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/BinaryExponentiationIterative.test.js)
			BinaryExponentiationRecursive.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/BinaryExponentiationRecursive.test.js)
			BisectionMethod.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/BisectionMethod.test.js)
			Coordinate.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Coordinate.test.js)
			DegreeToRadian.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/DegreeToRadian.test.js)
			EulerMethod.manual-test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/EulerMethod.manual-test.js)
			EulerMethod.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/EulerMethod.test.js)
			EulersTotient.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/EulersTotient.test.js)
			EulersTotientFunction.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/EulersTotientFunction.test.js)
			ExtendedEuclideanGCD.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/ExtendedEuclideanGCD.test.js)
			Factorial.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Factorial.test.js)
			Factors.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Factors.test.js)
			FareyApproximation.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/FareyApproximation.test.js)
			FermatPrimalityTest.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/FermatPrimalityTest.test.js)
			Fibonacci.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Fibonacci.test.js)
			FigurateNumber.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/FigurateNumber.test.js)
			FindHcf.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/FindHcf.test.js)
			FindLcm.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/FindLcm.test.js)
			FindMin.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/FindMin.test.js)
			GridGet.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/GridGet.test.js)
			IsDivisible.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/IsDivisible.test.js)
			IsEven.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/IsEven.test.js)
			LeapYear.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/LeapYear.test.js)
			LinearSieve.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/LinearSieve.test.js)
			LucasSeries.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/LucasSeries.test.js)
			Mandelbrot.manual-test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Mandelbrot.manual-test.js)
			Mandelbrot.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Mandelbrot.test.js)
			MeanSquareError.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/MeanSquareError.test.js)
			MidpointIntegration.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/MidpointIntegration.test.js)
			ModularBinaryExponentiationRecursive.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/ModularBinaryExponentiationRecursive.test.js)
			NumberOfDigits.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/NumberOfDigits.test.js)
			Palindrome.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Palindrome.test.js)
			PascalTriangle.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PascalTriangle.test.js)
			PerfectCube.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PerfectCube.test.js)
			PerfectNumber.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PerfectNumber.test.js)
			PerfectSquare.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PerfectSquare.test.js)
			PermutationAndCombination.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PermutationAndCombination.test.js)
			PiApproximationMonteCarlo.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PiApproximationMonteCarlo.test.js)
			Polynomial.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Polynomial.test.js)
			Pow.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Pow.test.js)
			PowLogarithmic.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PowLogarithmic.test.js)
			PrimeCheck.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PrimeCheck.test.js)
			PrimeFactors.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/PrimeFactors.test.js)
			RadianToDegree.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/RadianToDegree.test.js)
			ReversePolishNotation.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/ReversePolishNotation.test.js)
			SieveOfEratosthenes.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/SieveOfEratosthenes.test.js)
			SimpsonIntegration.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/SimpsonIntegration.test.js)
			Softmax.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Softmax.test.js)
			SumOfDigits.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/SumOfDigits.test.js)
			SumOfGeometricProgression.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/SumOfGeometricProgression.test.js)
			Volume.test.js,f(e=utama=C:/work/algos/Javascript/Maths/test/Volume.test.js)
	Navigation,d(/mk)
		Haversine.js,f(e=utama=C:/work/algos/Javascript/Navigation/Haversine.js)
		test,d(/mk)
			Haversine.test.js,f(e=utama=C:/work/algos/Javascript/Navigation/test/Haversine.test.js)
	Project-Euler,d(/mk)
		Problem001.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem001.js)
		Problem002.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem002.js)
		Problem003.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem003.js)
		Problem004.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem004.js)
		Problem005.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem005.js)
		Problem006.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem006.js)
		Problem008.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem008.js)
		Problem009.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem009.js)
		Problem010.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem010.js)
		Problem012.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem012.js)
		Problem014.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem014.js)
		Problem015.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem015.js)
		Problem016.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem016.js)
		Problem018.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem018.js)
		Problem020.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem020.js)
		Problem023.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem023.js)
		Problem025.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/Problem025.js)
		test,d(/mk)
			Problem008.test.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/test/Problem008.test.js)
			Problem010.test.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/test/Problem010.test.js)
			Problem012.test.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/test/Problem012.test.js)
			Problem016.test.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/test/Problem016.test.js)
			Problem018.test.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/test/Problem018.test.js)
			Problem020.test.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/test/Problem020.test.js)
			Problem023.test.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/test/Problem023.test.js)
			Problem025.test.js,f(e=utama=C:/work/algos/Javascript/Project-Euler/test/Problem025.test.js)
	Recursive,d(/mk)
		BinaryEquivalent.js,f(e=utama=C:/work/algos/Javascript/Recursive/BinaryEquivalent.js)
		BinarySearch.js,f(e=utama=C:/work/algos/Javascript/Recursive/BinarySearch.js)
		EucledianGCD.js,f(e=utama=C:/work/algos/Javascript/Recursive/EucledianGCD.js)
		Factorial.js,f(e=utama=C:/work/algos/Javascript/Recursive/Factorial.js)
		FibonacciNumberRecursive.js,f(e=utama=C:/work/algos/Javascript/Recursive/FibonacciNumberRecursive.js)
		FloodFill.js,f(e=utama=C:/work/algos/Javascript/Recursive/FloodFill.js)
		KochSnowflake.js,f(e=utama=C:/work/algos/Javascript/Recursive/KochSnowflake.js)
		KochSnowflake.manual-test.js,f(e=utama=C:/work/algos/Javascript/Recursive/KochSnowflake.manual-test.js)
		Palindrome.js,f(e=utama=C:/work/algos/Javascript/Recursive/Palindrome.js)
		SubsequenceRecursive.js,f(e=utama=C:/work/algos/Javascript/Recursive/SubsequenceRecursive.js)
		TowerOfHanoi.js,f(e=utama=C:/work/algos/Javascript/Recursive/TowerOfHanoi.js)
		test,d(/mk)
			BinarySearch.test.js,f(e=utama=C:/work/algos/Javascript/Recursive/test/BinarySearch.test.js)
			Factorial.test.js,f(e=utama=C:/work/algos/Javascript/Recursive/test/Factorial.test.js)
			FibonacciNumberRecursive.test.js,f(e=utama=C:/work/algos/Javascript/Recursive/test/FibonacciNumberRecursive.test.js)
			FloodFill.test.js,f(e=utama=C:/work/algos/Javascript/Recursive/test/FloodFill.test.js)
			KochSnowflake.test.js,f(e=utama=C:/work/algos/Javascript/Recursive/test/KochSnowflake.test.js)
			palindrome.test.js,f(e=utama=C:/work/algos/Javascript/Recursive/test/palindrome.test.js)
	Search,d(/mk)
		BinarySearch.js,f(e=utama=C:/work/algos/Javascript/Search/BinarySearch.js)
		ExponentialSearch.js,f(e=utama=C:/work/algos/Javascript/Search/ExponentialSearch.js)
		FibonacciSearch.js,f(e=utama=C:/work/algos/Javascript/Search/FibonacciSearch.js)
		InterpolationSearch.js,f(e=utama=C:/work/algos/Javascript/Search/InterpolationSearch.js)
		JumpSearch.js,f(e=utama=C:/work/algos/Javascript/Search/JumpSearch.js)
		LinearSearch.js,f(e=utama=C:/work/algos/Javascript/Search/LinearSearch.js)
		QuickSelectSearch.js,f(e=utama=C:/work/algos/Javascript/Search/QuickSelectSearch.js)
		SlidingWindow.js,f(e=utama=C:/work/algos/Javascript/Search/SlidingWindow.js)
		StringSearch.js,f(e=utama=C:/work/algos/Javascript/Search/StringSearch.js)
		TernarySearch.js,f(e=utama=C:/work/algos/Javascript/Search/TernarySearch.js)
		UnionFind.js,f(e=utama=C:/work/algos/Javascript/Search/UnionFind.js)
		test,d(/mk)
			SlidingWindow.test.js,f(e=utama=C:/work/algos/Javascript/Search/test/SlidingWindow.test.js)
			TernarySearch.test.js,f(e=utama=C:/work/algos/Javascript/Search/test/TernarySearch.test.js)
			UnionFind.test.js,f(e=utama=C:/work/algos/Javascript/Search/test/UnionFind.test.js)
	Sorts,d(/mk)
		AlphaNumericalSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/AlphaNumericalSort.js)
		BeadSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/BeadSort.js)
		BogoSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/BogoSort.js)
		BubbleSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/BubbleSort.js)
		BucketSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/BucketSort.js)
		CocktailShakerSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/CocktailShakerSort.js)
		CombSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/CombSort.js)
		CountingSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/CountingSort.js)
		CycleSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/CycleSort.js)
		FindSecondLargestElement.js,f(e=utama=C:/work/algos/Javascript/Sorts/FindSecondLargestElement.js)
		FisherYatesShuffle.js,f(e=utama=C:/work/algos/Javascript/Sorts/FisherYatesShuffle.js)
		FlashSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/FlashSort.js)
		GnomeSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/GnomeSort.js)
		HeapSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/HeapSort.js)
		HeapSortV2.js,f(e=utama=C:/work/algos/Javascript/Sorts/HeapSortV2.js)
		InsertionSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/InsertionSort.js)
		IntroSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/IntroSort.js)
		MergeSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/MergeSort.js)
		OddEvenSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/OddEvenSort.js)
		PancakeSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/PancakeSort.js)
		PigeonHoleSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/PigeonHoleSort.js)
		QuickSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/QuickSort.js)
		QuickSortRecursive.js,f(e=utama=C:/work/algos/Javascript/Sorts/QuickSortRecursive.js)
		RadixSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/RadixSort.js)
		SelectionSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/SelectionSort.js)
		ShellSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/ShellSort.js)
		TimSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/TimSort.js)
		TopologicalSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/TopologicalSort.js)
		WiggleSort.js,f(e=utama=C:/work/algos/Javascript/Sorts/WiggleSort.js)
		test,d(/mk)
			AlphaNumericalSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/AlphaNumericalSort.test.js)
			BeadSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/BeadSort.test.js)
			BogoSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/BogoSort.test.js)
			BubbleSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/BubbleSort.test.js)
			BucketSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/BucketSort.test.js)
			CocktailShakerSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/CocktailShakerSort.test.js)
			CombSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/CombSort.test.js)
			CycleSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/CycleSort.test.js)
			FisherYatesShuffle.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/FisherYatesShuffle.test.js)
			MergeSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/MergeSort.test.js)
			PancakeSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/PancakeSort.test.js)
			QuickSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/QuickSort.test.js)
			QuickSortRecursive.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/QuickSortRecursive.test.js)
			SelectionSort.test.js,f(e=utama=C:/work/algos/Javascript/Sorts/test/SelectionSort.test.js)
	String,d(/mk)
		AlphaNumericPalindrome.js,f(e=utama=C:/work/algos/Javascript/String/AlphaNumericPalindrome.js)
		AlternativeStringArrange.js,f(e=utama=C:/work/algos/Javascript/String/AlternativeStringArrange.js)
		CheckAnagram.js,f(e=utama=C:/work/algos/Javascript/String/CheckAnagram.js)
		CheckCamelCase.js,f(e=utama=C:/work/algos/Javascript/String/CheckCamelCase.js)
		CheckFlatCase.js,f(e=utama=C:/work/algos/Javascript/String/CheckFlatCase.js)
		CheckKebabCase.js,f(e=utama=C:/work/algos/Javascript/String/CheckKebabCase.js)
		CheckPalindrome.js,f(e=utama=C:/work/algos/Javascript/String/CheckPalindrome.js)
		CheckPangram.js,f(e=utama=C:/work/algos/Javascript/String/CheckPangram.js)
		CheckPascalCase.js,f(e=utama=C:/work/algos/Javascript/String/CheckPascalCase.js)
		CheckRearrangePalindrome.js,f(e=utama=C:/work/algos/Javascript/String/CheckRearrangePalindrome.js)
		CheckSnakeCase.js,f(e=utama=C:/work/algos/Javascript/String/CheckSnakeCase.js)
		CheckWordOccurrence.js,f(e=utama=C:/work/algos/Javascript/String/CheckWordOccurrence.js)
		CountVowels.js,f(e=utama=C:/work/algos/Javascript/String/CountVowels.js)
		CreatePermutations.js,f(e=utama=C:/work/algos/Javascript/String/CreatePermutations.js)
		DiceCoefficient.js,f(e=utama=C:/work/algos/Javascript/String/DiceCoefficient.js)
		FormatPhoneNumber.js,f(e=utama=C:/work/algos/Javascript/String/FormatPhoneNumber.js)
		GenerateGUID.js,f(e=utama=C:/work/algos/Javascript/String/GenerateGUID.js)
		HammingDistance.js,f(e=utama=C:/work/algos/Javascript/String/HammingDistance.js)
		KMPPatternSearching.js,f(e=utama=C:/work/algos/Javascript/String/KMPPatternSearching.js)
		LevenshteinDistance.js,f(e=utama=C:/work/algos/Javascript/String/LevenshteinDistance.js)
		Lower.js,f(e=utama=C:/work/algos/Javascript/String/Lower.js)
		MaxCharacter.js,f(e=utama=C:/work/algos/Javascript/String/MaxCharacter.js)
		MaxWord.js,f(e=utama=C:/work/algos/Javascript/String/MaxWord.js)
		PatternMatching.js,f(e=utama=C:/work/algos/Javascript/String/PatternMatching.js)
		PermutateString.js,f(e=utama=C:/work/algos/Javascript/String/PermutateString.js)
		ReverseString.js,f(e=utama=C:/work/algos/Javascript/String/ReverseString.js)
		ReverseWords.js,f(e=utama=C:/work/algos/Javascript/String/ReverseWords.js)
		ScrambleStrings.js,f(e=utama=C:/work/algos/Javascript/String/ScrambleStrings.js)
		Upper.js,f(e=utama=C:/work/algos/Javascript/String/Upper.js)
		ValidateCreditCard.js,f(e=utama=C:/work/algos/Javascript/String/ValidateCreditCard.js)
		ValidateEmail.js,f(e=utama=C:/work/algos/Javascript/String/ValidateEmail.js)
		ValidateUrl.js,f(e=utama=C:/work/algos/Javascript/String/ValidateUrl.js)
		test,d(/mk)
			AlphaNumericPalindrome.test.js,f(e=utama=C:/work/algos/Javascript/String/test/AlphaNumericPalindrome.test.js)
			CheckAnagram.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CheckAnagram.test.js)
			CheckCamelCase.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CheckCamelCase.test.js)
			CheckFlatCase.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CheckFlatCase.test.js)
			CheckPalindrome.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CheckPalindrome.test.js)
			CheckPangram.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CheckPangram.test.js)
			CheckSnakeCase.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CheckSnakeCase.test.js)
			CheckWordOcurrence.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CheckWordOcurrence.test.js)
			CountVowels.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CountVowels.test.js)
			CreatePermutations.test.js,f(e=utama=C:/work/algos/Javascript/String/test/CreatePermutations.test.js)
			DiceCoefficient.test.js,f(e=utama=C:/work/algos/Javascript/String/test/DiceCoefficient.test.js)
			FormatPhoneNumber.test.js,f(e=utama=C:/work/algos/Javascript/String/test/FormatPhoneNumber.test.js)
			HammingDistance.test.js,f(e=utama=C:/work/algos/Javascript/String/test/HammingDistance.test.js)
			KMPPatternSearching.test.js,f(e=utama=C:/work/algos/Javascript/String/test/KMPPatternSearching.test.js)
			LevenshteinDistance.test.js,f(e=utama=C:/work/algos/Javascript/String/test/LevenshteinDistance.test.js)
			Lower.test.js,f(e=utama=C:/work/algos/Javascript/String/test/Lower.test.js)
			MaxCharacter.test.js,f(e=utama=C:/work/algos/Javascript/String/test/MaxCharacter.test.js)
			MaxWord.test.js,f(e=utama=C:/work/algos/Javascript/String/test/MaxWord.test.js)
			PatternMatching.test.js,f(e=utama=C:/work/algos/Javascript/String/test/PatternMatching.test.js)
			PermutateString.test.js,f(e=utama=C:/work/algos/Javascript/String/test/PermutateString.test.js)
			ReverseString.test.js,f(e=utama=C:/work/algos/Javascript/String/test/ReverseString.test.js)
			ReverseWords.test.js,f(e=utama=C:/work/algos/Javascript/String/test/ReverseWords.test.js)
			ScrambleStrings.test.js,f(e=utama=C:/work/algos/Javascript/String/test/ScrambleStrings.test.js)
			Upper.test.js,f(e=utama=C:/work/algos/Javascript/String/test/Upper.test.js)
			ValidateCreditCard.test.js,f(e=utama=C:/work/algos/Javascript/String/test/ValidateCreditCard.test.js)
			ValidateEmail.test.js,f(e=utama=C:/work/algos/Javascript/String/test/ValidateEmail.test.js)
			ValidateUrl.test.js,f(e=utama=C:/work/algos/Javascript/String/test/ValidateUrl.test.js)
	Timing-Functions,d(/mk)
		GetMonthDays.js,f(e=utama=C:/work/algos/Javascript/Timing-Functions/GetMonthDays.js)
		IntervalTimer.js,f(e=utama=C:/work/algos/Javascript/Timing-Functions/IntervalTimer.js)
		test,d(/mk)
			GetMonthDays.test.js,f(e=utama=C:/work/algos/Javascript/Timing-Functions/test/GetMonthDays.test.js)
	Trees,d(/mk)
		BreadthFirstTreeTraversal.js,f(e=utama=C:/work/algos/Javascript/Trees/BreadthFirstTreeTraversal.js)
		DepthFirstSearch.js,f(e=utama=C:/work/algos/Javascript/Trees/DepthFirstSearch.js)
		FenwickTree.js,f(e=utama=C:/work/algos/Javascript/Trees/FenwickTree.js)
		test,d(/mk)
			BreadthFirstTreeTraversal.test.js,f(e=utama=C:/work/algos/Javascript/Trees/test/BreadthFirstTreeTraversal.test.js)
			FenwickTree.test.js,f(e=utama=C:/work/algos/Javascript/Trees/test/FenwickTree.test.js)
--#

--% C:/work/algos/Javascript/.gitignore
# dependencies
/node_modules

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

# intelliJ workspace folder
.idea

--#

--% C:/work/algos/Javascript/.gitpod.yml
tasks:
  - init: npm install
  

--#

--% C:/work/algos/Javascript/.prettierrc
{
  "arrowParens": "always",
  "bracketSpacing": true,
  "endOfLine": "lf",
  "insertPragma": false,
  "printWidth": 80,
  "proseWrap": "preserve",
  "quoteProps": "as-needed",
  "requirePragma": false,
  "semi": false,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "none",
  "useTabs": false
}

--#

--% C:/work/algos/Javascript/babel.config.cjs
module.exports = {
  presets: [
    [
      '@babel/preset-env',
      {
        targets: {
          esmodules: true
        }
      }
    ]
  ]
}

--#

--% C:/work/algos/Javascript/CONTRIBUTING.md
# Contributing guidelines

## Before contributing

Welcome to [TheAlgorithms/Javascript](https://github.com/TheAlgorithms/Javascript)! Before sending your pull requests,
make sure that you **read the whole guidelines**. If you have any doubt on the contributing guide, please feel free to
[state it clearly in an issue](https://github.com/TheAlgorithms/Javascript/issues/new).

## Contributing

### Contributor

We are very happy that you consider implementing algorithms and data structures for others! This repository is
referenced and used by learners from around the globe. Being one of our contributors, you agree and confirm that:

* You did your work - plagiarism is not allowed.
    * Any plagiarized work will not be merged.
* Your work will be distributed under [GNU License](LICENSE) once your pull request is merged.
* Your submitted work must fulfill our styles and standards.

**New implementation** is welcome! For example, new solutions to a problem, different representations of a graph data
structure or algorithm designs with different complexity.

**Improving comments** and **writing proper tests** are also highly welcome.

### Contribution

We appreciate any contribution, from fixing grammar mistakes to implementing complex algorithms. Please read this
section if you are contributing to your work.

If you submit a pull request that resolves an open issue, please help us to keep our issue list small by adding
`fixes: #{$ISSUE_NO}` to your commit message. GitHub will use this tag to auto-close the issue if your PR is merged.

#### What is an Algorithm?

An Algorithm is one or more functions (or classes) that:

* take one or more inputs,
* perform some internal calculations or data manipulations,
* return one or more outputs,
* have minimal side effects.

Algorithms should be packaged in a way that would make it easy for readers to put them into larger programs.

Algorithms should:

* have intuitive class and function names that make their purpose clear to readers
* use JavaScript naming conventions and intuitive variable names to ease comprehension
* be flexible to take different input values
* raise JavaScript exceptions (RangeError, etc.) on erroneous input values

Algorithms in this repo should not be how-to examples for existing JavaScript packages. Instead, they should perform
internal calculations or manipulations to convert input values into different output values. Those calculations or
manipulations can use data types, classes, or functions of existing JavaScript packages but each algorithm in this repo
should add unique value.

#### File Naming Convention

* filenames should use the UpperCamelCase (PascalCase) style.
* There should be no spaces in filenames.
* **Example:**`UserProfile.js` is allowed but `userprofile.js`,`Userprofile.js`,`user-Profile.js`,`userProfile.js` are
  not.

#### Module System

We use the [ES Module](https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/) system, which bring an official, standardized module system to JavaScript.

It roughly means you will need to use `export` and `import` statements instead of `module.exports` and `require()`.

#### Testing

Be confident that your code works. When was the last time you committed a code change, your build failed, and half of
your app stopped working? Mine was last week. Writing tests for our Algorithms will help us ensure the implementations
are air tight even after multiple fixes and code changes.

We use [Jest](https://jestjs.io/) to run unit tests on our algorithms. It provides a very readable and expressive way to
structure your test code.

It is advised that the algorithm file (module) does not contain any "live" code but rather just exports the function(s)
needed to execute the algorithm. Your test code can import those function(s), call them with the appropriate parameters
and inspect the outcome. Example: [RatInAMaze.test.js](Backtracking/tests/RatInAMaze.test.js).

Please refrain from using `console` in your implementation AND test code.

You can (and should!) run all tests locally before committing your changes:

```shell
npm test
```

If you want save some time and just run a specific test:

```shell
# this will run any test file where the filename matches "koch"
npm test -- koch
```

You can also start Jest in "watch" mode:

```shell
npm test -- --watchAll
```

This will run all tests and watch source and test files for changes. When a change is made, the tests will run again.

#### Coding Style

To maximize the readability and correctness of our code, we require that new submissions follow the
[JavaScript Standard Style](https://standardjs.com/).

Before committing, please run

```shell
npm run style
```

in order to apply the coding style (where it can be done automatically). If an error is shown, please figure out what's
wrong, fix it and run standard again.

A few (but not all) of the things to keep in mind:

* Use camelCase with the leading character as lowercase for identifier names (variables and functions)
* Names start with a letter
* Follow code indentation: Always use 2 spaces for indentation of code blocks
```js
function sumOfArray (arrayOfNumbers) {
  let sum = 0
  for (let i = 0; i < arrayOfNumbers.length; i++) {
    sum += arrayOfNumbers[i]
  }
  return (sum)
}
```
*
* Avoid using global variables and avoid `==`
* Please use `let` over `var`
* Please refrain from using `console.log` or any other console methods
* **Absolutely** don't use `alert`
* We strongly recommend the use of ECMAScript 6
* Avoid importing external libraries for basic algorithms. Only use those libraries for complicated algorithms
* Most importantly:
    * **Be consistent in the use of these guidelines when submitting**
    * Happy coding!

Writer [@itsvinayak](https://github.com/itsvinayak), May 2020.

--#

--% C:/work/algos/Javascript/DIRECTORY.md

## Backtracking
  * [AllCombinationsOfSizeK](https://github.com/TheAlgorithms/Javascript/blob/master/Backtracking/AllCombinationsOfSizeK.js)
  * [GeneratePermutations](https://github.com/TheAlgorithms/Javascript/blob/master/Backtracking/GeneratePermutations.js)
  * [KnightTour](https://github.com/TheAlgorithms/Javascript/blob/master/Backtracking/KnightTour.js)
  * [NQueen](https://github.com/TheAlgorithms/Javascript/blob/master/Backtracking/NQueen.js)
  * [RatInAMaze](https://github.com/TheAlgorithms/Javascript/blob/master/Backtracking/RatInAMaze.js)
  * [Sudoku](https://github.com/TheAlgorithms/Javascript/blob/master/Backtracking/Sudoku.js)
  * [SumOfSubset](https://github.com/TheAlgorithms/Javascript/blob/master/Backtracking/SumOfSubset.js)

## Bit-Manipulation
  * [BinaryCountSetBits](https://github.com/TheAlgorithms/Javascript/blob/master/Bit-Manipulation/BinaryCountSetBits.js)
  * [IsPowerOfTwo](https://github.com/TheAlgorithms/Javascript/blob/master/Bit-Manipulation/IsPowerOfTwo.js)
  * [NextPowerOfTwo](https://github.com/TheAlgorithms/Javascript/blob/master/Bit-Manipulation/NextPowerOfTwo.js)
  * [SetBit](https://github.com/TheAlgorithms/Javascript/blob/master/Bit-Manipulation/SetBit.js)

## Cache
  * [LFUCache](https://github.com/TheAlgorithms/Javascript/blob/master/Cache/LFUCache.js)
  * [LRUCache](https://github.com/TheAlgorithms/Javascript/blob/master/Cache/LRUCache.js)
  * [Memoize](https://github.com/TheAlgorithms/Javascript/blob/master/Cache/Memoize.js)

## Cellular-Automata
  * [ConwaysGameOfLife](https://github.com/TheAlgorithms/Javascript/blob/master/Cellular-Automata/ConwaysGameOfLife.js)

## Ciphers
  * [Atbash](https://github.com/TheAlgorithms/Javascript/blob/master/Ciphers/Atbash.js)
  * [CaesarsCipher](https://github.com/TheAlgorithms/Javascript/blob/master/Ciphers/CaesarsCipher.js)
  * [KeyFinder](https://github.com/TheAlgorithms/Javascript/blob/master/Ciphers/KeyFinder.js)
  * [KeywordShiftedAlphabet](https://github.com/TheAlgorithms/Javascript/blob/master/Ciphers/KeywordShiftedAlphabet.js)
  * [ROT13](https://github.com/TheAlgorithms/Javascript/blob/master/Ciphers/ROT13.js)
  * [VigenereCipher](https://github.com/TheAlgorithms/Javascript/blob/master/Ciphers/VigenereCipher.js)
  * [XORCipher](https://github.com/TheAlgorithms/Javascript/blob/master/Ciphers/XORCipher.js)

## Conversions
  * [ArbitraryBase](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/ArbitraryBase.js)
  * [ArrayBufferToBase64](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/ArrayBufferToBase64.js)
  * [Base64ToArrayBuffer](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/Base64ToArrayBuffer.js)
  * [BinaryToDecimal](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/BinaryToDecimal.js)
  * [BinaryToHex](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/BinaryToHex.js)
  * [DateDayDifference](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DateDayDifference.js)
  * [DateToDay](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DateToDay.js)
  * [DecimalToBinary](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DecimalToBinary.js)
  * [DecimalToHex](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DecimalToHex.js)
  * [DecimalToOctal](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DecimalToOctal.js)
  * [DecimalToRoman](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/DecimalToRoman.js)
  * [HexToBinary](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/HexToBinary.js)
  * [HexToDecimal](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/HexToDecimal.js)
  * [HexToRGB](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/HexToRGB.js)
  * [LowerCaseConversion](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/LowerCaseConversion.js)
  * [MeterToFeetConversion](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/MeterToFeetConversion.js)
  * [OctToDecimal](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/OctToDecimal.js)
  * [RailwayTimeConversion](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/RailwayTimeConversion.js)
  * [RgbHsvConversion](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/RgbHsvConversion.js)
  * [RGBToHex](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/RGBToHex.js)
  * [RomanToDecimal](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/RomanToDecimal.js)
  * [TemperatureConversion](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/TemperatureConversion.js)
  * [TitleCaseConversion](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/TitleCaseConversion.js)
  * [UpperCaseConversion](https://github.com/TheAlgorithms/Javascript/blob/master/Conversions/UpperCaseConversion.js)

## Data-Structures
  * Array
    * [LocalMaximomPoint](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Array/LocalMaximomPoint.js)
    * [NumberOfLocalMaximumPoints](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Array/NumberOfLocalMaximumPoints.js)
    * [QuickSelect](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Array/QuickSelect.js)
  * Graph
    * [Graph](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Graph/Graph.js)
    * [Graph2](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Graph/Graph2.js)
  * Heap
    * [MaxHeap](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Heap/MaxHeap.js)
    * [MinHeap](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Heap/MinHeap.js)
    * [MinPriorityQueue](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Heap/MinPriorityQueue.js)
  * Linked-List
    * [CycleDetection](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Linked-List/CycleDetection.js)
    * [DoublyLinkedList](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Linked-List/DoublyLinkedList.js)
    * [RotateListRight](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Linked-List/RotateListRight.js)
    * [SingleCircularLinkedList](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Linked-List/SingleCircularLinkedList.js.js)
    * [SinglyLinkedList](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Linked-List/SinglyLinkedList.js)
  * Queue
    * [CircularQueue](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Queue/CircularQueue.js)
    * [Queue](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Queue/Queue.js)
    * [QueueUsing2Stacks](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Queue/QueueUsing2Stacks.js)
  * Stack
    * [Stack](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Stack/Stack.js)
    * [StackES6](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Stack/StackES6.js)
  * Tree
    * [AVLTree](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Tree/AVLTree.js)
    * [BinarySearchTree](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Tree/BinarySearchTree.js)
    * [Trie](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Tree/Trie.js)
  * Vectors
    * [Vector2](https://github.com/TheAlgorithms/Javascript/blob/master/Data-Structures/Vectors/Vector2.js)

## Dynamic-Programming
  * [ClimbingStairs](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/ClimbingStairs.js)
  * [CoinChange](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/CoinChange.js)
  * [EditDistance](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/EditDistance.js)
  * [FibonacciNumber](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/FibonacciNumber.js)
  * [FindMonthCalendar](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/FindMonthCalendar.js)
  * [KadaneAlgo](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/KadaneAlgo.js)
  * [LevenshteinDistance](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/LevenshteinDistance.js)
  * [LongestCommonSubsequence](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/LongestCommonSubsequence.js)
  * [LongestIncreasingSubsequence](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/LongestIncreasingSubsequence.js)
  * [LongestPalindromicSubsequence](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/LongestPalindromicSubsequence.js)
  * [LongestValidParentheses](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/LongestValidParentheses.js)
  * [MaxNonAdjacentSum](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/MaxNonAdjacentSum.js)
  * [MaxProductOfThree](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/MaxProductOfThree.js)
  * [MinimumCostPath](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/MinimumCostPath.js)
  * [NumberOfSubsetEqualToGivenSum](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/NumberOfSubsetEqualToGivenSum.js)
  * [RodCutting](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/RodCutting.js)
  * [Shuf](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/Shuf.js)
  * [SieveOfEratosthenes](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/SieveOfEratosthenes.js)
  * Sliding-Window
    * [LongestSubstringWithoutRepeatingCharacters](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/Sliding-Window/LongestSubstringWithoutRepeatingCharacters.js)
    * [PermutationinString](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/Sliding-Window/PermutationinString.js)
  * [SudokuSolver](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/SudokuSolver.js)
  * [TrappingRainWater](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/TrappingRainWater.js)
  * [TribonacciNumber](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/TribonacciNumber.js)
  * [ZeroOneKnapsack](https://github.com/TheAlgorithms/Javascript/blob/master/Dynamic-Programming/ZeroOneKnapsack.js)

## Geometry
  * [ConvexHullGraham](https://github.com/TheAlgorithms/Javascript/blob/master/Geometry/ConvexHullGraham.js)

## Graphs
  * [BellmanFord](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/BellmanFord.js)
  * [BreadthFirstSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/BreadthFirstSearch.js)
  * [BreadthFirstShortestPath](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/BreadthFirstShortestPath.js)
  * [ConnectedComponents](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/ConnectedComponents.js)
  * [Density](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/Density.js)
  * [DepthFirstSearchIterative](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/DepthFirstSearchIterative.js)
  * [DepthFirstSearchRecursive](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/DepthFirstSearchRecursive.js)
  * [Dijkstra](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/Dijkstra.js)
  * [DijkstraSmallestPath](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/DijkstraSmallestPath.js)
  * [FloydWarshall](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/FloydWarshall.js)
  * [KruskalMST](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/KruskalMST.js)
  * [NodeNeighbors](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/NodeNeighbors.js)
  * [NumberOfIslands](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/NumberOfIslands.js)
  * [PrimMST](https://github.com/TheAlgorithms/Javascript/blob/master/Graphs/PrimMST.js)

## Hashes
  * [SHA1](https://github.com/TheAlgorithms/Javascript/blob/master/Hashes/SHA1.js)
  * [SHA256](https://github.com/TheAlgorithms/Javascript/blob/master/Hashes/SHA256.js)

## Maths
  * [Abs](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Abs.js)
  * [AliquotSum](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/AliquotSum.js)
  * [Area](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Area.js)
  * [ArmstrongNumber](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/ArmstrongNumber.js)
  * [AverageMean](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/AverageMean.js)
  * [AverageMedian](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/AverageMedian.js)
  * [BinaryConvert](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/BinaryConvert.js)
  * [BinaryExponentiationIterative](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/BinaryExponentiationIterative.js)
  * [BinaryExponentiationRecursive](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/BinaryExponentiationRecursive.js)
  * [BisectionMethod](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/BisectionMethod.js)
  * [CheckKishnamurthyNumber](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/CheckKishnamurthyNumber.js)
  * [Coordinate](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Coordinate.js)
  * [CoPrimeCheck](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/CoPrimeCheck.js)
  * [DecimalIsolate](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/DecimalIsolate.js)
  * [DegreeToRadian](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/DegreeToRadian.js)
  * [EulerMethod](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/EulerMethod.js)
  * [EulersTotient](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/EulersTotient.js)
  * [EulersTotientFunction](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/EulersTotientFunction.js)
  * [ExtendedEuclideanGCD](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/ExtendedEuclideanGCD.js)
  * [Factorial](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Factorial.js)
  * [Factors](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Factors.js)
  * [FareyApproximation](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/FareyApproximation.js)
  * [FermatPrimalityTest](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/FermatPrimalityTest.js)
  * [Fibonacci](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Fibonacci.js)
  * [FigurateNumber](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/FigurateNumber.js)
  * [FindHcf](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/FindHcf.js)
  * [FindLcm](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/FindLcm.js)
  * [FindMin](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/FindMin.js)
  * [GetEuclidGCD](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/GetEuclidGCD.js)
  * [GridGet](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/GridGet.js)
  * [IsDivisible](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/IsDivisible.js)
  * [IsEven](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/IsEven.js)
  * [IsOdd](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/IsOdd.js)
  * [LeapYear](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/LeapYear.js)
  * [LinearSieve](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/LinearSieve.js)
  * [LucasSeries](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/LucasSeries.js)
  * [Mandelbrot](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Mandelbrot.js)
  * [MatrixExponentiationRecursive](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/MatrixExponentiationRecursive.js)
  * [MatrixMultiplication](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/MatrixMultiplication.js)
  * [MeanSquareError](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/MeanSquareError.js)
  * [MidpointIntegration](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/MidpointIntegration.js)
  * [ModularBinaryExponentiationRecursive](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/ModularBinaryExponentiationRecursive.js)
  * [NumberOfDigits](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/NumberOfDigits.js)
  * [Palindrome](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Palindrome.js)
  * [PascalTriangle](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PascalTriangle.js)
  * [PerfectCube](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PerfectCube.js)
  * [PerfectNumber](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PerfectNumber.js)
  * [PerfectSquare](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PerfectSquare.js)
  * [PermutationAndCombination](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PermutationAndCombination.js)
  * [PiApproximationMonteCarlo](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PiApproximationMonteCarlo.js)
  * [Polynomial](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Polynomial.js)
  * [Pow](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Pow.js)
  * [PowLogarithmic](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PowLogarithmic.js)
  * [PrimeCheck](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PrimeCheck.js)
  * [PrimeFactors](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/PrimeFactors.js)
  * [RadianToDegree](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/RadianToDegree.js)
  * [ReverseNumber](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/ReverseNumber.js)
  * [ReversePolishNotation](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/ReversePolishNotation.js)
  * [SieveOfEratosthenes](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/SieveOfEratosthenes.js)
  * [SimpsonIntegration](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/SimpsonIntegration.js)
  * [Softmax](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Softmax.js)
  * [SquareRoot](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/SquareRoot.js)
  * [SumOfDigits](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/SumOfDigits.js)
  * [SumOfGeometricProgression](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/SumOfGeometricProgression.js)
  * [Volume](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/Volume.js)
  * [WhileLoopFactorial](https://github.com/TheAlgorithms/Javascript/blob/master/Maths/WhileLoopFactorial.js)

## Navigation
  * [Haversine](https://github.com/TheAlgorithms/Javascript/blob/master/Navigation/Haversine.js)

## Project-Euler
  * [Problem001](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem001.js)
  * [Problem002](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem002.js)
  * [Problem003](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem003.js)
  * [Problem004](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem004.js)
  * [Problem005](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem005.js)
  * [Problem006](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem006.js)
  * [Problem008](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem008.js)
  * [Problem009](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem009.js)
  * [Problem010](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem010.js)
  * [Problem012](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem012.js)
  * [Problem014](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem014.js)
  * [Problem015](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem015.js)
  * [Problem016](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem016.js)
  * [Problem018](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem018.js)
  * [Problem020](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem020.js)
  * [Problem023](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem023.js)
  * [Problem025](https://github.com/TheAlgorithms/Javascript/blob/master/Project-Euler/Problem025.js)

## Recursive
  * [BinaryEquivalent](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/BinaryEquivalent.js)
  * [BinarySearch](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/BinarySearch.js)
  * [EucledianGCD](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/EucledianGCD.js)
  * [Factorial](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/Factorial.js)
  * [FibonacciNumberRecursive](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/FibonacciNumberRecursive.js)
  * [FloodFill](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/FloodFill.js)
  * [KochSnowflake](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/KochSnowflake.js)
  * [Palindrome](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/Palindrome.js)
  * [SubsequenceRecursive](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/SubsequenceRecursive.js)
  * [TowerOfHanoi](https://github.com/TheAlgorithms/Javascript/blob/master/Recursive/TowerOfHanoi.js)

## Search
  * [BinarySearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/BinarySearch.js)
  * [ExponentialSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/ExponentialSearch.js)
  * [FibonacciSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/FibonacciSearch.js)
  * [InterpolationSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/InterpolationSearch.js)
  * [JumpSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/JumpSearch.js)
  * [LinearSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/LinearSearch.js)
  * [QuickSelectSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/QuickSelectSearch.js)
  * [SlidingWindow](https://github.com/TheAlgorithms/Javascript/blob/master/Search/SlidingWindow.js)
  * [StringSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/StringSearch.js)
  * [TernarySearch](https://github.com/TheAlgorithms/Javascript/blob/master/Search/TernarySearch.js)
  * [UnionFind](https://github.com/TheAlgorithms/Javascript/blob/master/Search/UnionFind.js)

## Sorts
  * [AlphaNumericalSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/AlphaNumericalSort.js)
  * [BeadSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/BeadSort.js)
  * [BogoSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/BogoSort.js)
  * [BubbleSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/BubbleSort.js)
  * [BucketSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/BucketSort.js)
  * [CocktailShakerSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/CocktailShakerSort.js)
  * [CombSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/CombSort.js)
  * [CountingSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/CountingSort.js)
  * [CycleSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/CycleSort.js)
  * [FindSecondLargestElement](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/FindSecondLargestElement.js)
  * [FisherYatesShuffle](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/FisherYatesShuffle.js)
  * [FlashSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/FlashSort.js)
  * [GnomeSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/GnomeSort.js)
  * [HeapSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/HeapSort.js)
  * [HeapSortV2](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/HeapSortV2.js)
  * [InsertionSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/InsertionSort.js)
  * [IntroSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/IntroSort.js)
  * [MergeSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/MergeSort.js)
  * [OddEvenSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/OddEvenSort.js)
  * [PancakeSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/PancakeSort.js)
  * [PigeonHoleSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/PigeonHoleSort.js)
  * [QuickSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/QuickSort.js)
  * [QuickSortRecursive](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/QuickSortRecursive.js)
  * [RadixSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/RadixSort.js)
  * [SelectionSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/SelectionSort.js)
  * [ShellSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/ShellSort.js)
  * [TimSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/TimSort.js)
  * [TopologicalSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/TopologicalSort.js)
  * [WiggleSort](https://github.com/TheAlgorithms/Javascript/blob/master/Sorts/WiggleSort.js)

## String
  * [AlphaNumericPalindrome](https://github.com/TheAlgorithms/Javascript/blob/master/String/AlphaNumericPalindrome.js)
  * [AlternativeStringArrange](https://github.com/TheAlgorithms/Javascript/blob/master/String/AlternativeStringArrange.js)
  * [CheckAnagram](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckAnagram.js)
  * [CheckCamelCase](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckCamelCase.js)
  * [CheckFlatCase](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckFlatCase.js)
  * [CheckKebabCase](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckKebabCase.js)
  * [CheckPalindrome](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckPalindrome.js)
  * [CheckPangram](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckPangram.js)
  * [CheckPascalCase](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckPascalCase.js)
  * [CheckRearrangePalindrome](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckRearrangePalindrome.js)
  * [CheckSnakeCase](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckSnakeCase.js)
  * [CheckWordOccurrence](https://github.com/TheAlgorithms/Javascript/blob/master/String/CheckWordOccurrence.js)
  * [CountVowels](https://github.com/TheAlgorithms/Javascript/blob/master/String/CountVowels.js)
  * [CreatePermutations](https://github.com/TheAlgorithms/Javascript/blob/master/String/CreatePermutations.js)
  * [DiceCoefficient](https://github.com/TheAlgorithms/Javascript/blob/master/String/DiceCoefficient.js)
  * [FormatPhoneNumber](https://github.com/TheAlgorithms/Javascript/blob/master/String/FormatPhoneNumber.js)
  * [GenerateGUID](https://github.com/TheAlgorithms/Javascript/blob/master/String/GenerateGUID.js)
  * [HammingDistance](https://github.com/TheAlgorithms/Javascript/blob/master/String/HammingDistance.js)
  * [KMPPatternSearching](https://github.com/TheAlgorithms/Javascript/blob/master/String/KMPPatternSearching.js)
  * [LevenshteinDistance](https://github.com/TheAlgorithms/Javascript/blob/master/String/LevenshteinDistance.js)
  * [Lower](https://github.com/TheAlgorithms/Javascript/blob/master/String/Lower.js)
  * [MaxCharacter](https://github.com/TheAlgorithms/Javascript/blob/master/String/MaxCharacter.js)
  * [MaxWord](https://github.com/TheAlgorithms/Javascript/blob/master/String/MaxWord.js)
  * [PatternMatching](https://github.com/TheAlgorithms/Javascript/blob/master/String/PatternMatching.js)
  * [PermutateString](https://github.com/TheAlgorithms/Javascript/blob/master/String/PermutateString.js)
  * [ReverseString](https://github.com/TheAlgorithms/Javascript/blob/master/String/ReverseString.js)
  * [ReverseWords](https://github.com/TheAlgorithms/Javascript/blob/master/String/ReverseWords.js)
  * [ScrambleStrings](https://github.com/TheAlgorithms/Javascript/blob/master/String/ScrambleStrings.js)
  * [Upper](https://github.com/TheAlgorithms/Javascript/blob/master/String/Upper.js)
  * [ValidateCreditCard](https://github.com/TheAlgorithms/Javascript/blob/master/String/ValidateCreditCard.js)
  * [ValidateEmail](https://github.com/TheAlgorithms/Javascript/blob/master/String/ValidateEmail.js)
  * [ValidateUrl](https://github.com/TheAlgorithms/Javascript/blob/master/String/ValidateUrl.js)

## Timing-Functions
  * [GetMonthDays](https://github.com/TheAlgorithms/Javascript/blob/master/Timing-Functions/GetMonthDays.js)
  * [IntervalTimer](https://github.com/TheAlgorithms/Javascript/blob/master/Timing-Functions/IntervalTimer.js)

## Trees
  * [BreadthFirstTreeTraversal](https://github.com/TheAlgorithms/Javascript/blob/master/Trees/BreadthFirstTreeTraversal.js)
  * [DepthFirstSearch](https://github.com/TheAlgorithms/Javascript/blob/master/Trees/DepthFirstSearch.js)
  * [FenwickTree](https://github.com/TheAlgorithms/Javascript/blob/master/Trees/FenwickTree.js)

--#

--% C:/work/algos/Javascript/LICENSE
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

--#

--% C:/work/algos/Javascript/package.json
{
  "name": "javascript",
  "version": "1.0.0",
  "type": "module",
  "description": "A repository for All algorithms implemented in Javascript (for educational purposes only)",
  "main": "",
  "scripts": {
    "test": "jest --no-cache",
    "style": "standard"
  },
  "author": "TheAlgorithms",
  "license": "GPL-3.0",
  "dependencies": {
    "@babel/core": "^7.11.6",
    "@babel/plugin-transform-runtime": "^7.11.5",
    "@babel/preset-env": "^7.11.5",
    "atob": "2.1.2",
    "jsdom": "^16.3.0",
    "node": "^14.13.1",
    "node-fetch": "3.1.1"
  },
  "standard": {
    "env": [
      "jest"
    ]
  },
  "devDependencies": {
    "babel-jest": "^26.3.0",
    "globby": "^12.0.2",
    "jest": "^26.4.2",
    "standard": "^16.0.4"
  }
}

--#

--% C:/work/algos/Javascript/README.md
# The Algorithms - JavaScript

[![contributions welcome](https://img.shields.io/static/v1.svg?label=Contributions&message=Welcome&color=0059b3&style=flat-square)](CONTRIBUTING.md)
[![Language grade: JavaScript](https://img.shields.io/lgtm/grade/javascript/g/TheAlgorithms/Javascript.svg?logo=lgtm&logoWidth=18&style=flat-square)](https://lgtm.com/projects/g/TheAlgorithms/Javascript/context:javascript)
![Node CI](https://github.com/TheAlgorithms/Javascript/workflows/Node%20CI/badge.svg)
![update_directory_md](https://github.com/TheAlgorithms/Javascript/workflows/update_directory_md/badge.svg)
[![Discord chat](https://img.shields.io/discord/808045925556682782.svg?logo=discord&colorB=7289DA&style=flat-square)](https://discord.gg/c7MnfGFGa6)
![](https://img.shields.io/github/repo-size/TheAlgorithms/Javascript.svg?label=Repo%20size&style=flat-square)
[![standard.js](https://img.shields.io/badge/code%20style-standardjs-%23f3df49)](https://standardjs.com/)

## All algorithms implemented in JavaScript (for educational purposes only)

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/TheAlgorithms/Javascript)

These are for demonstration purposes only. There are many implementations of sorts in the JavaScript standard library 
that are much better for performance reasons.

## Contribution Guidelines

Read our [Contribution Guidelines](CONTRIBUTING.md) before you contribute.

## List of Algorithms

See our [directory](DIRECTORY.md).

## Algorithm Explanation

See our [wiki](https://github.com/TheAlgorithms/Javascript/wiki).

--#

--% C:/work/algos/Javascript/.github/CODEOWNERS
* @raklaptudirm

--#

--% C:/work/algos/Javascript/.github/pull_request_template.md
# Welcome to JavaScript community

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/from-referrer/)&nbsp;[know more](https://www.gitpod.io/docs/pull-requests/)



### Describe your change:

* [ ] Add an algorithm?
* [ ] Fix a bug or typo in an existing algorithm?
* [ ] Documentation change?


### Checklist:
* [ ] I have read [CONTRIBUTING.md](https://github.com/TheAlgorithms/Javascript/blob/master/CONTRIBUTING.md).
* [ ] This pull request is all my own work -- I have not plagiarized.
* [ ] I know that pull requests will not be merged if they fail the automated tests.
* [ ] This PR only changes one algorithm file.  To ease review, please open separate PRs for separate algorithms.
* [ ] All new JavaScript files are placed inside an existing directory.
* [ ] All filenames should use the UpperCamelCase (PascalCase) style.  There should be no spaces in filenames.
     **Example:**`UserProfile.js` is allowed but `userprofile.js`,`Userprofile.js`,`user-Profile.js`,`userProfile.js` are not
* [ ] All new algorithms have a URL in its comments that points to Wikipedia or other similar explanation.
* [ ] If this pull request resolves one or more open issues then the commit message contains `Fixes: #{$ISSUE_NO}`.

--#

--% C:/work/algos/Javascript/.github/stale.yml
# Number of days of inactivity before an issue becomes stale (a week)
daysUntilStale: 7
# Number of days of inactivity before a stale issue is closed (a week)
daysUntilClose: 7
# Issues with these labels will never be considered stale
exemptLabels:
  - bug
  - help wanted
  - OK to merge
# Label to use when marking an issue as stale
staleLabel: wontfix
# Comment to post when marking an issue as stale. Set to `false` to disable
markComment: >
  This issue has been automatically marked as stale because it has not had
  recent activity. It will be closed if no further activity occurs. Thank you
  for your contributions.
# Comment to post when closing a stale issue. Set to `false` to disable
closeComment: >
  Please reopen this issue once you commit the changes requested or 
  make improvements on the code. Thank you for your contributions.

--#

--% C:/work/algos/Javascript/.github/workflows/Ci.yml
name: Continuous Integration

on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "14"
          cache: npm

      - name:  Install dependencies
        run: npm ci

      - name:  Run tests
        run: npm test

      - name:  Code style
        run: npm run style

--#

--% C:/work/algos/Javascript/.github/workflows/Codespell.yml
name: codespell
on: [push, pull_request]
jobs:
  codespell:
    name: Check for spelling errors
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: codespell-project/actions-codespell@master
        with:
          # file types to ignore
          skip: "*.json,*.yml,DIRECTORY.md"
          ignore_words_list: "ba,esy,yse"

--#

--% C:/work/algos/Javascript/.github/workflows/CommitAndPushDirectory.sh
if ! git diff --quiet DIRECTORY.md; then
    echo Changes found, attempting to commit and push...
    git add DIRECTORY.md
    git commit -am "Auto-update DIRECTORY.md" ||  true
    git push --force origin HEAD:$GITHUB_REF || true
    echo ... done.
else
    echo No changes found, exiting.
fi


--#

--% C:/work/algos/Javascript/.github/workflows/UpdateDirectory.mjs
import path from 'path'
import fs from 'fs'
import { globby } from 'globby'

const URL_BASE = 'https://github.com/TheAlgorithms/Javascript/blob/master'

function pathPrefix (i) {
  if (i) {
    const res = '  '.repeat(i)
    return res + '*'
  } else {
    return '\n##'
  }
}

function printPath (oldPath, newPath, output) {
  const oldParts = oldPath.split(path.sep)
  const newParts = newPath.split(path.sep)
  for (let i = 0; i < newParts.length; ++i) {
    const newPart = newParts[i]
    if (i + 1 > oldParts.length || oldParts[i] !== newPart) {
      if (newPart) {
        output.push(`${pathPrefix(i)} ${newPart.replace('_', ' ')}`)
      }
    }
  }
  return newPath
}

function pathsToMarkdown (filePaths) {
  const output = []

  let oldPath = ''
  filePaths.sort(function (a, b) {
    if (a.toLowerCase() < b.toLowerCase()) return -1
    if (a.toLowerCase() > b.toLowerCase()) return 1
    return 0
  })
  for (let filepath of filePaths) {
    const file = filepath.split(path.sep)
    let filename = ''
    if (file.length === 1) {
      filepath = ''
      filename = file[0]
    } else {
      const total = file.length
      filename = file[total - 1]
      filepath = file.splice(0, total - 1).join(path.sep)
    }
    if (filepath !== oldPath) {
      oldPath = printPath(oldPath, filepath, output)
    }
    let indent = 0
    for (let i = 0; i < filepath.length; ++i) {
      if (filepath[i] === path.sep) {
        ++indent
      }
    }
    if (filepath) {
      ++indent
    }

    // prepare the markdown-esque prefix to the file's line
    const prefix = pathPrefix(indent)

    // remove extension from filename
    const name = filename.split('.')[0]

    // create URL to the actual file on github
    const url = encodeURI([URL_BASE, filepath, filename].join('/'))

    output.push(`${prefix} [${name}](${url})`)
  }

  return output.join('\n')
}

// get paths of all .js files - excluding node_modules, the .github folder, tests and config stuff
globby([
  '**/*.js',
  '!(node_modules|.github)/**/*',
  '!**/*.test.js',
  '!**/*.manual-test.js',
  '!babel.config.js'
])
  // create markdown content
  .then(pathsToMarkdown)
  // write markdown to file
  .then(markdown => fs.writeFileSync('DIRECTORY.md', markdown + '\n', { encoding: 'utf8' }))

--#

--% C:/work/algos/Javascript/.github/workflows/UpdateDirectory.yml
# This GitHub Action updates the DIRECTORY.md file (if needed) when doing a git push
name: Update Directory

on: [push]

jobs:
  updateDirectory:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: "14"
          cache: npm

      - name:  Install dependencies
        run: npm ci

      - name:  Create Directory from JS files
        run: node .github/workflows/UpdateDirectory.mjs

      - name:  Commit & push new Directory (if needed)
        run: |
          git config --global user.name github-actions
          git config --global user.email '${GITHUB_ACTOR}@users.noreply.github.com'
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/$GITHUB_REPOSITORY
          .github/workflows/CommitAndPushDirectory.sh

--#

--% C:/work/algos/Javascript/Backtracking/AllCombinationsOfSizeK.js
/*
  Problem: Given two numbers, n and k, make all unique combinations of k numbers from 1 to n and in sorted order

  What is combinations?
  - Combinations is selecting items from a collections without considering order of selection

  Example:
  - We have an apple, a banana, and a jackfruit
  - We have three objects, and need to choose two items, then combinations will be

  1. Apple & Banana
  2. Apple & Jackfruit
  3. Banana & Jackfruit

  To read more about combinations, you can visit the following link:
  - https://betterexplained.com/articles/easy-permutations-and-combinations/

  Solution:
  - We will be using backtracking to solve this questions
  - Take one element, and make all them combinations for k-1 elements
  - Once we get all combinations of that element, pop it and do same for next element
*/

class Combinations {
  constructor (n, k) {
    this.n = n
    this.k = k
    this.current = [] // will be used for storing current combination
    this.combinations = []
  }

  findCombinations (high = this.n, total = this.k, low = 1) {
    if (total === 0) {
      this.combinations.push([...this.current])
      return this.combinations
    }
    for (let i = low; i <= high; i++) {
      this.current.push(i)
      this.findCombinations(high, total - 1, i + 1)
      this.current.pop()
    }
    return this.combinations
  }
}

export { Combinations }

--#

--% C:/work/algos/Javascript/Backtracking/GeneratePermutations.js
/*
 * Problem Statement: Generate all distinct permutations of a an array (all permutations should be in sorted order);
 *
 * What is permutations?
 * - Permutation means possible arrangements in a set (here it is an array);
 *
 * Reference to know more about permutations:
 * - https://www.britannica.com/science/permutation
 *
 */

const swap = (arr, i, j) => {
  const newArray = [...arr];

  [newArray[i], newArray[j]] = [newArray[j], newArray[i]] // Swapping elements ES6 way

  return newArray
}

const permutations = arr => {
  const P = []
  const permute = (arr, low, high) => {
    if (low === high) {
      P.push([...arr])
      return P
    }
    for (let i = low; i <= high; i++) {
      arr = swap(arr, low, i)
      permute(arr, low + 1, high)
    }
    return P
  }
  return permute(arr, 0, arr.length - 1)
}

export { permutations }

--#

--% C:/work/algos/Javascript/Backtracking/KnightTour.js
// Wikipedia: https://en.wikipedia.org/wiki/Knight%27s_tour

class OpenKnightTour {
  constructor (size) {
    this.board = new Array(size).fill(0).map(() => new Array(size).fill(0))
    this.size = size
  }

  getMoves ([i, j]) {
    // helper function to get the valid moves of the knight from the current position
    const moves = [
      [i + 2, j - 1],
      [i + 2, j + 1],
      [i - 2, j - 1],
      [i - 2, j + 1],
      [i + 1, j - 2],
      [i + 1, j + 2],
      [i - 1, j - 2],
      [i - 1, j + 2]
    ]

    return moves.filter(([y, x]) => y >= 0 && y < this.size && x >= 0 && x < this.size)
  }

  isComplete () {
    // helper function to check if the board is complete
    return !this.board.map(row => row.includes(0)).includes(true)
  }

  solve () {
    // function to find the solution for the given board
    for (let i = 0; i < this.size; i++) {
      for (let j = 0; j < this.size; j++) {
        if (this.solveHelper([i, j], 0)) return true
      }
    }
    return false
  }

  solveHelper ([i, j], curr) {
    // helper function for the main computation
    if (this.isComplete()) return true

    for (const [y, x] of this.getMoves([i, j])) {
      if (this.board[y][x] === 0) {
        this.board[y][x] = curr + 1
        if (this.solveHelper([y, x], curr + 1)) return true
        // backtracking
        this.board[y][x] = 0
      }
    }
    return false
  }

  printBoard (output = value => console.log(value)) {
    // utility function to display the board
    for (const row of this.board) {
      let string = ''
      for (const elem of row) {
        string += elem + '\t'
      }
      output(string)
    }
  }
}

export { OpenKnightTour }

--#

--% C:/work/algos/Javascript/Backtracking/NQueen.js
class NQueen {
  constructor (size) {
    this.board = new Array(size).fill('.').map(() => new Array(size).fill('.'))
    this.size = size
    this.solutionCount = 0
  }

  isValid ([row, col]) {
    // function to check if the placement of the queen in the given location is valid

    // checking the left of the current row
    for (let i = 0; i < col; i++) {
      if (this.board[row][i] === 'Q') return false
    }

    // checking the upper left diagonal
    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {
      if (this.board[i][j] === 'Q') return false
    }

    // checking the lower left diagonal
    for (let i = row, j = col; j >= 0 && i < this.size; i++, j--) {
      if (this.board[i][j] === 'Q') return false
    }

    return true
  }

  placeQueen (row, col) {
    this.board[row][col] = 'Q'
  }

  removeQueen (row, col) {
    this.board[row][col] = '.'
  }

  solve (col = 0) {
    if (col >= this.size) {
      this.solutionCount++
      return true
    }

    for (let i = 0; i < this.size; i++) {
      if (this.isValid([i, col])) {
        this.placeQueen(i, col)
        this.solve(col + 1)
        this.removeQueen(i, col)
      }
    }

    return false
  }

  printBoard (output = value => console.log(value)) {
    if (!output._isMockFunction) {
      output('\n')
    }
    for (const row of this.board) {
      output(row)
    }
  }
}

export { NQueen }

--#

--% C:/work/algos/Javascript/Backtracking/RatInAMaze.js
/*
 * Problem Statement:
 * - Given a NxN grid, find whether rat in cell [0, 0] can reach the target in cell [N-1, N-1]
 * - The grid is represented as an array of rows. Each row is represented as an array of 0 or 1 values.
 * - A cell with value 0 can not be moved through. Value 1 means the rat can move here.
 * - The rat can not move diagonally.
 *
 * Reference for this problem: https://www.geeksforgeeks.org/rat-in-a-maze-backtracking-2/
 *
 * Based on the original implementation contributed by Chiranjeev Thapliyal (https://github.com/chiranjeev-thapliyal).
 */

/**
 * Checks if the given grid is valid.
 *
 * A grid needs to satisfy these conditions:
 * - must not be empty
 * - must be a square
 * - must not contain values other than {@code 0} and {@code 1}
 *
 * @param grid The grid to check.
 * @throws TypeError When the given grid is invalid.
 */
function validateGrid (grid) {
  if (!Array.isArray(grid) || grid.length === 0) throw new TypeError('Grid must be a non-empty array')

  const allRowsHaveCorrectLength = grid.every(row => row.length === grid.length)
  if (!allRowsHaveCorrectLength) throw new TypeError('Grid must be a square')

  const allCellsHaveValidValues = grid.every(row => {
    return row.every(cell => cell === 0 || cell === 1)
  })
  if (!allCellsHaveValidValues) throw new TypeError('Grid must only contain 0s and 1s')
}

function isSafe (grid, x, y) {
  const n = grid.length
  return x >= 0 && x < n && y >= 0 && y < n && grid[y][x] === 1
}

/**
 * Attempts to calculate the remaining path to the target.
 *
 * @param grid The full grid.
 * @param x The current X coordinate.
 * @param y The current Y coordinate.
 * @param solution The current solution matrix.
 * @param path The path we took to get from the source cell to the current location.
 * @returns {string|boolean} Either the path to the target cell or false.
 */
function getPathPart (grid, x, y, solution, path) {
  const n = grid.length

  // are we there yet?
  if (x === n - 1 && y === n - 1 && grid[y][x] === 1) {
    solution[y][x] = 1
    return path
  }

  // did we step on a 0 cell or outside the grid?
  if (!isSafe(grid, x, y)) return false

  // are we walking onto an already-marked solution coordinate?
  if (solution[y][x] === 1) return false

  // none of the above? let's dig deeper!

  // mark the current coordinates on the solution matrix
  solution[y][x] = 1

  // attempt to move right
  const right = getPathPart(grid, x + 1, y, solution, path + 'R')
  if (right) return right

  // right didn't work: attempt to move down
  const down = getPathPart(grid, x, y + 1, solution, path + 'D')
  if (down) return down

  // down didn't work: attempt to move up
  const up = getPathPart(grid, x, y - 1, solution, path + 'U')
  if (up) return up

  // up didn't work: attempt to move left
  const left = getPathPart(grid, x - 1, y, solution, path + 'L')
  if (left) return left

  // no direction was successful: remove this cell from the solution matrix and backtrack
  solution[y][x] = 0
  return false
}

function getPath (grid) {
  // grid dimensions
  const n = grid.length

  // prepare solution matrix
  const solution = []
  for (let i = 0; i < n; i++) {
    const row = Array(n)
    row.fill(0)
    solution[i] = row
  }

  return getPathPart(grid, 0, 0, solution, '')
}

/**
 * Creates an instance of the "rat in a maze" based on a given grid (maze).
 */
export class RatInAMaze {
  constructor (grid) {
    // first, let's do some error checking on the input
    validateGrid(grid)

    // attempt to solve the maze now - all public methods only query the result state later
    const solution = getPath(grid)

    if (solution !== false) {
      this.path = solution
      this.solved = true
    } else {
      this.path = ''
      this.solved = false
    }
  }
}

--#

--% C:/work/algos/Javascript/Backtracking/Sudoku.js
class Sudoku {
  // Sudoku Class to hold the board and related functions
  constructor (board) {
    this.board = board
  }

  findEmptyCell () {
    // Find a empty cell in the board (returns [-1, -1] if all cells are filled)
    for (let i = 0; i < 9; i++) {
      for (let j = 0; j < 9; j++) {
        if (this.board[i][j] === 0) return [i, j]
      }
    }
    return [-1, -1]
  }

  check ([y, x], value) {
    // checks if the value to be added in the board is an acceptable value for the cell

    // checking through the row
    for (let i = 0; i < 9; i++) {
      if (this.board[i][x] === value) return false
    }
    // checking through the column
    for (let i = 0; i < 9; i++) {
      if (this.board[y][i] === value) return false
    }

    // checking through the 3x3 block of the cell
    const secRow = Math.floor(y / 3)
    const secCol = Math.floor(x / 3)
    for (let i = (secRow * 3); i < ((secRow * 3) + 3); i++) {
      for (let j = (secCol * 3); j < ((secCol * 3) + 3); j++) {
        if (y !== i && x !== j && this.board[i][j] === value) return false
      }
    }

    return true
  }

  solve () {
    const [y, x] = this.findEmptyCell()

    // checking if the board is complete
    if (y === -1 && x === -1) return true

    for (let val = 1; val < 10; val++) {
      if (this.check([y, x], val)) {
        this.board[y][x] = val
        if (this.solve()) return true
        // backtracking if the board cannot be solved using current configuration
        this.board[y][x] = 0
      }
    }
    // returning false the board cannot be solved using current configuration
    return false
  }

  getSection (row, [start, end]) {
    return this.board[row].slice(start, end)
  }

  printBoard (output = (...v) => console.log(...v)) {
    // helper function to display board
    for (let i = 0; i < 9; i++) {
      if (i % 3 === 0 && i !== 0) {
        output('- - - - - - - - - - - -')
      }
      output(
        ...this.getSection(i, [0, 3]), ' | ',
        ...this.getSection(i, [3, 6]), ' | ',
        ...this.getSection(i, [6, 9]))
    }
  }
}

export { Sudoku }

--#

--% C:/work/algos/Javascript/Backtracking/SumOfSubset.js
/*
 *
 *  Sum of Subset problem
 *
 *  Given an ordered set W of non-negative integers and a value K,
 *  determine all possible subsets from the given set W whose sum
 *  of its elements equals to the given value K.
 *
 *  More info: https://www.geeksforgeeks.org/subset-sum-backtracking-4/
 */

/*
 * @param {number[]} set Original set of numbers
 * @param {number[]} subset Subset being evaluated
 * @param {number} setIndex Index from set of last element in subset
 * @param {number} Sum of elements from subset
 * @param {targetSum} The target sum on which the subset sum is compared to
 * @returns {number[][]} Subsets whose elements add up to targetSum
 */
const sumOfSubset = (set, subset, setindex, sum, targetSum) => {
  // Base case where the subset sum is equal to target sum
  // Evaluation of following subsets on this path will always add up to
  // greater than targetSum, so no need to continue
  if (sum === targetSum) return [subset]

  // This and following subsets on this path will always add up to
  // greater than targetSum, so no need to continue
  if (sum > targetSum) return []

  // Initialize results array. Will contain only valid subsets
  let results = []

  // Slice gets from the set all the elements at the right of the last element
  // to be evaluated (last element of subset)
  // forEach iterated on the resulting array
  set.slice(setindex).forEach((num, index) => {
    // The next subset to be evaluated, current subset plus next element
    const nextSubset = [...subset, num]

    // Next index from the set. Current set index plus iteration index
    // index starts at 0, so a + 1 is required
    const nextSetIndex = setindex + index + 1

    // Sum of elements from the next subset to be evaluated
    const nextSum = sum + num

    // Call recursively the sumOfSubset for the nextSubset
    const subsetResult = sumOfSubset(
      set,
      nextSubset,
      nextSetIndex,
      nextSum,
      targetSum
    )

    // Concat the recursive result with current result array
    results = [...results, ...subsetResult]
  })

  // Return results
  return results
}

export { sumOfSubset }

--#

--% C:/work/algos/Javascript/Backtracking/tests/AllCombinationsOfSizeK.test.js
import { Combinations } from '../AllCombinationsOfSizeK'

describe('AllCombinationsOfSizeK', () => {
  it('should return 3x2 matrix solution for n = 3 and k = 2', () => {
    const test1 = new Combinations(3, 2)
    expect(test1.findCombinations()).toEqual([[1, 2], [1, 3], [2, 3]])
  })

  it('should return 6x2 matrix solution for n = 4 and k = 2', () => {
    const test2 = new Combinations(4, 2)
    expect(test2.findCombinations()).toEqual([[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]])
  })
})

--#

--% C:/work/algos/Javascript/Backtracking/tests/GeneratePermutations.test.js
import { permutations } from '../GeneratePermutations'

describe('Permutations', () => {
  it('Permutations of [1, 2, 3]', () => {
    expect(permutations([1, 2, 3])).toEqual([
      [1, 2, 3],
      [1, 3, 2],
      [2, 1, 3],
      [2, 3, 1],
      [3, 1, 2],
      [3, 2, 1]
    ])
  })
})

--#

--% C:/work/algos/Javascript/Backtracking/tests/KnightTour.test.js
import { OpenKnightTour } from '../KnightTour'

describe('OpenKnightTour', () => {
  it('OpenKnightTour(5)', () => {
    const KT = new OpenKnightTour(5)
    expect(KT.board).toEqual([
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0]
    ])

    KT.solve()
    expect(KT.board).toEqual([
      [19, 4, 15, 10, 25],
      [14, 9, 18, 5, 16],
      [1, 20, 3, 24, 11],
      [8, 13, 22, 17, 6],
      [21, 2, 7, 12, 23]
    ])
  })
})

--#

--% C:/work/algos/Javascript/Backtracking/tests/NQueen.test.js
import { NQueen } from '../NQueen'

describe('NQueen', () => {
  it('should return 2 solutions for 4x4 size board', () => {
    const _4Queen = new NQueen(4)
    _4Queen.solve()
    expect(_4Queen.solutionCount).toEqual(2)
  })

  it('should return 92 solutions for 8x8 size board', () => {
    const _8Queen = new NQueen(8)
    _8Queen.solve()
    expect(_8Queen.solutionCount).toEqual(92)
  })
})

--#

--% C:/work/algos/Javascript/Backtracking/tests/RatInAMaze.test.js
import { RatInAMaze } from '../RatInAMaze'

describe('RatInAMaze', () => {
  it('should fail for non-arrays', () => {
    const values = [undefined, null, {}, 42, 'hello, world']

    for (const value of values) {
      // we deliberately want to check whether this constructor call fails or not
      // eslint-disable-next-line no-new
      expect(() => { new RatInAMaze(value) }).toThrow()
    }
  })

  it('should fail for an empty array', () => {
    // we deliberately want to check whether this constructor call fails or not
    // eslint-disable-next-line no-new
    expect(() => { new RatInAMaze([]) }).toThrow()
  })

  it('should fail for a non-square array', () => {
    const array = [
      [0, 0, 0],
      [0, 0]
    ]

    // we deliberately want to check whether this constructor call fails or not
    // eslint-disable-next-line no-new
    expect(() => { new RatInAMaze(array) }).toThrow()
  })

  it('should fail for arrays containing invalid values', () => {
    const values = [[[2]], [['a']]]

    for (const value of values) {
      // we deliberately want to check whether this constructor call fails or not
      // eslint-disable-next-line no-new
      expect(() => { new RatInAMaze(value) }).toThrow()
    }
  })

  it('should work for a single-cell maze', () => {
    const maze = new RatInAMaze([[1]])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('')
  })

  it('should work for a single-cell maze that can not be solved', () => {
    const maze = new RatInAMaze([[0]])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })

  it('should work for a simple 3x3 maze', () => {
    const maze = new RatInAMaze([[1, 1, 0], [0, 1, 0], [0, 1, 1]])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('RDDR')
  })

  it('should work for a simple 2x2 that can not be solved', () => {
    const maze = new RatInAMaze([[1, 0], [0, 1]])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })

  it('should work for a more complex maze', () => {
    const maze = new RatInAMaze([
      [1, 1, 1, 1, 1, 0, 0],
      [0, 0, 0, 0, 1, 0, 0],
      [1, 1, 1, 0, 1, 0, 0],
      [1, 0, 1, 0, 1, 0, 0],
      [1, 0, 1, 1, 1, 0, 0],
      [1, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1]
    ])
    expect(maze.solved).toBe(true)
    expect(maze.path).toBe('RRRRDDDDLLUULLDDDDRRRRRR')
  })

  it('should work for a more complex maze that can not be solved', () => {
    const maze = new RatInAMaze([
      [1, 1, 1, 1, 1, 0, 1],
      [0, 0, 0, 0, 1, 0, 1],
      [1, 1, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 1, 0, 1],
      [1, 0, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1]
    ])
    expect(maze.solved).toBe(false)
    expect(maze.path).toBe('')
  })
})

--#

--% C:/work/algos/Javascript/Backtracking/tests/Sudoku.test.js
import { Sudoku } from '../Sudoku'

const data = [
  [3, 0, 6, 5, 0, 8, 4, 0, 0],
  [5, 2, 0, 0, 0, 0, 0, 0, 0],
  [0, 8, 7, 0, 0, 0, 0, 3, 1],
  [0, 0, 3, 0, 1, 0, 0, 8, 0],
  [9, 0, 0, 8, 6, 3, 0, 0, 5],
  [0, 5, 0, 0, 9, 0, 6, 0, 0],
  [1, 3, 0, 0, 0, 0, 2, 5, 0],
  [0, 0, 0, 0, 0, 0, 0, 7, 4],
  [0, 0, 5, 2, 0, 6, 3, 0, 0]
]

const solved = [
  [3, 1, 6, 5, 7, 8, 4, 9, 2],
  [5, 2, 9, 1, 3, 4, 7, 6, 8],
  [4, 8, 7, 6, 2, 9, 5, 3, 1],
  [2, 6, 3, 4, 1, 5, 9, 8, 7],
  [9, 7, 4, 8, 6, 3, 1, 2, 5],
  [8, 5, 1, 7, 9, 2, 6, 4, 3],
  [1, 3, 8, 9, 4, 7, 2, 5, 6],
  [6, 9, 2, 3, 5, 1, 8, 7, 4],
  [7, 4, 5, 2, 8, 6, 3, 1, 9]
]

describe('Sudoku', () => {
  it('should create a valid board successfully', () => {
    // we deliberately want to check whether this constructor call fails or not
    // eslint-disable-next-line no-new
    expect(() => { new Sudoku(data) }).not.toThrow()
  })

  it('should find an empty cell', () => {
    const board = new Sudoku(data)
    const emptyCell = board.findEmptyCell()
    expect(emptyCell).not.toEqual([-1, -1])
  })

  it('should solve the board successfully', () => {
    const board = new Sudoku(data)
    board.solve()

    // should not have empty cells anymore
    const emptyCell = board.findEmptyCell()
    expect(emptyCell).toEqual([-1, -1])

    // solved board should match our expectation
    for (let i = 0; i < 9; i++) {
      const section = board.getSection(i, [0, 9])
      expect(section).toEqual(solved[i])
    }
  })
})

--#

--% C:/work/algos/Javascript/Backtracking/tests/SumOfSubset.test.js
import { sumOfSubset } from '../SumOfSubset'

describe('SumOfSubset', () => {
  it('should return the subsets that add up to the given number', () => {
    // W = [2, 5, 7, 8, 12, 16, 23, 40]
    // K = 25

    const nums = [2, 5, 7, 8, 12, 16, 23, 40]

    const subsets = sumOfSubset(nums, [], 0, 0, 25)

    expect(subsets).toEqual([
      [2, 7, 16],
      [2, 23],
      [5, 8, 12]
    ])
  })
})

--#

--% C:/work/algos/Javascript/Bit-Manipulation/BinaryCountSetBits.js
/*
    author: vivek9patel
    license: GPL-3.0 or later

    This script will find number of 1's
    in binary representation of given number

*/

function BinaryCountSetBits (a) {
  'use strict'
  // convert number into binary representation and return number of set bits in binary representation
  return a.toString(2).split('1').length - 1
}

export { BinaryCountSetBits }

--#

--% C:/work/algos/Javascript/Bit-Manipulation/IsPowerOfTwo.js
/*
    author: @Aayushi-Mittal

    This script will check whether the given
    number is a power of two or not.

    A number will be a power of two if only one bit is set and rest are unset.
    This is true for all the cases except 01 because (2^0 = 1) which is not a power of 2.
    For eg: 10 (2^1 = 2), 100 (2^2 = 4), 10000 (2^4 = 16)

    Reference Link: https://www.hackerearth.com/practice/notes/round-a-number-to-the-next-power-of-2/

    If we will subtract 1 from a number that is a power of 2 we will get it's 1's complement.
    And we know that 1's complement is just opp. of that number.
    So, (n & (n-1)) will be 0.

    For eg:    (1000 & (1000-1))
                1 0 0 0     // Original Number (8)
                0 1 1 1     // After Subtracting 1 (8-1 = 7)
                _______
                0 0 0 0     // will become 0

*/

export const IsPowerOfTwo = (n) => {
  if (n > 0 && (n & (n - 1)) === 0) {
    return true
  }
  return false
}

--#

--% C:/work/algos/Javascript/Bit-Manipulation/NextPowerOfTwo.js
/**
 *
 *  This script will find next power of two
 *    of given number.
 *  More about it:
 *   https://www.techiedelight.com/round-next-highest-power-2/
 *
 */

export const nextPowerOfTwo = (n) => {
  if (n > 0 && (n & (n - 1)) === 0) return n
  let result = 1
  while (n > 0) {
    result = result << 1
    n = n >> 1
  }
  return result
}

--#

--% C:/work/algos/Javascript/Bit-Manipulation/SetBit.js
/*
 * Setting Bit: https://www.geeksforgeeks.org/set-k-th-bit-given-number/
 *
 * To set any bit we use bitwise OR (|) operator.
 *
 * Bitwise OR (|) compares the bits of the 32
 * bit binary representations of the number and
 * returns a number after comparing each bit.
 *
 * 0 | 0 -> 0
 * 0 | 1 -> 1
 * 1 | 0 -> 1
 * 1 | 1 -> 1
 *
 * In-order to set kth bit of a number (where k is the position where bit is to be changed)
 * we need to shift 1 k times to its left and then perform bitwise OR operation with the
 * number and result of left shift performed just before.
 *
 * References:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR
 */

/**
 * @param {number} number
 * @param {number} bitPosition - zero based.
 * @return {number}
 */

export const setBit = (number, bitPosition) => {
  return number | (1 << bitPosition)
}

--#

--% C:/work/algos/Javascript/Bit-Manipulation/test/IsPowerOfTwo.test.js
import { IsPowerOfTwo } from '../IsPowerOfTwo'

test('Check if 0 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(0)
  expect(res).toBe(false)
})

test('Check if 1 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1)
  expect(res).toBe(true)
})

test('Check if 4 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(4)
  expect(res).toBe(true)
})

test('Check if 1024 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1024)
  expect(res).toBe(true)
})

test('Check if 1025 is a power of 2 or not:', () => {
  const res = IsPowerOfTwo(1025)
  expect(res).toBe(false)
})

--#

--% C:/work/algos/Javascript/Bit-Manipulation/test/NextPowerOfTwo.test.js
import { nextPowerOfTwo } from '../NextPowerOfTwo'

describe('NextPowerOfTwo', () => {
  it.each`
    input    | result
    ${0}     | ${1}
    ${1}     | ${1}
    ${2}     | ${2}
    ${3}     | ${4}
    ${5}     | ${8}
    ${125}   | ${128}
    ${1024}  | ${1024}
    ${10000} | ${16384}
  `('returns $result when is given $input', ({ input, result }) => {
    const res = nextPowerOfTwo(input)
    expect(res).toBe(result)
  })
})

--#

--% C:/work/algos/Javascript/Bit-Manipulation/test/SetBit.test.js
import { setBit } from '../SetBit'

test('Set bit number 0 in 1:', () => {
  const setBitPos = setBit(1, 0)
  expect(setBitPos).toBe(1)
})

test('Set bit number 0 in 2:', () => {
  const setBitPos = setBit(2, 0)
  expect(setBitPos).toBe(3)
})

test('Set bit number 1 in 10:', () => {
  const setBitPos = setBit(10, 1)
  expect(setBitPos).toBe(10)
})

test('Set bit number 2 in 10:', () => {
  const setBitPos = setBit(10, 2)
  expect(setBitPos).toBe(14)
})

--#

--% C:/work/algos/Javascript/Cache/LFUCache.js
class DoubleLinkedListNode {
  // Double Linked List Node built specifically for LFU Cache
  constructor (key, val) {
    this.key = key
    this.val = val
    this.freq = 0
    this.next = null
    this.prev = null
  }
}

class DoubleLinkedList {
  // Double Linked List built specifically for LFU Cache
  constructor () {
    this.head = new DoubleLinkedListNode(null, null)
    this.rear = new DoubleLinkedListNode(null, null)
    this.head.next = this.rear
    this.rear.prev = this.head
  }

  _positionNode (node) {
    // Helper function to position a node based on the frequency of the key
    while (node.prev.key && node.prev.freq > node.freq) {
      const node1 = node
      const node2 = node.prev
      node1.prev = node2.prev
      node2.next = node1.prev
      node1.next = node2
      node2.prev = node1
    }
  }

  add (node) {
    // Adds the given node to the end of the list (before rear) and positions it based on frequency
    const temp = this.rear.prev
    temp.next = node
    node.prev = temp
    this.rear.prev = node
    node.next = this.rear
    this._positionNode(node)
  }

  remove (node) {
    // Removes and returns the given node from the list
    const tempLast = node.prev
    const tempNext = node.next
    node.prev = null
    node.next = null
    tempLast.next = tempNext
    tempNext.prev = tempLast

    return node
  }
}

class LFUCache {
  // LFU Cache to store a given capacity of data
  // The Double Linked List is used to store the order of deletion from the cache
  // The rear.prev holds the most frequently used key and the head.next holds the least used key
  // When the number of elements reaches the capacity, the least frequently used item is removed before adding the next key
  constructor (capacity) {
    this.list = new DoubleLinkedList()
    this.capacity = capacity
    this.numKeys = 0
    this.hits = 0
    this.miss = 0
    this.cache = {}
  }

  cacheInfo () {
    // Return the details for the cache instance [hits, misses, capacity, current_size]
    return `CacheInfo(hits=${this.hits}, misses=${this.miss}, capacity=${this.capacity}, current size=${this.numKeys})`
  }

  set (key, value) {
    // Sets the value for the input key and updates the Double Linked List
    if (!(key in this.cache)) {
      if (this.numKeys >= this.capacity) {
        const keyToDelete = this.list.head.next.key
        this.list.remove(this.cache[keyToDelete])
        delete this.cache[keyToDelete]
        this.numKeys -= 1
      }
      this.cache[key] = new DoubleLinkedListNode(key, value)
      this.list.add(this.cache[key])
      this.numKeys += 1
    } else {
      const node = this.list.remove(this.cache[key])
      node.val = value
      this.list.add(node)
    }
  }

  get (key) {
    // Returns the value for the input key and updates the Double Linked List. Returns null if key is not present in cache
    if (key in this.cache) {
      this.hits += 1
      this.list.add(this.list.remove(this.cache[key]))
      return this.cache[key].val
    }
    this.miss += 1
    return null
  }
}

export { LFUCache }

--#

--% C:/work/algos/Javascript/Cache/LRUCache.js
class LRUCache {
  // LRU Cache to store a given capacity of data
  constructor (capacity) {
    this.cache = new Map()
    this.capacity = capacity
    this.hits = 0
    this.miss = 0
  }

  cacheInfo () {
    // Return the details for the cache instance [hits, misses, capacity, current_size]
    return `CacheInfo(hits=${this.hits}, misses=${this.miss}, capacity=${this.capacity}, current size=${this.cache.size})`
  }

  set (key, value) {
    // Sets the value for the input key and if the key exists it updates the existing key
    if (this.cache.size === this.capacity) {
      // delete oldest key existing in map
      this.cache.delete(this.cache.keys().next().value)
    }
    this.cache.set(key, value)
  }

  get (key) {
    // Returns the value for the input key. Returns null if key is not present in cache
    if (this.cache.has(key)) {
      const value = this.cache.get(key)
      // refresh the cache to update the order of key
      this.cache.delete(key)
      this.cache.set(key, value)
      this.hits += 1
      return value
    } else {
      this.miss += 1
      return null
    }
  }
}

export { LRUCache }

--#

--% C:/work/algos/Javascript/Cache/Memoize.js
/**
 * Memoize
 *
 * From [Wikipedia](https://en.wikipedia.org/wiki/Memoization),
 * memoization is an optimization technique
 * used primarily to speed up computer programs,
 * by storing the results of expensive function calls
 * and returning the cached result when the same inputs occur again
 *
 * This function is a first class objects,
 * which lets us use it as [Higher-Order Function](https://eloquentjavascript.net/05_higher_order.html)
 * and return another function
 *
 * @param {Function} func Original function
 * @returns {Function} Memoized function
 */
export const memoize = (func) => {
  // Initialization of a slot to store the function result
  const cache = {}

  return (...args) => {
    // Retrieving the first argument of the function
    const [arg] = args

    /**
     * Checks if the argument is already present in the cache,
     * then return the associated value / result
     */
    if (arg in cache) {
      return cache[arg]
    }

    /**
     * If the argument is not yet present in the cache,
     * execute original function and save its value / result in cache,
     * finally return it
     */
    const result = func(arg)
    cache[arg] = result
    return result
  }
}

--#

--% C:/work/algos/Javascript/Cache/test/LFUCache.test.js
import { LFUCache } from '../LFUCache'

describe('LFUCache', () => {
  it('Example 1 (Small Cache, size=2)', () => {
    const cache = new LFUCache(2)
    cache.set(1, 1)
    cache.set(2, 2)

    expect(cache.get(1)).toBe(1)
    expect(cache.get(2)).toBe(2)

    // Additional entries triggers cache rotate
    cache.set(3, 3)

    // Then we should have a cache miss for the first entry added
    expect(cache.get(1)).toBe(null)
    expect(cache.get(2)).toBe(2)
    expect(cache.get(3)).toBe(3)

    cache.set(4, 4)
    expect(cache.get(1)).toBe(null) // cache miss
    expect(cache.get(2)).toBe(null) // cache miss
    expect(cache.get(3)).toBe(3)
    expect(cache.get(4)).toBe(4)

    expect(cache.cacheInfo()).toBe('CacheInfo(hits=6, misses=3, capacity=2, current size=2)')
  })

  it('Example 2 (Computing Fibonacci Series, size=100)', () => {
    const cache = new LFUCache(100)
    for (let i = 1; i <= 100; i++) {
      fib(i, cache)
    }
    expect(cache.cacheInfo()).toBe('CacheInfo(hits=193, misses=103, capacity=100, current size=98)')
  })
})

// Helper for building and caching Fibonacci series
function fib (num, cache = null) {
  if (cache) {
    const value = cache.get(num)
    if (value) {
      return value
    }
  }
  if (num === 1 || num === 2) {
    return 1
  }
  const result = fib(num - 1, cache) + fib(num - 2, cache)
  if (cache) {
    cache.set(num, result)
  }
  return result
}

--#

--% C:/work/algos/Javascript/Cache/test/LRUCache.test.js
import { LRUCache } from '../LRUCache'

describe('LRUCache', () => {
  it('Example 1 (Small Cache, size=2)', () => {
    const cache = new LRUCache(2)
    cache.set(1, 1)
    cache.set(2, 2)

    expect(cache.get(1)).toBe(1)
    expect(cache.get(2)).toBe(2)

    // Additional entries triggers cache rotate
    cache.set(3, 3)

    // Then we should have a cache miss for the first entry added
    expect(cache.get(1)).toBe(null)
    expect(cache.get(2)).toBe(2)
    expect(cache.get(3)).toBe(3)

    cache.set(4, 4)
    expect(cache.get(1)).toBe(null) // cache miss
    expect(cache.get(2)).toBe(null) // cache miss
    expect(cache.get(3)).toBe(3)
    expect(cache.get(4)).toBe(4)

    expect(cache.cacheInfo()).toBe('CacheInfo(hits=6, misses=3, capacity=2, current size=2)')
  })

  it('Example 2 (Computing Fibonacci Series, size=100)', () => {
    const cache = new LRUCache(100)
    for (let i = 1; i <= 100; i++) {
      fib(i, cache)
    }
    expect(cache.cacheInfo()).toBe('CacheInfo(hits=193, misses=103, capacity=100, current size=98)')
  })
})

// Helper for building and caching Fibonacci series
function fib (num, cache = null) {
  if (cache) {
    const value = cache.get(num)
    if (value) {
      return value
    }
  }
  if (num === 1 || num === 2) {
    return 1
  }
  const result = fib(num - 1, cache) + fib(num - 2, cache)
  if (cache) {
    cache.set(num, result)
  }
  return result
}

--#

--% C:/work/algos/Javascript/Cache/test/Memoize.test.js
import { memoize } from '../Memoize'

const fibonacci = (n) => {
  if (n < 2) {
    return n
  }

  return fibonacci(n - 2) + fibonacci(n - 1)
}

const factorial = (n) => {
  if (n === 0) {
    return 1
  }

  return n * factorial(n - 1)
}

describe('Memoize', () => {
  it('expects the fibonacci function to use the cache on the second call', () => {
    const memoFibonacci = memoize(fibonacci)

    expect(memoFibonacci(5)).toEqual(fibonacci(5))
    expect(memoFibonacci(5)).toEqual(5)
    expect(memoFibonacci(10)).toEqual(fibonacci(10))
    expect(memoFibonacci(10)).toEqual(55)
  })

  it('expects the factorial function to use the cache on the second call', () => {
    const memoFactorial = memoize(factorial)

    expect(memoFactorial(5)).toEqual(factorial(5))
    expect(memoFactorial(5)).toEqual(120)
    expect(memoFactorial(10)).toEqual(factorial(10))
    expect(memoFactorial(10)).toEqual(3628800)
  })
})

--#

--% C:/work/algos/Javascript/Cellular-Automata/ConwaysGameOfLife.js
/*
Conway's Game of Life
The Game of Life is a cellular automaton devised by the British mathematician John Horton Conway in 1970. The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, live or dead, (or populated and unpopulated, respectively). Every cell interacts with its eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:
  1. Any live cell with two or three live neighbours survives.
  2. Any dead cell with three live neighbours becomes a live cell.
  3. All other live cells die in the next generation. Similarly, all other dead cells stay dead.
(description adapted from https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life )
(example adapted from https://github.com/TheAlgorithms/Python/blob/master/cellular_automata/conways_game_of_life.py )
*/

/**
 * Generates the next generation for a given state of Conway's Game of Life.
 */
export function newGeneration (cells) {
  const nextGeneration = []
  for (let i = 0; i < cells.length; i++) {
    const nextGenerationRow = []
    for (let j = 0; j < cells[i].length; j++) {
      // Get the number of living neighbours
      let neighbourCount = 0
      if (i > 0 && j > 0) neighbourCount += cells[i - 1][j - 1]
      if (i > 0) neighbourCount += cells[i - 1][j]
      if (i > 0 && j < cells[i].length - 1) neighbourCount += cells[i - 1][j + 1]
      if (j > 0) neighbourCount += cells[i][j - 1]
      if (j < cells[i].length - 1) neighbourCount += cells[i][j + 1]
      if (i < cells.length - 1 && j > 0) neighbourCount += cells[i + 1][j - 1]
      if (i < cells.length - 1) neighbourCount += cells[i + 1][j]
      if (i < cells.length - 1 && j < cells[i].length - 1) neighbourCount += cells[i + 1][j + 1]

      // Decide whether the cell is alive or dead
      const alive = cells[i][j] === 1
      if ((alive && neighbourCount >= 2 && neighbourCount <= 3) || (!alive && neighbourCount === 3)) {
        nextGenerationRow.push(1)
      } else {
        nextGenerationRow.push(0)
      }
    }
    nextGeneration.push(nextGenerationRow)
  }
  return nextGeneration
}

--#

--% C:/work/algos/Javascript/Cellular-Automata/test/ConwaysGameOfLife.test.js
import { newGeneration } from '../ConwaysGameOfLife'

describe('newGeneration', () => {
  it('should produce the next generation according to the rules', () => {
    expect(newGeneration([[0, 1, 0], [0, 1, 0], [0, 1, 0]]))
      .toEqual([[0, 0, 0], [1, 1, 1], [0, 0, 0]])
  })
})

--#

--% C:/work/algos/Javascript/Ciphers/Atbash.js
/*
The Atbash cipher is a particular type of monoalphabetic cipher
formed by taking the alphabet and mapping it to its reverse,
so that the first letter becomes the last letter,
the second letter becomes the second to last letter, and so on.
*/

/**
 * Decrypt a Atbash cipher
 * @param {String} str - string to be decrypted/encrypt
 * @return {String} decrypted/encrypted string
 */
function Atbash (message) {
  let decodedString = ''
  for (let i = 0; i < message.length; i++) {
    if (/[^a-zA-Z]/.test(message[i])) {
      decodedString += message[i]
    } else if (message[i] === message[i].toUpperCase()) {
      decodedString += String.fromCharCode(90 + 65 - message.charCodeAt(i))
    } else {
      decodedString += String.fromCharCode(122 + 97 - message.charCodeAt(i))
    }
  }
  return decodedString
}

export { Atbash }

// > Atbash('HELLO WORLD')
// 'SVOOL DLIOW'

--#

--% C:/work/algos/Javascript/Ciphers/CaesarsCipher.js
/**
 * Caesar's Cipher - also known as the ROT13 Cipher is when
 * a letter is replaced by the one that is 13 spaces away
 * from it in the alphabet. If the letter is in the first half
 * of the alphabet we add 13, if it's in the latter half we
 * subtract 13 from the character code value.
 */

/**
 * Decrypt a ROT13 cipher
 * @param {String} str - string to be decrypted
 * @return {String} decrypted string
 */
function rot13 (str) {
  const response = []
  const strLength = str.length

  for (let i = 0; i < strLength; i++) {
    const char = str.charCodeAt(i)

    if (char < 65 || (char > 90 && char < 97) || char > 122) {
      response.push(str.charAt(i))
    } else if ((char > 77 && char <= 90) || (char > 109 && char <= 122)) {
      response.push(String.fromCharCode(str.charCodeAt(i) - 13))
    } else {
      response.push(String.fromCharCode(str.charCodeAt(i) + 13))
    }
  }
  return response.join('')
}

export { rot13 }

// > rot13('Uryyb Jbeyq')
// 'Hello World'

--#

--% C:/work/algos/Javascript/Ciphers/KeyFinder.js
/******************************************************
 Find and retrieve the encryption key automatically
 Note: This is a draft version, please help to modify, Thanks!
 ******************************************************/
function keyFinder (str) { // str is used to get the input of encrypted string
  const wordBank = [
    'I ',
    'You ',
    'We ',
    'They ',
    'He ',
    'She ',
    'It ',
    ' the ',
    'The ',
    ' of ',
    ' is ',
    'Is ',
    ' am ',
    'Am ',
    ' are ',
    'Are ',
    ' have ',
    'Have ',
    ' has ',
    'Has ',
    ' may ',
    'May ',
    ' be ',
    'Be ']
  // let wordbankelementCounter = 0;
  // let key = 0; // return zero means the key can not be found
  const inStr = str.toString() // convert the input to String
  let outStr = '' // store the output value
  let outStrElement = '' // temporary store the word inside the outStr, it is used for comparison
  for (let k = 0; k < 26; k++) { // try the number of key shifted, the sum of character from a-z or A-Z is 26
    outStr = caesarCipherEncodeAndDecodeEngine(inStr, k) // use the encryption engine to decrypt the input string

    // loop through the whole input string
    for (let s = 0; s < outStr.length; s++) {
      for (let i = 0; i < wordBank.length; i++) {
        // initialize the outStrElement which is a temp output string for comparison,
        // use a loop to find the next digit of wordBank element and compare with outStr's digit
        for (let w = 0; w < wordBank[i].length; w++) {
          outStrElement += outStr[s + w]
        }
        // this part need to be optimize with the calculation of the number of occurrence of word's probabilities
        // linked list will be used in the next stage of development to calculate the number of occurrence of the key
        if (wordBank[i] === outStrElement) {
          return k // return the key number if founded
        }
        outStrElement = '' // reset the temp word
      } // end for ( let i=0; i < wordBank.length; i++)
    }
  }
  return 0 // return 0 if found nothing
}

/* this sub-function is used to assist the keyFinder to find the key */
function caesarCipherEncodeAndDecodeEngine (inStr, numShifted) {
  const shiftNum = numShifted
  let charCode = 0
  let outStr = ''
  let shiftedCharCode = 0
  let result = 0

  for (let i = 0; i < inStr.length; i++) {
    charCode = inStr[i].charCodeAt()
    shiftedCharCode = charCode + shiftNum
    result = charCode

    if ((charCode >= 48 && charCode <= 57)) {
      if (shiftedCharCode < 48) {
        let diff = Math.abs(48 - 1 - shiftedCharCode) % 10

        while (diff >= 10) {
          diff = diff % 10
        }
        document.getElementById('diffID').innerHTML = diff

        shiftedCharCode = 57 - diff

        result = shiftedCharCode
      } else if (shiftedCharCode >= 48 && shiftedCharCode <= 57) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 57) {
        let diff = Math.abs(57 + 1 - shiftedCharCode) % 10

        while (diff >= 10) {
          diff = diff % 10
        }
        document.getElementById('diffID').innerHTML = diff

        shiftedCharCode = 48 + diff

        result = shiftedCharCode
      }
    } else if ((charCode >= 65 && charCode <= 90)) {
      if (shiftedCharCode <= 64) {
        let diff = Math.abs(65 - 1 - shiftedCharCode) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 90 - diff
        result = shiftedCharCode
      } else if (shiftedCharCode >= 65 && shiftedCharCode <= 90) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 90) {
        let diff = Math.abs(shiftedCharCode - 1 - 90) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 65 + diff
        result = shiftedCharCode
      }
    } else if ((charCode >= 97 && charCode <= 122)) {
      if (shiftedCharCode <= 96) {
        let diff = Math.abs(97 - 1 - shiftedCharCode) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 122 - diff
        result = shiftedCharCode
      } else if (shiftedCharCode >= 97 && shiftedCharCode <= 122) {
        result = shiftedCharCode
      } else if (shiftedCharCode > 122) {
        let diff = Math.abs(shiftedCharCode - 1 - 122) % 26

        while ((diff % 26) >= 26) {
          diff = diff % 26
        }
        shiftedCharCode = 97 + diff
        result = shiftedCharCode
      }
    }
    outStr = outStr + String.fromCharCode(parseInt(result))
  }
  return outStr
}

export { keyFinder }

// > keyFinder('test')
// 0

--#

--% C:/work/algos/Javascript/Ciphers/KeywordShiftedAlphabet.js
/**
 * Keyword shifted alphabet is a simple cipher using a translation table created with a help of a keyword.
 * Keyword must be a word where each character can occur only once.
 * To create the translation table, we write all the alphabet characters to the first.
 * Second row start with the keyword, then we continue with the rest of the characters that are missing in alphabetical order.
 *
 * |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z|
 * |K|E|Y|W|O|R|D|A|B|C|F|G|H|I|J|L|M|N|P|Q|S|T|U|V|W|Z|
 *
 * Encryption is then just a matter of writing the matching (same index) letter from the second row instead of the first row:
 * 'Hello world' -> 'Aoggj ujngw'
 *
 * Decryption is then just the reverse process of writing the matching (same index) letter from the first row instead of the second row
 * 'Aogg ujngw' -> 'Hello world'
 *
 * Non alphabetical characters (space, exclamation mark, ...) are kept as they are
 */

const alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

function checkKeywordValidity (keyword) {
  keyword.split('').forEach((char, index) => {
    const rest = keyword.slice(0, index) + keyword.slice(index + 1)
    if (rest.indexOf(char) !== -1) {
      return false
    }
  })
  return true
}

function getEncryptedAlphabet (keyword) {
  const encryptedAlphabet = keyword.split('')
  alphabet.forEach((char) => {
    if (encryptedAlphabet.indexOf(char) === -1) {
      encryptedAlphabet.push(char)
    }
  })
  return encryptedAlphabet
}

function translate (sourceAlphabet, targetAlphabet, message) {
  return message.split('').reduce((encryptedMessage, char) => {
    const isUpperCase = char === char.toUpperCase()
    const encryptedCharIndex = sourceAlphabet.indexOf(char.toLowerCase())
    const encryptedChar = encryptedCharIndex !== -1 ? targetAlphabet[encryptedCharIndex] : char
    encryptedMessage += isUpperCase ? encryptedChar.toUpperCase() : encryptedChar
    return encryptedMessage
  }, '')
}

function checkInputs (keyword, message) {
  if (!keyword || !message) {
    throw new Error('Both keyword and message must be specified')
  }

  if (!checkKeywordValidity(keyword)) {
    throw new Error('Invalid keyword!')
  }
}

function encrypt (keyword, message) {
  checkInputs(keyword, message)
  return translate(alphabet, getEncryptedAlphabet(keyword.toLowerCase()), message)
}

function decrypt (keyword, message) {
  checkInputs(keyword, message)
  return translate(getEncryptedAlphabet(keyword.toLowerCase()), alphabet, message)
}

export { encrypt, decrypt }

// encrypt('keyword', 'Hello world!') // Prints 'Aoggj ujngw!'
// decrypt('keyword', 'Aoggj ujngw!') // Prints 'Hello world!

--#

--% C:/work/algos/Javascript/Ciphers/ROT13.js
/**
 * Transcipher a ROT13 cipher
 * @param  {String} text - string to be encrypted
 * @return {String} - decrypted string
 */
const ROT13 = (text) => {
  const originalCharacterList = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
  const toBeMappedCharaterList = 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'
  const index = x => originalCharacterList.indexOf(x)
  const replace = x => index(x) > -1 ? toBeMappedCharaterList[index(x)] : x
  return text.split('').map(replace).join('')
}

export { ROT13 }

// > ROT13('The quick brown fox jumps over the lazy dog')
// 'Gur dhvpx oebja sbk whzcf bire gur ynml qbt'

--#

--% C:/work/algos/Javascript/Ciphers/VigenereCipher.js
/**
 * Check if the Character is letter or not
 * @param {String} str - character to check
 * @return {object} An array with the character or null if isn't a letter
 */
function isLetter (str) {
  return str.length === 1 && str.match(/[a-zA-Z]/i)
}

/**
 * Check if is Uppercase or Lowercase
 * @param {String} character - character to check
 * @return {Boolean} result of the checking
 */
function isUpperCase (character) {
  if (character === character.toUpperCase()) {
    return true
  }
  if (character === character.toLowerCase()) {
    return false
  }
}

/**
 * Encrypt a Vigenere cipher
 * @param {String} message - string to be encrypted
 * @param {String} key - key for encrypt
 * @return {String} result - encrypted string
 */
function encrypt (message, key) {
  let result = ''

  for (let i = 0, j = 0; i < message.length; i++) {
    const c = message.charAt(i)
    if (isLetter(c)) {
      if (isUpperCase(c)) {
        result += String.fromCharCode((c.charCodeAt(0) + key.toUpperCase().charCodeAt(j) - 2 * 65) % 26 + 65) // A: 65
      } else {
        result += String.fromCharCode((c.charCodeAt(0) + key.toLowerCase().charCodeAt(j) - 2 * 97) % 26 + 97) // a: 97
      }
    } else {
      result += c
    }
    j = ++j % key.length
  }
  return result
}

/**
 * Decrypt a Vigenere cipher
 * @param {String} message - string to be decrypted
 * @param {String} key - key for decrypt
 * @return {String} result - decrypted string
 */
function decrypt (message, key) {
  let result = ''

  for (let i = 0, j = 0; i < message.length; i++) {
    const c = message.charAt(i)
    if (isLetter(c)) {
      if (isUpperCase(c)) {
        result += String.fromCharCode(90 - (25 - (c.charCodeAt(0) - key.toUpperCase().charCodeAt(j))) % 26)
      } else {
        result += String.fromCharCode(122 - (25 - (c.charCodeAt(0) - key.toLowerCase().charCodeAt(j))) % 26)
      }
    } else {
      result += c
    }
    j = ++j % key.length
  }
  return result
}

export { encrypt, decrypt }

// > encrypt('Hello World!', 'code')
// 'Jsopq Zstzg!'

// > decrypt('Jsopq Zstzg!', 'code')
// 'Hello World!'

--#

--% C:/work/algos/Javascript/Ciphers/XORCipher.js
/**
 * The XOR cipher is a type of additive cipher.
 * Each character is bitwise XORed with the key.
 * We loop through the input string, XORing each
 * character with the key.
 */

/**
 * Encrypt using an XOR cipher
 * @param {String} str - String to be encrypted
 * @param {Number} key - key for encryption
 * @return {String} encrypted string
 */

function XOR (str, key) {
  let result = ''
  for (const elem of str) {
    result += String.fromCharCode(elem.charCodeAt(0) ^ key)
  }
  return result
}

export { XOR }

// Nb: Node REPL might not output the null char '\x00' (charcode 0)

// > XOR('test string', 32)
// 'TEST\x00STRING'

// > XOR('TEST\x00STRING', 32)
// 'test string'

--#

--% C:/work/algos/Javascript/Conversions/ArbitraryBase.js
/**
* Converts a string from one base to other
* @param {string} stringInBaseOne String in input base
* @param {string} baseOneCharacters Character set for the input base
* @param {string} baseTwoCharacters Character set for the output base
* @returns {string}
*/
const convertArbitraryBase = (stringInBaseOne, baseOneCharacters, baseTwoCharacters) => {
  if ([stringInBaseOne, baseOneCharacters, baseTwoCharacters].map(arg => typeof arg).some(type => type !== 'string')) {
    throw new TypeError('Only string arguments are allowed')
  }
  [baseOneCharacters, baseTwoCharacters].forEach(baseString => {
    const charactersInBase = [...baseString]
    if (charactersInBase.length !== new Set(charactersInBase).size) {
      throw new TypeError('Duplicate characters in character set are not allowed')
    }
  })
  const reversedStringOneChars = [...stringInBaseOne].reverse()
  const stringOneBase = baseOneCharacters.length
  let value = 0
  let placeValue = 1
  for (const digit of reversedStringOneChars) {
    const digitNumber = baseOneCharacters.indexOf(digit)
    if (digitNumber === -1) {
      throw new TypeError(`Not a valid character: ${digit}`)
    }
    value += (digitNumber * placeValue)
    placeValue *= stringOneBase
  }
  let stringInBaseTwo = ''
  const stringTwoBase = baseTwoCharacters.length
  while (value > 0) {
    const remainder = value % stringTwoBase
    stringInBaseTwo = baseTwoCharacters.charAt(remainder) + stringInBaseTwo
    value /= stringTwoBase
  }
  const baseTwoZero = baseTwoCharacters.charAt(0)
  return stringInBaseTwo.replace(new RegExp(`^${baseTwoZero}+`), '')
}

export { convertArbitraryBase }

// > convertArbitraryBase('98', '0123456789', '01234567')
// '142'

// > convertArbitraryBase('98', '0123456789', 'abcdefgh')
// 'bec'

// > convertArbitraryBase('129', '0123456789', '01234567')
// '201'

--#

--% C:/work/algos/Javascript/Conversions/ArrayBufferToBase64.js
// About base64: https://en.wikipedia.org/wiki/Base64

/**
 * Converts an array of bytes to base64 encoding
 * @param {ArrayBuffer} binaryData An ArrayBuffer which represents an array of bytes
 * @returns {string} A string containing the base64 encoding of `binaryData`
 */
function bufferToBase64 (binaryData) {
  // The base64 encoding uses the following set of characters to encode any binary data as text
  const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  // Every 3 bytes translates to 4 base64 characters, if we have less than 3 bytes we must append '=' chars as padding
  const padding = 3 - (binaryData.byteLength % 3)
  // Create an instance of Uint8Array, to read from the binaryData array buffer
  const byteView = new Uint8Array(binaryData)
  let result = ''

  // Loop through all bytes in the buffer, in increments of 3 bytes
  for (let i = 0; i < byteView.byteLength; i += 3) {
    // Get the index for the next 4 base64 chars
    const char1 = (byteView[i] & 252) >> 2
    const char2 = ((byteView[i] & 3) << 4) + ((byteView[i + 1] & 240) >> 4)
    const char3 = ((byteView[i + 1] & 15) << 2) + ((byteView[i + 2] & 192) >> 6)
    const char4 = byteView[i + 2] & 63

    result +=
        base64Table[char1] +
        base64Table[char2] +
        base64Table[char3] +
        base64Table[char4]
  }

  // Add padding '=' chars if needed
  if (padding !== 3) {
    const paddedResult = result.slice(0, result.length - padding) + '='.repeat(padding)
    return paddedResult
  }

  return result
}

export { bufferToBase64 }

--#

--% C:/work/algos/Javascript/Conversions/Base64ToArrayBuffer.js
// About base64: https://en.wikipedia.org/wiki/Base64

/**
 * Converts a base64 string to an array of bytes
 * @param {string} b64 A base64 string
 * @returns {ArrayBuffer} An ArrayBuffer representing the bytes encoded by the base64 string
 */
function base64ToBuffer (b64) {
  // The base64 encoding uses the following set of characters to encode any binary data as text
  const base64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
  // Find the index of char '=' first occurrence
  const paddingIdx = b64.indexOf('=')
  // Remove padding chars from base64 string, if there are any
  const b64NoPadding = paddingIdx !== -1 ? b64.slice(0, paddingIdx) : b64
  // Calculate the length of the result buffer
  const bufferLength = Math.floor((b64NoPadding.length * 6) / 8)
  // Create the result buffer
  const result = new ArrayBuffer(bufferLength)
  // Create an instance of Uint8Array, to write to the `result` buffer
  const byteView = new Uint8Array(result)

  // Loop through all chars in the base64 string, in increments of 4 chars, and in increments of 3 bytes
  for (let i = 0, j = 0; i < b64NoPadding.length; i += 4, j += 3) {
    // Get the index of the next 4 base64 chars
    const b64Char1 = base64Table.indexOf(b64NoPadding[i])
    const b64Char2 = base64Table.indexOf(b64NoPadding[i + 1])
    let b64Char3 = base64Table.indexOf(b64NoPadding[i + 2])
    let b64Char4 = base64Table.indexOf(b64NoPadding[i + 3])

    // If base64 chars 3 and 4 don't exit, then set them to 0
    if (b64Char3 === -1) b64Char3 = 0
    if (b64Char4 === -1) b64Char4 = 0

    // Calculate the next 3 bytes
    const byte1 = (b64Char1 << 2) + ((b64Char2 & 48) >> 4)
    const byte2 = ((b64Char2 & 15) << 4) + ((b64Char3 & 60) >> 2)
    const byte3 = ((b64Char3 & 3) << 6) + b64Char4

    byteView[j] = byte1
    byteView[j + 1] = byte2
    byteView[j + 2] = byte3
  }

  return result
}

export { base64ToBuffer }

--#

--% C:/work/algos/Javascript/Conversions/BinaryToDecimal.js
export default function binaryToDecimal (binaryString) {
  let decimalNumber = 0
  const binaryDigits = binaryString.split('').reverse() // Splits the binary number into reversed single digits
  binaryDigits.forEach((binaryDigit, index) => {
    decimalNumber += binaryDigit * (Math.pow(2, index)) // Summation of all the decimal converted digits
  })
  return decimalNumber
}

--#

--% C:/work/algos/Javascript/Conversions/BinaryToHex.js
const pad = (num, padlen) => {
  const pad = new Array(1 + padlen).join(0)
  return (pad + num).slice(-pad.length)
}

const hexLookup = (bin) => {
  let binary = bin
  if (binary.length < 4) {
    binary = pad(binary, 4)
  }
  switch (binary) {
    case '0000': return '0'
    case '0001': return '1'
    case '0010': return '2'
    case '0011': return '3'
    case '0100': return '4'
    case '0101': return '5'
    case '0110': return '6'
    case '0111': return '7'
    case '1000': return '8'
    case '1001': return '9'
    case '1010': return 'A'
    case '1011': return 'B'
    case '1100': return 'C'
    case '1101': return 'D'
    case '1110': return 'E'
    case '1111': return 'F'
  }
}
const binaryToHex = (binaryString) => {
  /*
  Function for convertung Binary to Hex

  1. The conversion will start from Least Significant Digit (LSB) to the Most Significant Bit (MSB).
  2. We divide the bits into sections of 4-bits starting from LSB to MSB.
  3. If the MSB get less than 4 bits, then we pad 0s to the front of it.

  For Example:
  Binary String = '1001101'

  1. Divide it to 2 parts => ['100', '1101']
  2. Pad 0s the MSB so it'll be => ['0100', '1101']
  3. Use the lookup table and merge them, therefore the result is 4D.

  */

  let result = ''
  binaryString = binaryString.split('')
  for (let i = binaryString.length - 1; i >= 0; i = i - 4) {
    if (i >= 3) {
      result += hexLookup(binaryString.slice(i - 3, i + 1).join(''))
    } else {
      result += hexLookup(binaryString.slice(0, i + 1).join(''))
    }
  }
  return result.split('').reverse().join('')
}

export default binaryToHex

--#

--% C:/work/algos/Javascript/Conversions/DateDayDifference.js
/*
    DateDayDifference Method
    ------------------------
    DateDayDifference method calculates the number of days between two dates.

    Algorithm & Explanation : https://ncalculators.com/time-date/date-difference-calculator.htm
*/

// Internal method for make calculations easier
const isLeap = (year) => {
  if (year % 400 === 0) return true
  else if (year % 100 === 0) return false
  else if (year % 4 === 0) return true
  else return false
}
const DateToDay = (dd, mm, yyyy) => {
  return Math.floor((365 * (yyyy - 1)) + ((yyyy - 1) / 4) - ((yyyy - 1) / 100) + ((yyyy - 1) / 400) + dd + (((367 * mm) - 362) / 12) + (mm <= 2 ? 0 : isLeap(yyyy) ? -1 : -2))
}

const DateDayDifference = (date1, date2) => {
  // firstly, check that both input are string or not.
  if (typeof date1 !== 'string' && typeof date2 !== 'string') {
    return new TypeError('Argument is not a string.')
  }
  // extract the first date
  const [firstDateDay, firstDateMonth, firstDateYear] = date1.split('/').map((ele) => Number(ele))
  // extract the second date
  const [secondDateDay, secondDateMonth, secondDateYear] = date2.split('/').map((ele) => Number(ele))
  // check the both data are valid or not.
  if (firstDateDay < 0 || firstDateDay > 31 ||
        firstDateMonth > 12 || firstDateMonth < 0 ||
        secondDateDay < 0 || secondDateDay > 31 ||
        secondDateMonth > 12 || secondDateMonth < 0) {
    return new TypeError('Date is not valid.')
  }
  return Math.abs(DateToDay(secondDateDay, secondDateMonth, secondDateYear) - DateToDay(firstDateDay, firstDateMonth, firstDateYear))
}

// Example : DateDayDifference('17/08/2002', '10/10/2020') => 6630

export { DateDayDifference }

--#

--% C:/work/algos/Javascript/Conversions/DateToDay.js
/*
                    DateToDay Method
                    ----------------
    The DateToDay method takes a date in string format and
    returns the name of a day. The approach behind this method
    is very simple, we first take a string date and check
    whether their date is valid or not, if the date is valid
    then we do this But apply the algorithm shown below. The
    algorithm shown below gives us the number of the day and
    finally converts it to the name of the day.

    Algorithm & Explanation : https://cs.uwaterloo.ca/~alopez-o/math-faq/node73.html
*/

// March is taken as the first month of the year.
const calcMonthList = {
  1: 11,
  2: 12,
  3: 1,
  4: 2,
  5: 3,
  6: 4,
  7: 5,
  8: 6,
  9: 7,
  10: 8,
  11: 9,
  12: 10
}

// show the week day in a number : Sunday - Saturday => 0 - 6
const daysNameList = { // weeks-day
  0: 'Sunday',
  1: 'Monday',
  2: 'Tuesday',
  3: 'Wednesday',
  4: 'Thursday',
  5: 'Friday',
  6: 'Saturday'
}

const DateToDay = (date) => {
  // firstly, check that input is a string or not.
  if (typeof date !== 'string') {
    return new TypeError('Argument is not a string.')
  }
  // extract the date
  const [day, month, year] = date.split('/').map((x) => Number(x))
  // check the data are valid or not.
  if (day < 0 || day > 31 || month > 12 || month < 0) {
    return new TypeError('Date is not valid.')
  }
  // divide year to century and yearDigit value.
  const yearDigit = (year % 100)
  const century = Math.floor(year / 100)
  // Apply the algorithm shown above
  const weekDay = Math.abs((day + Math.floor((2.6 * calcMonthList[month]) - 0.2) - (2 * century) + yearDigit + Math.floor(yearDigit / 4) + Math.floor(century / 4)) % 7)
  // return the weekDay name.
  return daysNameList[weekDay]
}

// Example : DateToDay("18/12/2020") => Friday

export { DateToDay }

--#

--% C:/work/algos/Javascript/Conversions/DecimalToBinary.js
function decimalToBinary (num) {
  const bin = []
  while (num > 0) {
    bin.unshift(num % 2)
    num >>= 1 // basically /= 2 without remainder if any
  }
  return bin.join('')
}

export { decimalToBinary }

// > decimalToBinary(2)
// '10'

// > decimalToBinary(7)
// '111'

// > decimalToBinary(35)
// '100011'

--#

--% C:/work/algos/Javascript/Conversions/DecimalToHex.js
function intToHex (num) {
  switch (num) {
    case 10: return 'A'
    case 11: return 'B'
    case 12: return 'C'
    case 13: return 'D'
    case 14: return 'E'
    case 15: return 'F'
  }
  return num
}

function decimalToHex (num) {
  const hexOut = []
  while (num > 15) {
    hexOut.unshift(intToHex(num % 16))
    num = Math.floor(num / 16)
  }
  return intToHex(num) + hexOut.join('')
}

export { decimalToHex }

--#

--% C:/work/algos/Javascript/Conversions/DecimalToOctal.js
function decimalToOctal (num) {
  let oct = 0
  let c = 0
  while (num > 0) {
    const r = num % 8
    oct = oct + (r * Math.pow(10, c++))
    num = Math.floor(num / 8) // basically /= 8 without remainder if any
  }
  return oct
}

export { decimalToOctal }

// > decimalToOctal(2)
// 2

// > decimalToOctal(8)
// 10

// > decimalToOctal(65)
// 101

// > decimalToOctal(216)
// 330

// > decimalToOctal(512)
// 1000

--#

--% C:/work/algos/Javascript/Conversions/DecimalToRoman.js
/*
    Decimal To Roman

    This algorithm take decimal number and convert to roman numeral according to standard form (https://en.wikipedia.org/wiki/Roman_numerals#Description)

    Algorithm & Explanation : https://www.rapidtables.com/convert/number/how-number-to-roman-numerals.html
*/

const values = {
  M: 1000,
  CM: 900,
  D: 500,
  CD: 400,
  C: 100,
  XC: 90,
  L: 50,
  XL: 40,
  X: 10,
  IX: 9,
  V: 5,
  IV: 4,
  I: 1
}

const orders = [
  'M',
  'CM',
  'D',
  'CD',
  'C',
  'XC',
  'L',
  'XL',
  'X',
  'IX',
  'V',
  'IV',
  'I'
]

function decimalToRoman (num) {
  let roman = ''
  for (const symbol of orders) {
    while (num >= values[symbol]) {
      roman += symbol
      num -= values[symbol]
    }
  }
  return roman
}

export { decimalToRoman }

--#

--% C:/work/algos/Javascript/Conversions/HexToBinary.js
const binLookup = (c) => {
  switch (c.toLowerCase()) {
    case '0': return '0000'
    case '1': return '0001'
    case '2': return '0010'
    case '3': return '0011'
    case '4': return '0100'
    case '5': return '0101'
    case '6': return '0110'
    case '7': return '0111'
    case '8': return '1000'
    case '9': return '1001'
    case 'a': return '1010'
    case 'b': return '1011'
    case 'c': return '1100'
    case 'd': return '1101'
    case 'e': return '1110'
    case 'f': return '1111'
    default: return ''
  }
}
const hexToBinary = (hexString) => {
  /*
    Function for converting Hex to Binary

    1. We convert every hexadecimal bit to 4 binary bits
    2. Conversion goes by searching in the lookup table

    */
  const hexLexemes = hexString.split('')
  return hexLexemes.map(lexeme => binLookup(lexeme)).join('')
}

export default hexToBinary

--#

--% C:/work/algos/Javascript/Conversions/HexToDecimal.js
function hexToInt (hexNum) {
  const numArr = hexNum.split('') // converts number to array
  return numArr.map((item, index) => {
    switch (item) {
      case 'A': return 10
      case 'B': return 11
      case 'C': return 12
      case 'D': return 13
      case 'E': return 14
      case 'F': return 15
      default: return parseInt(item)
    }
  })
}

function hexToDecimal (hexNum) {
  const intItemsArr = hexToInt(hexNum)
  return intItemsArr.reduce((accumulator, current, index) => {
    return accumulator + (current * Math.pow(16, (intItemsArr.length - (1 + index))))
  }, 0)
}

export { hexToInt, hexToDecimal }

--#

--% C:/work/algos/Javascript/Conversions/HexToRGB.js
function hexStringToRGB (hexString) {
  let r = hexString.substring(0, 2)
  let g = hexString.substring(2, 4)
  let b = hexString.substring(4, 6)

  r = parseInt(r, 16)
  g = parseInt(g, 16)
  b = parseInt(b, 16)
  const obj = { r, g, b }

  return obj
}

export { hexStringToRGB }

// > hexStringToRGB('ffffff')
// { r: 255, g: 255, b: 255 }

--#

--% C:/work/algos/Javascript/Conversions/LowerCaseConversion.js
/*
    Explanation :- a user gives a String (it can be incomplete uppercase or
        partial uppercase) and then the program would convert it into a
        complete(all characters in lower case) lower case string. The
        logic we have used in the following program is: All the upper case
        characters (A-Z) has ASCII value ranging from 65 to 90 and their
        corresponding lower case characters (a-z) have ASCII values 32
        greater than them. For example A has an ASCII value of 65
        and a has an ASCII value of 97 (65+32). The same applies to other
        characters.
*/

/**
 * LowerCaseConversion takes any case-style string and converts it to the lower case-style string.
 * @param {String} inputString any case style string
 * @returns {String} lower case string
 */
const LowerCaseConversion = (inputString) => {
  // Take a string and split it into characters.
  const newString = inputString.split('').map(char => {
    // Get a character code by the use charCodeAt method.
    const presentCharCode = char.charCodeAt()
    // If the character code lies between 65 to 90 it means they are in the upper case so convert it.
    if (presentCharCode >= 65 && presentCharCode <= 90) {
      // Convert the case by use of the above explanation.
      return String.fromCharCode(presentCharCode + 32)
    }
    // Else return the characters without any modification.
    return char
  })
  // After modification, with the help of the join method, join all the characters and return them.
  return newString.join('')
}

export { LowerCaseConversion }

--#

--% C:/work/algos/Javascript/Conversions/MeterToFeetConversion.js
// Foot: https://en.wikipedia.org/wiki/Foot_(unit)
const feetToMeter = (feet) => {
  return feet * 0.3048
}

const meterToFeet = (meter) => {
  return meter / 0.3048
}

export { feetToMeter, meterToFeet }

--#

--% C:/work/algos/Javascript/Conversions/OctToDecimal.js
function octalToDecimal (num) {
  let dec = 0
  let base = 1
  while (num > 0) {
    const r = num % 10
    num = Math.floor(num / 10)
    dec = dec + (r * base)
    base = base * 8
  }
  return dec
}

export { octalToDecimal }

// > octalToDecimal(56)
// 46

// > octalToDecimal(2365)
// 1269

--#

--% C:/work/algos/Javascript/Conversions/RailwayTimeConversion.js
/*
    The time conversion of normalized time to the railway is a simple algorithm
    because we know that if the time is in 'AM' value it means they only want
    some changes on hours and minutes and if the time in 'PM' it means the only
    want some changes in hour value.

    Input Format -> 07:05:45PM
    Output Format -> 19:05:45

    Problem & Explanation Source : https://www.mathsisfun.com/time.html
*/

/**
 * RailwayTimeConversion method converts normalized time string to Railway time string.
 * @param {String} timeString Normalized time string.
 * @returns {String} Railway time string.
 */
const RailwayTimeConversion = (timeString) => {
  // firstly, check that input is a string or not.
  if (typeof timeString !== 'string') {
    return new TypeError('Argument is not a string.')
  }
  // split the string by ':' character.
  const [hour, minute, scondWithShift] = timeString.split(':')
  // split second and shift value.
  const [second, shift] = [scondWithShift.substr(0, 2), scondWithShift.substr(2)]
  // convert shifted time to not-shift time(Railway time) by using the above explanation.
  if (shift === 'PM') {
    if (parseInt(hour) === 12) { return `${hour}:${minute}:${second}` } else { return `${parseInt(hour) + 12}:${minute}:${second}` }
  } else {
    if (parseInt(hour) === 12) { return `00:${minute}:${second}` } else { return `${hour}:${minute}:${second}` }
  }
}

export { RailwayTimeConversion }

--#

--% C:/work/algos/Javascript/Conversions/RgbHsvConversion.js
/*
 * The RGB color model is an additive color model in which red, green, and blue light are added
 * together in various ways to reproduce a broad array of colors. The name of the model comes from
 * the initials of the three additive primary colors, red, green, and blue. Meanwhile, the HSV
 * representation models how colors appear under light. In it, colors are represented using three
 * components: hue, saturation and (brightness-)value. This file provides functions for converting
 * colors from one representation to the other. (description adapted from
 * https://en.wikipedia.org/wiki/RGB_color_model and https://en.wikipedia.org/wiki/HSL_and_HSV).
 */

/**
 * Conversion from the HSV-representation to the RGB-representation.
 *
 * @param hue Hue of the color.
 * @param saturation Saturation of the color.
 * @param value Brightness-value of the color.
 * @return The tuple of RGB-components.
 */
export function hsvToRgb (hue, saturation, value) {
  if (hue < 0 || hue > 360) {
    throw new Error('hue should be between 0 and 360')
  }

  if (saturation < 0 || saturation > 1) {
    throw new Error('saturation should be between 0 and 1')
  }

  if (value < 0 || value > 1) {
    throw new Error('value should be between 0 and 1')
  }

  const chroma = value * saturation
  const hueSection = hue / 60
  const secondLargestComponent = chroma * (1 - Math.abs(hueSection % 2 - 1))
  const matchValue = value - chroma

  return getRgbBySection(hueSection, chroma, matchValue, secondLargestComponent)
}

/**
 * Conversion from the RGB-representation to the HSV-representation.
 *
 * @param red Red-component of the color.
 * @param green Green-component of the color.
 * @param blue Blue-component of the color.
 * @return The tuple of HSV-components.
 */
export function rgbToHsv (red, green, blue) {
  if (red < 0 || red > 255) {
    throw new Error('red should be between 0 and 255')
  }

  if (green < 0 || green > 255) {
    throw new Error('green should be between 0 and 255')
  }

  if (blue < 0 || blue > 255) {
    throw new Error('blue should be between 0 and 255')
  }

  const dRed = red / 255
  const dGreen = green / 255
  const dBlue = blue / 255
  const value = Math.max(Math.max(dRed, dGreen), dBlue)
  const chroma = value - Math.min(Math.min(dRed, dGreen), dBlue)
  const saturation = value === 0 ? 0 : chroma / value
  let hue

  if (chroma === 0) {
    hue = 0
  } else if (value === dRed) {
    hue = 60 * ((dGreen - dBlue) / chroma)
  } else if (value === dGreen) {
    hue = 60 * (2 + (dBlue - dRed) / chroma)
  } else {
    hue = 60 * (4 + (dRed - dGreen) / chroma)
  }

  hue = (hue + 360) % 360

  return [hue, saturation, value]
}

export function approximatelyEqualHsv (hsv1, hsv2) {
  const bHue = Math.abs(hsv1[0] - hsv2[0]) < 0.2
  const bSaturation = Math.abs(hsv1[1] - hsv2[1]) < 0.002
  const bValue = Math.abs(hsv1[2] - hsv2[2]) < 0.002

  return bHue && bSaturation && bValue
}

function getRgbBySection (hueSection, chroma, matchValue, secondLargestComponent) {
  function convertToInt (input) {
    return Math.round(255 * input)
  }

  let red
  let green
  let blue

  if (hueSection >= 0 && hueSection <= 1) {
    red = convertToInt(chroma + matchValue)
    green = convertToInt(secondLargestComponent + matchValue)
    blue = convertToInt(matchValue)
  } else if (hueSection > 1 && hueSection <= 2) {
    red = convertToInt(secondLargestComponent + matchValue)
    green = convertToInt(chroma + matchValue)
    blue = convertToInt(matchValue)
  } else if (hueSection > 2 && hueSection <= 3) {
    red = convertToInt(matchValue)
    green = convertToInt(chroma + matchValue)
    blue = convertToInt(secondLargestComponent + matchValue)
  } else if (hueSection > 3 && hueSection <= 4) {
    red = convertToInt(matchValue)
    green = convertToInt(secondLargestComponent + matchValue)
    blue = convertToInt(chroma + matchValue)
  } else if (hueSection > 4 && hueSection <= 5) {
    red = convertToInt(secondLargestComponent + matchValue)
    green = convertToInt(matchValue)
    blue = convertToInt(chroma + matchValue)
  } else {
    red = convertToInt(chroma + matchValue)
    green = convertToInt(matchValue)
    blue = convertToInt(secondLargestComponent + matchValue)
  }

  return [red, green, blue]
}

--#

--% C:/work/algos/Javascript/Conversions/RGBToHex.js
function RGBToHex (r, g, b) {
  if (
    typeof r !== 'number' ||
    typeof g !== 'number' ||
    typeof b !== 'number'
  ) {
    throw new TypeError('argument is not a Number')
  }

  const toHex = n => (n || '0').toString(16).padStart(2, '0')

  return `#${toHex(r)}${toHex(g)}${toHex(b)}`
}

export { RGBToHex }

// > RGBToHex(255, 255, 255)
// '#ffffff'

// > RGBToHex(255, 99, 71)
// '#ff6347'

--#

--% C:/work/algos/Javascript/Conversions/RomanToDecimal.js
const values = {
  I: 1,
  V: 5,
  X: 10,
  L: 50,
  C: 100,
  D: 500,
  M: 1000
}

export function romanToDecimal (romanNumber) {
  let prev = ' '

  let sum = 0

  let newPrev = 0
  for (let i = romanNumber.length - 1; i >= 0; i--) {
    const c = romanNumber.charAt(i)

    if (prev !== ' ') {
      newPrev = values[prev] > newPrev ? values[prev] : newPrev
    }

    const currentNum = values[c]
    if (currentNum >= newPrev) {
      sum += currentNum
    } else {
      sum -= currentNum
    }

    prev = c
  }
  return sum
}

--#

--% C:/work/algos/Javascript/Conversions/TemperatureConversion.js
// This files has functions to convert different temperature units
// Functions take temperature value as a argument and returns corresponding converted value

const celsiusToFahrenheit = (celsius) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  return Math.round(((celsius) * 9 / 5) + 32)
}

const celsiusToKelvin = (celsius) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  return Math.round((celsius) + 273.15)
}

const celsiusToRankine = (celsius) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  return Math.round(((celsius) * 9 / 5) + 491.67)
}

const fahrenheitToCelsius = (fahrenheit) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  return Math.round(((fahrenheit) - 32) * 5 / 9)
}

const fahrenheitToKelvin = (fahrenheit) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  return Math.round((((fahrenheit) - 32) * 5 / 9) + 273.15)
}

const fahrenheitToRankine = (fahrenheit) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  return Math.round((fahrenheit) + 459.67)
}

const kelvinToCelsius = (kelvin) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  return Math.round((kelvin) - 273.15)
}

const kelvinToFahrenheit = (kelvin) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  return Math.round((((kelvin) - 273.15) * 9 / 5) + 32)
}

const kelvinToRankine = (kelvin) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  return Math.round(((kelvin) * 9 / 5))
}

const rankineToCelsius = (rankine) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  // Wikipedia reference: https://en.wikipedia.org/wiki/Celsius
  return Math.round(((rankine) - 491.67) * 5 / 9)
}

const rankineToFahrenheit = (rankine) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  // Wikipedia reference: https://en.wikipedia.org/wiki/Fahrenheit
  return Math.round((rankine) - 459.67)
}

const rankineToKelvin = (rankine) => {
  // Wikipedia reference: https://en.wikipedia.org/wiki/Rankine_scale
  // Wikipedia reference: https://en.wikipedia.org/wiki/Kelvin
  return Math.round(((rankine) * 5 / 9))
}

const reaumurToKelvin = (reaumur) => {
  // Reference:- http://www.csgnetwork.com/temp2conv.html
  return Math.round(((reaumur) * 1.25 + 273.15))
}

const reaumurToFahrenheit = (reaumur) => {
  // Reference:- http://www.csgnetwork.com/temp2conv.html
  return Math.round(((reaumur) * 2.25 + 32))
}

const reaumurToCelsius = (reaumur) => {
  // Reference:- http://www.csgnetwork.com/temp2conv.html
  return Math.round(((reaumur) * 1.25))
}

const reaumurToRankine = (reaumur) => {
  // Reference:- http://www.csgnetwork.com/temp2conv.html
  return Math.round(((reaumur) * 2.25 + 32 + 459.67))
}

export {
  celsiusToFahrenheit, celsiusToKelvin, celsiusToRankine,
  fahrenheitToCelsius, fahrenheitToKelvin, fahrenheitToRankine,
  kelvinToCelsius, kelvinToFahrenheit, kelvinToRankine,
  rankineToCelsius, rankineToFahrenheit, rankineToKelvin,
  reaumurToCelsius, reaumurToFahrenheit, reaumurToKelvin, reaumurToRankine
}

--#

--% C:/work/algos/Javascript/Conversions/TitleCaseConversion.js
/*
    Problem statement and Explanation : https://www.codeproject.com/Tips/162540/Letter-Case-Conversion-Algorithms-Title-Case-Toggl.
    [Title case](https://en.wikipedia.org/wiki/Title_case) is a style where all words are capitalized. Officially, title case
    does not capitalize some words, such as very short words like "a" or "is", but for the purposes of this function, a general approach
    is taken where all words are capitalized regardless of length.
*/

/**
 * The titleCaseConversion function converts a string into a title case string.
 * @param {string} inputString The input string which can have any types of letter casing.
 * @returns {string} A string that is in title case.
 */
const titleCaseConversion = (inputString) => {
  if (inputString === '') return ''
  // Extract all space separated string.
  const stringCollections = inputString.split(' ').map(word => {
    let firstChar = ''
    // Get the [ASCII](https://en.wikipedia.org/wiki/ASCII) character code by the use charCodeAt method.
    const firstCharCode = word[0].charCodeAt()
    // If the ASCII character code lies between 97 to 122 it means they are in the lowercase so convert it.
    if (firstCharCode >= 97 && firstCharCode <= 122) {
      // Convert the case by use of the above explanation.
      firstChar += String.fromCharCode(firstCharCode - 32)
    } else {
      // Else store the characters without any modification.
      firstChar += word[0]
    }
    const newWordChar = word.slice(1).split('').map(char => {
      // Get the ASCII character code by the use charCodeAt method.
      const presentCharCode = char.charCodeAt()
      // If the ASCII character code lies between 65 to 90, it means they are in the uppercase so convert it.
      if (presentCharCode >= 65 && presentCharCode <= 90) {
        // Convert the case by use of the above explanation.
        return String.fromCharCode(presentCharCode + 32)
      }
      // Else return the characters without any modification.
      return char
    })
    // Return the first converted character and remaining character string.
    return firstChar + newWordChar.join('')
  })
  // Convert all words in a string and return it.
  return stringCollections.join(' ')
}

export { titleCaseConversion }

--#

--% C:/work/algos/Javascript/Conversions/UpperCaseConversion.js
/*
    Explanation :- A user gives a string (it can be incomplete lowercase or
        partially in lowercase) and then the program converts it into a
        completely (all characters in uppercase) uppercase string. The
        logic we have used in the following program is: All the lowercase
        characters (a-z) has [ASCII](https://en.wikipedia.org/wiki/ASCII) value ranging from 97 to 122 and their
        corresponding uppercase characters (A-Z) have ASCII values 32
        lesser than them. For example a has an ASCII value of 97
        and A has an ASCII value of 65 (97 - 32). The same applies to other
        characters.
*/

/**
 * upperCaseConversion takes any case-style string and converts it to the uppercase-style string.
 * @param {string} inputString Any case style string
 * @returns {string} Uppercase string
 */
const upperCaseConversion = (inputString) => {
  // Take a string and split it into characters.
  const newString = inputString.split('').map(char => {
    // Get a character code by the use charCodeAt method.
    const presentCharCode = char.charCodeAt()
    // If the character code lies between 97 to 122, it means they are in the lowercase so convert it.
    if (presentCharCode >= 97 && presentCharCode <= 122) {
      // Convert the case by use of the above explanation.
      return String.fromCharCode(presentCharCode - 32)
    }
    // Else return the characters without any modification.
    return char
  })
  // After modification, with the help of the join method, join all the characters and return them.
  return newString.join('')
}

export { upperCaseConversion }

--#

--% C:/work/algos/Javascript/Conversions/test/ArrayBufferToBase64.test.js
import { bufferToBase64 } from '../ArrayBufferToBase64'
import { TextEncoder } from 'util'

describe('ArrayBufferToBase64', () => {
  it('should encode "Hello, world!" as "SGVsbG8sIHdvcmxkIQ=="', () => {
    const testString = 'Hello, world!'
    const encoder = new TextEncoder()
    const helloWorldBuffer = encoder.encode(testString)
    const result = bufferToBase64(helloWorldBuffer)
    expect(result).toBe('SGVsbG8sIHdvcmxkIQ==')
  })

  it('should encode binary buffer [55,23,177,234,68,26,90] as "Nxex6kQaWg=="', () => {
    const testBuffer = new Uint8Array([55, 23, 177, 234, 68, 26, 90])
    const result = bufferToBase64(testBuffer)
    expect(result).toBe('Nxex6kQaWg==')
  })

  it('should encode binary buffer [0,1,2,3,4,5,6,7,8,9] as "AAECAwQFBgcICQ=="', () => {
    const testBuffer = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    const result = bufferToBase64(testBuffer)
    expect(result).toBe('AAECAwQFBgcICQ==')
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/Base64ToArrayBuffer.test.js
import { base64ToBuffer } from '../Base64ToArrayBuffer'
import { TextDecoder } from 'util'

describe('Base64ToArrayBuffer', () => {
  it('should decode "SGVsbG8sIHdvcmxkIQ==" as "Hello, world!"', () => {
    const testBase64String = 'SGVsbG8sIHdvcmxkIQ=='
    const buffer = base64ToBuffer(testBase64String)
    const decoder = new TextDecoder()
    const helloWorldString = decoder.decode(buffer)
    expect(helloWorldString).toBe('Hello, world!')
  })

  it('should decode base64 "Nxex6kQaWg==" as binary buffer [55,23,177,234,68,26,90]', () => {
    const testBase64String = 'Nxex6kQaWg=='
    const buffer = base64ToBuffer(testBase64String)
    const array = [...new Uint8Array(buffer)]
    expect(array).toEqual([55, 23, 177, 234, 68, 26, 90])
  })

  it('should decode base64 "AAECAwQFBgcICQ==" as binary buffer [0,1,2,3,4,5,6,7,8,9]', () => {
    const testBase64String = 'AAECAwQFBgcICQ=='
    const buffer = base64ToBuffer(testBase64String)
    const array = [...new Uint8Array(buffer)]
    expect(array).toEqual([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/BinaryToDecimal.test.js
import binaryToDecimal from '../BinaryToDecimal'

describe('BinaryToDecimal', () => {
  it('expects to return correct decimal value', () => {
    expect(binaryToDecimal('1000')).toBe(8)
  })

  it('expects to return correct hexadecimal value for more than one hex digit', () => {
    expect(binaryToDecimal('01101000')).toBe(104)
  })

  it('expects to return correct hexadecimal value for padding-required binary', () => {
    expect(binaryToDecimal('1000101')).toBe(69)
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/BinaryToHex.test.js
import binaryToHex from '../BinaryToHex'

describe('BinaryToHex', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(binaryToHex('1000')).toBe('8')
  })

  it('expects to return correct hexadecimal value for more than one hex digit', () => {
    expect(binaryToHex('11101010')).toBe('EA')
  })

  it('expects to return correct hexadecimal value for padding-required binary', () => {
    expect(binaryToHex('1001101')).toBe('4D')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(16)', () => {
    expect(binaryToHex('1111')).toBe(parseInt('1111', 2).toString(16).toUpperCase())
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/DecimalToHex.test.js
import { decimalToHex } from '../DecimalToHex'

describe('DecimalToHex', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(decimalToHex(255)).toBe('FF')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(16)', () => {
    expect(decimalToHex(32768)).toBe((32768).toString(16).toUpperCase())
  })

  it('expects to not handle negative numbers', () => {
    expect(decimalToHex(-32768)).not.toBe((-32768).toString(16).toUpperCase())
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/DecimalToRoman.test.js
import { decimalToRoman } from '../DecimalToRoman'

describe('decimalToRoman', () => {
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(34)).toBe('XXXIV')
  })
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(28)).toBe('XXVIII')
  })
  it('expects to return correct roman numeral of given number', () => {
    expect(decimalToRoman(2021)).toBe('MMXXI')
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/HexToBinary.test.js
import hexToBinary from '../HexToBinary'

describe('hexToBinary', () => {
  it('expects to return correct hexadecimal value', () => {
    expect(hexToBinary('8')).toBe('1000')
  })

  it('expects to return correct binary value for more than one hex digit', () => {
    expect(hexToBinary('EA')).toBe('11101010')
  })

  it('expects to test its robustness as it should be case-insensitive', () => {
    expect(hexToBinary('4d')).toBe('01001101')
  })

  it('expects to return correct hexadecimal value, matching (num).toString(2)', () => {
    expect(hexToBinary('F')).toBe(parseInt('F', 16).toString(2))
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/MeterToFeetConversion.test.js
import { meterToFeet, feetToMeter } from '../MeterToFeetConversion'

describe('Testing conversion of Meter to Feet', () => {
  it('with feet value', () => {
    expect(meterToFeet(30.48)).toBe(100)
  })
})

describe('Testing conversion of Feet to Meter', () => {
  it('with feet value', () => {
    expect(feetToMeter(10)).toBe(3.048)
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/RgbHsvConversion.test.js
import { approximatelyEqualHsv, hsvToRgb, rgbToHsv } from '../RgbHsvConversion'

describe('hsvToRgb', () => {
  // Expected RGB-values taken from https://www.rapidtables.com/convert/color/hsv-to-rgb.html
  it('should calculate the correct RGB values', () => {
    expect(hsvToRgb(0, 0, 0)).toEqual([0, 0, 0])
    expect(hsvToRgb(0, 0, 1)).toEqual([255, 255, 255])
    expect(hsvToRgb(0, 1, 1)).toEqual([255, 0, 0])
    expect(hsvToRgb(60, 1, 1)).toEqual([255, 255, 0])
    expect(hsvToRgb(120, 1, 1)).toEqual([0, 255, 0])
    expect(hsvToRgb(240, 1, 1)).toEqual([0, 0, 255])
    expect(hsvToRgb(300, 1, 1)).toEqual([255, 0, 255])
    expect(hsvToRgb(180, 0.5, 0.5)).toEqual([64, 128, 128])
    expect(hsvToRgb(234, 0.14, 0.88)).toEqual([193, 196, 224])
    expect(hsvToRgb(330, 0.75, 0.5)).toEqual([128, 32, 80])
  })
})

describe('rgbToHsv', () => {
  // "approximatelyEqualHsv" needed because of small deviations due to rounding for the RGB-values
  it('should calculate the correct HSV values', () => {
    expect(approximatelyEqualHsv(rgbToHsv(0, 0, 0), [0, 0, 0])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 255, 255), [0, 0, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 0, 0), [0, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 255, 0), [60, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(0, 255, 0), [120, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(0, 0, 255), [240, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(255, 0, 255), [300, 1, 1])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(64, 128, 128), [180, 0.5, 0.5])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(193, 196, 224), [234, 0.14, 0.88])).toEqual(true)
    expect(approximatelyEqualHsv(rgbToHsv(128, 32, 80), [330, 0.75, 0.5])).toEqual(true)
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/RomanToDecimal.test.js
import { romanToDecimal } from '../RomanToDecimal'

describe('romanToDecimal', () => {
  it('XXIIVV', () => {
    expect(romanToDecimal('XXIIVV')).toBe(28)
  })

  it('MDCCCIV', () => {
    expect(romanToDecimal('MDCCCIV')).toBe(1804)
  })

  it('XXIVI', () => {
    expect(romanToDecimal('XXIVI')).toBe(25)
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/TemperatureConversion.test.js
import * as tc from '../TemperatureConversion.js'

describe('Testing Conversion of Celsius to fahrenheit', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToFahrenheit(10)
    expect(test1).toBe(50)
  })
})

describe('Testing Conversion of Celsius to kelvin', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToKelvin(15)
    expect(test1).toBe(288)
  })
})

describe('Testing Conversion of Celsius to Rankine', () => {
  it('with celsius value', () => {
    const test1 = tc.celsiusToRankine(28)
    expect(test1).toBe(542)
  })
})

describe('Testing Conversion of Fahrenheit to Celsius', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToCelsius(134)
    expect(test1).toBe(57)
  })
})

describe('Testing Conversion of Fahrenheit to Kelvin', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToKelvin(125)
    expect(test1).toBe(325)
  })
})

describe('Testing Conversion of Fahrenheit to Rankine', () => {
  it('with Fahrenheit value', () => {
    const test1 = tc.fahrenheitToRankine(10)
    expect(test1).toBe(470)
  })
})

describe('Testing Conversion of Kelvin to Celsius', () => {
  it('with Kelvin value', () => {
    const test1 = tc.kelvinToCelsius(100)
    expect(test1).toBe(-173)
  })
})

describe('Testing Conversion of Kelvin to Fahrenheit', () => {
  it('with Kelvin value', () => {
    const test1 = tc.kelvinToFahrenheit(20)
    expect(test1).toBe(-424)
  })
})

describe('Testing Conversion of Kelvin to Rankine', () => {
  it('with kelvin value', () => {
    const test1 = tc.kelvinToRankine(69)
    expect(test1).toBe(124)
  })
})
describe('Testing Conversion of Rankine to Celsius', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToCelsius(234)
    expect(test1).toBe(-143)
  })
})
describe('Testing Conversion of Rankine to Fahrenheit', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToFahrenheit(98)
    expect(test1).toBe(-362)
  })
})
describe('Testing Conversion of Rankine to Kelvin', () => {
  it('with Rankine value', () => {
    const test1 = tc.rankineToKelvin(10)
    expect(test1).toBe(6)
  })
})
describe('Testing Conversion of Reamur to Celsius', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToCelsius(100)
    expect(test1).toBe(125)
  })
})
describe('Testing Conversion of Reamur to Fahrenheit', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToFahrenheit(100)
    expect(test1).toBe(257)
  })
})
describe('Testing Conversion of Reamur to Kelvin', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToKelvin(100)
    expect(test1).toBe(398)
  })
})
describe('Testing Conversion of Reamur to Rankine', () => {
  it('with Reamur value', () => {
    const test1 = tc.reaumurToRankine(100)
    expect(test1).toBe(717)
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/TitleCaseConversion.test.js
import { titleCaseConversion } from '../TitleCaseConversion'

describe(('Tests for the titleCaseConversion function'), () => {
  it('should return an empty string when the input is an empty string', () => {
    expect(titleCaseConversion('')).toEqual('')
  })

  it('should return the input string when the input string is a title case string', () => {
    expect(titleCaseConversion('A Proper Title Case String')).toEqual('A Proper Title Case String')
  })

  it('should return a title case string when input is an all-uppercase string', () => {
    expect(titleCaseConversion('ALL UPPER CASE')).toEqual('All Upper Case')
  })

  it('should return a title case string when input is a title case string of with spaces', () => {
    expect(titleCaseConversion('ALL UPPERCASE')).toEqual('All Uppercase')
  })

  it('should return a title case string when input is a title case string of with no spaces', () => {
    expect(titleCaseConversion('ALLUPPERCASE')).toEqual('Alluppercase')
  })

  it('should return a title case string when input is a title case string with punctuation', () => {
    expect(titleCaseConversion('All Title Case!')).toEqual('All Title Case!')
  })

  it('should return a title case string when input is an all-lowercase string with no spaces', () => {
    expect(titleCaseConversion('lowercaseinput')).toEqual('Lowercaseinput')
  })

  it('should return a title case string when input is an all-lowercase string with spaces', () => {
    expect(titleCaseConversion('lowercase input')).toEqual('Lowercase Input')
  })

  it('should return a title case string when input is an all-lowercase string with punctuation', () => {
    expect(titleCaseConversion('lower, case, input.')).toEqual('Lower, Case, Input.')
  })

  it('should return a title case string when input is an mixed-case string', () => {
    expect(titleCaseConversion('mixeD CaSe INPuT')).toEqual('Mixed Case Input')
  })

  it('should return a title case string when input is an mixed-case string with no spaces', () => {
    expect(titleCaseConversion('mixeDCaSeINPuT')).toEqual('Mixedcaseinput')
  })

  it('should return a title case string when input is an mixed-case string with punctuation', () => {
    expect(titleCaseConversion('mixeD, CaSe, INPuT!')).toEqual('Mixed, Case, Input!')
  })
})

--#

--% C:/work/algos/Javascript/Conversions/test/UpperCaseConverstion.test.js
import { upperCaseConversion } from '../UpperCaseConversion'

describe(('Test the upperCaseConversion function'), () => {
  it('should return an empty string when the input is an empty string', () => {
    expect(upperCaseConversion('')).toEqual('')
  })

  it('should return an all-uppercase string when input is an all-uppercase string', () => {
    expect(upperCaseConversion('ALLUPPERCASE')).toEqual('ALLUPPERCASE')
  })

  it('should return an all-uppercase string when input is an all-uppercase string with spaces', () => {
    expect(upperCaseConversion('ALL UPPERCASE')).toEqual('ALL UPPERCASE')
  })

  it('should return an all-uppercase string when input is an all-uppercase string with punctuation', () => {
    expect(upperCaseConversion('ALL UPPER-CASE!')).toEqual('ALL UPPER-CASE!')
  })

  it('should return an all-uppercase string when input is an all-lowercase string', () => {
    expect(upperCaseConversion('lowercaseinput')).toEqual('LOWERCASEINPUT')
  })

  it('should return an all-uppercase string when input is an all-lowercase string with spaces', () => {
    expect(upperCaseConversion('lowercase input')).toEqual('LOWERCASE INPUT')
  })

  it('should return an all-uppercase string when input is an all-lowercase string with punctuation', () => {
    expect(upperCaseConversion('lower-case, input.')).toEqual('LOWER-CASE, INPUT.')
  })

  it('should return an all-uppercase string when input is an mixed-case string', () => {
    expect(upperCaseConversion('mixeDCaSeINPuT')).toEqual('MIXEDCASEINPUT')
  })

  it('should return an all-uppercase string when input is an mixed-case string with spaces', () => {
    expect(upperCaseConversion('mixeD CaSe INPuT')).toEqual('MIXED CASE INPUT')
  })

  it('should return an all-uppercase string when input is an mixed-case string with punctuation', () => {
    expect(upperCaseConversion('mixeD-CaSe INPuT!')).toEqual('MIXED-CASE INPUT!')
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Array/LocalMaximomPoint.js
/**
 * [LocalMaxima](https://www.geeksforgeeks.org/find-indices-of-all-local-maxima-and-local-minima-in-an-array/) is an algorithm to find relative bigger numbers compared to their neighbors
 *
 * Notes:
 * - works by using divide and conquer
 * - the function gets the array A with n Real numbersand returns the local max point index (if more than one exists return the first one)
 *
 * @complexity: O(log(n)) (on average )
 * @complexity: O(log(n)) (worst case)
 * @flow
 */
const findMaxPointIndex = (array, rangeStartIndex, rangeEndIndex, originalLength) => {
  // find index range middle point
  const middleIndex = rangeStartIndex + parseInt((rangeEndIndex - rangeStartIndex) / 2)

  // handle array bounds
  if ((middleIndex === 0 || array[middleIndex - 1] <= array[middleIndex]) &&
        (middleIndex === originalLength - 1 || array[middleIndex + 1] <= array[middleIndex])) {
    return middleIndex
  } else if (middleIndex > 0 && array[middleIndex - 1] > array[middleIndex]) {
    return findMaxPointIndex(array, rangeStartIndex, (middleIndex - 1), originalLength)
  } else {
    // regular local max
    return findMaxPointIndex(array, (middleIndex + 1), rangeEndIndex, originalLength)
  }
}

const LocalMaximomPoint = (A) => findMaxPointIndex(A, 0, A.length - 1, A.length)

export { LocalMaximomPoint }

--#

--% C:/work/algos/Javascript/Data-Structures/Array/NumberOfLocalMaximumPoints.js
/**
 * [NumberOfLocalMaximumPoints](https://www.geeksforgeeks.org/find-indices-of-all-local-maxima-and-local-minima-in-an-array/) is an algorithm to find relative bigger numbers compared to their neighbors
 *
 * Notes:
 * - like the other similar local maxima search function find relative maxima points in array but doesn't stop at one but returns total point count
 * - runs on array A of size n and returns the local maxima count using divide and conquer methodology
 *
 * @complexity: O(n) (on average )
 * @complexity: O(n) (worst case)
 * @flow
 */

// check if returned index is a local maxima
const IsMaximumPoint = (array, index) => {
  // handle array bounds
  // array start
  if (index === 0) {
    return array[index] > array[index + 1]
    // array end
  } else if (index === array.length - 1) {
    return array[index] > array[index - 1]
    // handle index inside array bounds
  } else {
    return array[index] > array[index + 1] && array[index] > array[index - 1]
  }
}

const CountLocalMaximumPoints = (array, startIndex, endIndex) => {
  // stop check in divide and conquer recursion
  if (startIndex === endIndex) {
    return IsMaximumPoint(array, startIndex) ? 1 : 0
  }

  // handle the two halves
  const middleIndex = parseInt((startIndex + endIndex) / 2)
  return CountLocalMaximumPoints(array, startIndex, middleIndex) +
    CountLocalMaximumPoints(array, middleIndex + 1, endIndex)
}

const NumberOfLocalMaximumPoints = (A) => CountLocalMaximumPoints(A, 0, A.length - 1)

export { NumberOfLocalMaximumPoints }

--#

--% C:/work/algos/Javascript/Data-Structures/Array/QuickSelect.js
/**
 * [QuickSelect](https://www.geeksforgeeks.org/quickselect-algorithm/) is an algorithm to find the kth smallest number
 *
 * Notes:
 * -QuickSelect is related to QuickSort, thus has optimal best and average
 * -case (O(n)) but unlikely poor worst case (O(n^2))
 * -This implementation uses randomly selected pivots for better performance
 *
 * @complexity: O(n) (on average )
 * @complexity: O(n^2) (worst case)
 * @flow
 */

function QuickSelect (items, kth) { // eslint-disable-line no-unused-vars
  if (kth < 1 || kth > items.length) {
    throw new RangeError('Index Out of Bound')
  }

  return RandomizedSelect(items, 0, items.length - 1, kth)
}

function RandomizedSelect (items, left, right, i) {
  if (left === right) return items[left]

  const pivotIndex = RandomizedPartition(items, left, right)
  const k = pivotIndex - left + 1

  if (i === k) return items[pivotIndex]
  if (i < k) return RandomizedSelect(items, left, pivotIndex - 1, i)

  return RandomizedSelect(items, pivotIndex + 1, right, i - k)
}

function RandomizedPartition (items, left, right) {
  const rand = getRandomInt(left, right)
  Swap(items, rand, right)
  return Partition(items, left, right)
}

function Partition (items, left, right) {
  const x = items[right]
  let pivotIndex = left - 1

  for (let j = left; j < right; j++) {
    if (items[j] <= x) {
      pivotIndex++
      Swap(items, pivotIndex, j)
    }
  }

  Swap(items, pivotIndex + 1, right)

  return pivotIndex + 1
}

function getRandomInt (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

function Swap (arr, x, y) {
  [arr[x], arr[y]] = [arr[y], arr[x]]
}

export { QuickSelect }

--#

--% C:/work/algos/Javascript/Data-Structures/Array/test/LocalMaximomPoint.test.js
import { LocalMaximomPoint } from '../LocalMaximomPoint'

describe('LocalMaximumPoint tests', () => {
  it('test boundary maximum points - last element', () => {
    const Array = [1, 2, 3, 4, 5, 6, 12]
    expect(LocalMaximomPoint(Array)).toEqual(6)
  })

  it('test boundary maximum points - first element', () => {
    const Array2 = [13, 6, 5, 4, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(0)
  })

  it('test boundary maximum points - should find first maximom point from the top', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [13, 2, 3, 4, 5, 6, 12]
    expect(LocalMaximomPoint(Array)).toEqual(6)
  })

  it('test inner points - second element', () => {
    const Array2 = [13, 16, 5, 4, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(1)
  })

  it('test inner points - element some where in the middle', () => {
    const Array2 = [13, 16, 5, 41, 3, 2, 1]
    expect(LocalMaximomPoint(Array2)).toEqual(3)
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Array/test/NumberOfLocalMaximumPoints.test.js
import { NumberOfLocalMaximumPoints } from '../NumberOfLocalMaximumPoints'

describe('LocalMaximomPoint tests', () => {
  it('test boundary maximum points - last element', () => {
    const Array = [1, 2, 3, 4, 5, 6, 12]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(1)
  })

  it('test boundary maximum points - first element', () => {
    const Array = [13, 6, 5, 4, 3, 2, 1]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(1)
  })

  it('test boundary maximum points - both boundaries have maximum points', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [13, 2, 3, 4, 5, 6, 12]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(2)
  })

  it('multiple maximum points in the middle', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [1, 3, 2, 5, 6, 9, 2, 7, 12, 1, 0]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(3)
  })

  it('multiple maximum points in the middle with one at end', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [1, 3, 2, 5, 6, 9, 2, 7, 12, 1, 10]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(4)
  })

  it('multiple maximum points in the middle with one at start', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [10, 3, 2, 5, 6, 9, 2, 7, 12, 1, 0]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(3)
  })

  it('multiple maximum points in the middle with two more at both ends', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    const Array = [10, 3, 11, 5, 6, 9, 2, 7, 12, 1, 10]
    expect(NumberOfLocalMaximumPoints(Array)).toEqual(5)
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Array/test/QuickSelect.test.js
import { QuickSelect } from '../QuickSelect'

describe('QuickSelect tests', () => {
  it('should return the only element of a list of length 1', () => {
    // Test a mix of number types (i.e., positive/negative, numbers with decimals, fractions)
    expect(QuickSelect([100], 1)).toEqual(100)
    expect(QuickSelect([-23], 1)).toEqual(-23)
    expect(QuickSelect([2007.102], 1)).toEqual(2007.102)
    expect(QuickSelect([0.9], 1)).toEqual(0.9)
    expect(QuickSelect([-0.075], 1)).toEqual(-0.075)
    expect(QuickSelect([0], 1)).toEqual(0)
    expect(QuickSelect([1], 1)).toEqual(1)
  })

  it('should throw an Error when k is greater than the length of the list', () => {
    expect(() => QuickSelect([100, 2], 5)).toThrow('Index Out of Bound')
  })

  it('should throw an Error when k is less than 1', () => {
    expect(() => QuickSelect([100, 2], 0)).toThrow('Index Out of Bound')
    expect(() => QuickSelect([100, 2], -1)).toThrow('Index Out of Bound')
  })

  describe('varieties of list composition', () => {
    it('should return the kth smallest element of a list that is in increasing order', () => {
      expect(QuickSelect([10, 22, 33, 44, 55], 1)).toEqual(10)
      expect(QuickSelect([10, 22, 33, 44, 55], 2)).toEqual(22)
      expect(QuickSelect([10, 22, 33, 44, 55], 3)).toEqual(33)
      expect(QuickSelect([10, 22, 33, 44, 55], 4)).toEqual(44)
      expect(QuickSelect([10, 22, 33, 44, 55], 5)).toEqual(55)
    })

    it('should return the kth smallest element of an input list that is in decreasing order', () => {
      expect(QuickSelect([82, 33.12, 4.0, 1], 1)).toEqual(1)
      expect(QuickSelect([82, 33.12, 4.0, 1], 2)).toEqual(4.0)
      expect(QuickSelect([82, 33.12, 4.0, 1], 2)).toEqual(4)
      expect(QuickSelect([82, 33.12, 4.0, 1], 3)).toEqual(33.12)
      expect(QuickSelect([82, 33.12, 4.0, 1], 4)).toEqual(82)
    })

    it('should return the kth smallest element of an input list that is no particular order', () => {
      expect(QuickSelect([123, 14231, -10, 0, 15], 3)).toEqual(15)
      expect(QuickSelect([0, 15, 123, 14231, -10], 3)).toEqual(15)
      expect(QuickSelect([-10, 15, 123, 14231, 0], 3)).toEqual(15)
      expect(QuickSelect([14231, 0, 15, 123, -10], 3)).toEqual(15)
      expect(QuickSelect([14231, 0, 15, -10, 123], 3)).toEqual(15)
    })
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Graph/Graph.js
class Graph {
  constructor () {
    this.adjacencyMap = {}
  }

  addVertex (vertex) {
    this.adjacencyMap[vertex] = []
  }

  containsVertex (vertex) {
    return typeof (this.adjacencyMap[vertex]) !== 'undefined'
  }

  addEdge (vertex1, vertex2) {
    if (this.containsVertex(vertex1) && this.containsVertex(vertex2)) {
      this.adjacencyMap[vertex1].push(vertex2)
      this.adjacencyMap[vertex2].push(vertex1)
    }
  }

  printGraph (output = value => console.log(value)) {
    const keys = Object.keys(this.adjacencyMap)
    for (const i of keys) {
      const values = this.adjacencyMap[i]
      let vertex = ''
      for (const j of values) {
        vertex += j + ' '
      }
      output(i + ' -> ' + vertex)
    }
  }

  /**
   * Prints the Breadth first traversal of the graph from source.
   * @param {number} source The source vertex to start BFS.
   */
  bfs (source, output = value => console.log(value)) {
    const queue = [[source, 0]] // level of source is 0
    const visited = new Set()

    while (queue.length) {
      const [node, level] = queue.shift() // remove the front of the queue
      if (visited.has(node)) { // visited
        continue
      }

      visited.add(node)
      output(`Visited node ${node} at level ${level}.`)
      for (const next of this.adjacencyMap[node]) {
        queue.push([next, level + 1]) // level 1 more than current
      }
    }
  }

  /**
   * Prints the Depth first traversal of the graph from source.
   * @param {number} source The source vertex to start DFS.
   */
  dfs (source, visited = new Set(), output = value => console.log(value)) {
    if (visited.has(source)) { // visited
      return
    }

    output(`Visited node ${source}`)
    visited.add(source)
    for (const neighbour of this.adjacencyMap[source]) {
      this.dfs(neighbour, visited, output)
    }
  }
}

const example = () => {
  const g = new Graph()
  g.addVertex(1)
  g.addVertex(2)
  g.addVertex(3)
  g.addVertex(4)
  g.addVertex(5)
  g.addEdge(1, 2)
  g.addEdge(1, 3)
  g.addEdge(2, 4)
  g.addEdge(2, 5)

  // Graph
  // 1 -> 2 3
  // 2 -> 1 4 5
  // 3 -> 1
  // 4 -> 2
  // 5 -> 2

  // Printing the adjacency list
  // g.printGraph()

  // Breadth first search at node 1
  g.bfs(1)

  // Depth first search at node 1
  g.dfs(1)
}

export { Graph, example }

--#

--% C:/work/algos/Javascript/Data-Structures/Graph/Graph2.js
// create a graph class
class Graph {
  // defining vertex array and
  // adjacent list
  constructor (noOfVertices) {
    this.noOfVertices = noOfVertices
    this.AdjList = new Map()
  }

  // functions to be implemented

  // addVertex(v)
  // addEdge(v, w)
  // printGraph()

  // bfs(v)
  // dfs(v)

  // add vertex to the graph
  addVertex (v) {
    // initialize the adjacent list with a
    // null array

    this.AdjList.set(v, [])
  }

  // add edge to the graph
  addEdge (v, w) {
    // get the list for vertex v and put the
    // vertex w denoting edge between v and w
    this.AdjList.get(v).push(w)

    // Since graph is undirected,
    // add an edge from w to v also
    this.AdjList.get(w).push(v)
  }

  // Prints the vertex and adjacency list
  printGraph (output = value => console.log(value)) {
    // get all the vertices
    const getKeys = this.AdjList.keys()

    // iterate over the vertices
    for (const i of getKeys) {
      // great the corresponding adjacency list
      // for the vertex
      const getValues = this.AdjList.get(i)
      let conc = ''

      // iterate over the adjacency list
      // concatenate the values into a string
      for (const j of getValues) {
        conc += j + ' '
      }

      // print the vertex and its adjacency list
      output(i + ' -> ' + conc)
    }
  }
}

export { Graph }

--#

--% C:/work/algos/Javascript/Data-Structures/Graph/test/Graph2.test.js
import { Graph } from '../Graph2'

describe('Test Graph2', () => {
  const vertices = ['A', 'B', 'C', 'D', 'E', 'F']
  const graph = new Graph(vertices.length)

  // adding vertices
  for (let i = 0; i < vertices.length; i++) {
    graph.addVertex(vertices[i])
  }

  // adding edges
  graph.addEdge('A', 'B')
  graph.addEdge('A', 'D')
  graph.addEdge('A', 'E')
  graph.addEdge('B', 'C')
  graph.addEdge('D', 'E')
  graph.addEdge('E', 'F')
  graph.addEdge('E', 'C')
  graph.addEdge('C', 'F')

  it('Check adjacency lists', () => {
    const mockFn = jest.fn()
    graph.printGraph(mockFn)

    // Expect one call per vertex
    expect(mockFn.mock.calls.length).toBe(vertices.length)

    // Collect adjacency lists from output (call args)
    const adjListArr = mockFn.mock.calls.map(v => v[0])

    expect(adjListArr).toEqual([
      'A -> B D E ',
      'B -> A C ',
      'C -> B E F ',
      'D -> A E ',
      'E -> A D F C ',
      'F -> E C '
    ])
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Heap/MaxHeap.js
/**
 * Author: Samarth Jain
 * Max Heap implementation in Javascript
 */

class BinaryHeap {
  constructor () {
    this.heap = []
  }

  insert (value) {
    this.heap.push(value)
    this.heapify()
  }

  size () {
    return this.heap.length
  }

  empty () {
    return this.size() === 0
  }

  // using iterative approach to reorder the heap after insertion
  heapify () {
    let index = this.size() - 1

    while (index > 0) {
      const element = this.heap[index]
      const parentIndex = Math.floor((index - 1) / 2)
      const parent = this.heap[parentIndex]

      if (parent[0] >= element[0]) break
      this.heap[index] = parent
      this.heap[parentIndex] = element
      index = parentIndex
    }
  }

  // Extracting the maximum element from the Heap
  extractMax () {
    const max = this.heap[0]
    const tmp = this.heap.pop()
    if (!this.empty()) {
      this.heap[0] = tmp
      this.sinkDown(0)
    }
    return max
  }

  // To restore the balance of the heap after extraction.
  sinkDown (index) {
    const left = 2 * index + 1
    const right = 2 * index + 2
    let largest = index
    const length = this.size()

    if (left < length && this.heap[left][0] > this.heap[largest][0]) {
      largest = left
    }
    if (right < length && this.heap[right][0] > this.heap[largest][0]) {
      largest = right
    }
    // swap
    if (largest !== index) {
      const tmp = this.heap[largest]
      this.heap[largest] = this.heap[index]
      this.heap[index] = tmp
      this.sinkDown(largest)
    }
  }
}

// Example

// const maxHeap = new BinaryHeap()
// maxHeap.insert([4])
// maxHeap.insert([3])
// maxHeap.insert([6])
// maxHeap.insert([1])
// maxHeap.insert([8])
// maxHeap.insert([2])
// const mx = maxHeap.extractMax()

export { BinaryHeap }

--#

--% C:/work/algos/Javascript/Data-Structures/Heap/MinHeap.js
/**
 *   Min Heap is one of the two Binary Heap types (the other is Max Heap)
 *   which maintains the smallest value of its input array on top and remaining values in loosely (but not perfectly sorted) order.
 *
 *   Min Heaps can be expressed as a 'complete' binary tree structure
 *   (in which all levels of the binary tree are filled, with the exception of the last level which must be filled left-to-right).
 *
 *   However the Min Heap class below expresses this tree structure as an array
 *   which represent the binary tree node values in an array ordered from root-to-leaf, left-to-right.
 *
 *   In the array representation, the parent node-child node relationship is such that the
 *      * parent index relative to its two children are: (parentIdx * 2) and (parent * 2 + 1)
 *      * and either child's index position relative to its parent is: Math.floor((childIdx-1)/2)
 *
 *   The parent and respective child values define much of heap behavior as we continue to sort or not sort depending on their values.
 *      * The parent value must be less than or equal to either child's value.
 *
 *   This is a condensed overview but for more information and visuals here is a nice read: https://www.geeksforgeeks.org/binary-heap/
 */

class MinHeap {
  constructor (array) {
    this.heap = this.initializeHeap(array)
  }

  /**
   *   startingParent represents the parent of the last index (=== array.length-1)
   *   and iterates towards 0 with all index values below sorted to meet heap conditions
  */
  initializeHeap (array) {
    const startingParent = Math.floor((array.length - 2) / 2)

    for (let currIdx = startingParent; currIdx >= 0; currIdx--) {
      this.sinkDown(currIdx, array.length - 1, array)
    }
    return array
  }

  /**
   *   overall functionality: heap-sort value at a starting index (currIdx) towards end of heap
   *
   *   currIdx is considered to be a starting 'parent' index of two children indices (childOneIdx, childTwoIdx).
   *   endIdx represents the last valid index in the heap.
   *
   *   first check that childOneIdx and childTwoIdx are both smaller than endIdx
   *   and check for the smaller heap value between them.
   *
   *   the child index with the smaller heap value is set to a variable called swapIdx.
   *
   *   swapIdx's value will be compared to currIdx (the 'parent' index)
   *   and if swapIdx's value is smaller than currIdx's value, swap the values in the heap,
   *   update currIdx and recalculate the new childOneIdx to check heap conditions again.
   *
   *   if there is no swap, it means the children indices and the parent index satisfy heap conditions and can exit the function.
  */
  sinkDown (currIdx, endIdx, heap) {
    let childOneIdx = currIdx * 2 + 1

    while (childOneIdx <= endIdx) {
      const childTwoIdx = childOneIdx + 1 <= endIdx ? childOneIdx + 1 : -1
      const swapIdx = childTwoIdx !== -1 && heap[childTwoIdx] < heap[childOneIdx]
        ? childTwoIdx
        : childOneIdx

      if (heap[swapIdx] < heap[currIdx]) {
        this.swap(currIdx, swapIdx, heap)
        currIdx = swapIdx
        childOneIdx = currIdx * 2 + 1
      } else {
        return
      }
    }
  }

  /**
   *   overall functionality: heap-sort value at a starting index (currIdx) towards front of heap.
   *
   *   while the currIdx's value is smaller than its parent's (parentIdx) value, swap the values in the heap
   *   update currIdx and recalculate the new parentIdx to check heap condition again.
   *
   *   iteration does not end while a valid currIdx has a value smaller than its parentIdx's value
  */
  bubbleUp (currIdx) {
    let parentIdx = Math.floor((currIdx - 1) / 2)

    while (currIdx > 0 && this.heap[currIdx] < this.heap[parentIdx]) {
      this.swap(currIdx, parentIdx, this.heap)
      currIdx = parentIdx
      parentIdx = Math.floor((currIdx - 1) / 2)
    }
  }

  peek () {
    return this.heap[0]
  }

  /**
   *   the min heap value should be the first value in the heap (=== this.heap[0])
   *
   *   firstIdx value and lastIdx value are swapped
   *   the resulting min heap value now resides at heap[heap.length-1] which is popped and later returned.
   *
   *   the remaining values in the heap are re-sorted
  */
  extractMin () {
    this.swap(0, this.heap.length - 1, this.heap)
    const min = this.heap.pop()
    this.sinkDown(0, this.heap.length - 1, this.heap)
    return min
  }

  // a new value is pushed to the end of the heap and sorted up
  insert (value) {
    this.heap.push(value)
    this.bubbleUp(this.heap.length - 1)
  }

  // index-swapping helper method
  swap (idx1, idx2, heap) {
    const temp = heap[idx1]
    heap[idx1] = heap[idx2]
    heap[idx2] = temp
  }
}

export { MinHeap }

--#

--% C:/work/algos/Javascript/Data-Structures/Heap/MinPriorityQueue.js

/* Minimum Priority Queue
* It is a part of heap data structure
* A heap is a specific tree based data structure
* in which all the nodes of tree are in a specific order.
* that is the children are arranged in some
* respect of their parents, can either be greater
* or less than the parent. This makes it a min priority queue
* or max priority queue.
*/

// Functions: insert, delete, peek, isEmpty, print, heapSort, sink

class MinPriorityQueue {
  // calls the constructor and initializes the capacity
  constructor (c) {
    this.heap = []
    this.capacity = c
    this.size = 0
  }

  // inserts the key at the end and rearranges it
  // so that the binary heap is in appropriate order
  insert (key) {
    if (this.isFull()) return
    this.heap[this.size + 1] = key
    let k = this.size + 1
    while (k > 1) {
      if (this.heap[k] < this.heap[Math.floor(k / 2)]) {
        const temp = this.heap[k]
        this.heap[k] = this.heap[Math.floor(k / 2)]
        this.heap[Math.floor(k / 2)] = temp
      }
      k = Math.floor(k / 2)
    }
    this.size++
  }

  // returns the highest priority value
  peek () {
    return this.heap[1]
  }

  // returns boolean value whether the heap is empty or not
  isEmpty () {
    return this.size === 0
  }

  // returns boolean value whether the heap is full or not
  isFull () {
    if (this.size === this.capacity) return true
    return false
  }

  // prints the heap
  print (output = value => console.log(value)) {
    output(this.heap.slice(1))
  }

  // heap reverse can be done by performing swapping the first
  // element with the last, removing the last element to
  // new array and calling sink function.
  heapReverse () {
    const heapSort = []
    while (this.size > 0) {
      // swap first element with last element
      [this.heap[1], this.heap[this.size]] = [this.heap[this.size], this.heap[1]]
      heapSort.push(this.heap.pop())
      this.size--
      this.sink()
    }
    // first value from heap it's empty to respect
    // structure with 1 as index of the first element
    this.heap = [undefined, ...heapSort.reverse()]
    this.size = heapSort.length
  }

  // this function reorders the heap after every delete function
  sink () {
    let k = 1
    while (2 * k <= this.size || 2 * k + 1 <= this.size) {
      let minIndex
      if (this.heap[2 * k] >= this.heap[k]) {
        if (2 * k + 1 <= this.size && this.heap[2 * k + 1] >= this.heap[k]) {
          break
        } else if (2 * k + 1 > this.size) {
          break
        }
      }
      if (2 * k + 1 > this.size) {
        minIndex = this.heap[2 * k] < this.heap[k] ? 2 * k : k
      } else {
        if (
          this.heap[k] > this.heap[2 * k] ||
          this.heap[k] > this.heap[2 * k + 1]
        ) {
          minIndex =
            this.heap[2 * k] < this.heap[2 * k + 1] ? 2 * k : 2 * k + 1
        } else {
          minIndex = k
        }
      }
      const temp = this.heap[k]
      this.heap[k] = this.heap[minIndex]
      this.heap[minIndex] = temp
      k = minIndex
    }
  }

  // deletes the highest priority value from the heap. The last
  // element goes to ahead to first position and reorder heap
  delete () {
    // checks empty and one element array conditions
    if (this.isEmpty()) return
    if (this.size === 1) {
      this.size--
      return this.heap.pop()
    }
    const min = this.heap[1]
    this.heap[1] = this.heap.pop()
    this.size--
    this.sink()
    return min
  }
}

export { MinPriorityQueue }

--#

--% C:/work/algos/Javascript/Data-Structures/Heap/test/MinHeap.test.js
import { MinHeap } from '../MinHeap'

describe('MinHeap', () => {
  const array = [2, 4, 10, 23, 43, 42, 39, 7, 9, 16, 85, 1, 51]
  let heap

  beforeEach(() => {
    heap = new MinHeap(array)
  })

  it('should initialize a heap from an input array', () => {
    expect(heap).toEqual({ 'heap': [1, 4, 2, 7, 16, 10, 39, 23, 9, 43, 85, 42, 51] })   // eslint-disable-line
  })

  it('should show the top value in the heap', () => {
    const minValue = heap.peek()

    expect(minValue).toEqual(1)
  })

  it('should remove and return the top value in the heap', () => {
    const minValue = heap.extractMin()

    expect(minValue).toEqual(1)
    expect(heap).toEqual({ 'heap': [2, 4, 10, 7, 16, 42, 39, 23, 9, 43, 85, 51] })      // eslint-disable-line
  })

  it('should insert a new value and sort until it meets heap conditions', () => {
    heap.insert(15)

    expect(heap).toEqual({ 'heap': [2, 4, 10, 7, 16, 15, 39, 23, 9, 43, 85, 51, 42] })  // eslint-disable-line
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Heap/test/MinPriorityQueue.test.js
import { MinPriorityQueue } from '../MinPriorityQueue'

describe('MinPriorityQueue', () => {
  const values = [5, 2, 4, 1, 7, 6, 3, 8]
  const capacity = values.length
  let queue

  beforeEach(() => {
    queue = new MinPriorityQueue(capacity)
    values.forEach(v => queue.insert(v))
  })

  it('Check heap ordering', () => {
    const mockFn = jest.fn()
    queue.print(mockFn)

    expect(mockFn.mock.calls.length).toBe(1) // Expect one call
    expect(mockFn.mock.calls[0].length).toBe(1) // Expect one argument

    const heap = mockFn.mock.calls[0][0]
    expect(heap.length).toBe(capacity)
    expect(heap).toStrictEqual([1, 2, 3, 5, 7, 6, 4, 8])
  })

  it('heapSort() expected to reverse the heap ordering', () => {
    queue.heapReverse()
    const mockFn = jest.fn()
    queue.print(mockFn)

    expect(mockFn.mock.calls.length).toBe(1)
    expect(mockFn.mock.calls[0].length).toBe(1)

    const heap = mockFn.mock.calls[0][0]
    expect(heap.length).toBe(capacity)
    expect(heap).toStrictEqual([8, 7, 6, 5, 4, 3, 2, 1])
  })

  describe('delete() function work properly', () => {
    it('return undefined if heap is empty', () => {
      const minqueue = new MinPriorityQueue(capacity)
      const min = minqueue.delete()
      expect(min).toBe(undefined)
    })
    it('return min value and remove it', () => {
      const sortedValues = values.sort()
      let initialSize = queue.size
      sortedValues.forEach((minValue, index) => {
        const min = queue.delete()
        expect(min).toBe(minValue)
        expect(queue.size).toBe(--initialSize)
      })
      expect(queue.size).toBe(0)
    })
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Linked-List/CycleDetection.js
/**
 * A LinkedList based solution for Detect a Cycle in a list
 * https://en.wikipedia.org/wiki/Cycle_detection
 */

function main () {
  /*
  Problem Statement:
  Given head, the head of a linked list, determine if the linked list has a cycle in it.

  Note:
  * While Solving the problem in given link below, don't use main() function.
  * Just use only the code inside main() function.
  * The purpose of using main() function here is to avoid global variables.

  Link for the Problem: https://leetcode.com/problems/linked-list-cycle/
  */
  const head = '' // Reference to head is given in the problem. So please ignore this line
  let fast = head
  let slow = head

  while (fast != null && fast.next != null && slow != null) {
    fast = fast.next.next
    slow = slow.next
    if (fast === slow) {
      return true
    }
  }
  return false
}

main()

--#

--% C:/work/algos/Javascript/Data-Structures/Linked-List/DoublyLinkedList.js
// Hamza chabchoub contribution for a university project
function DoubleLinkedList () {
  const Node = function (element) {
    this.element = element
    this.next = null
    this.prev = null
  }

  let length = 0
  let head = null
  let tail = null

  // Add new element
  this.append = function (element) {
    const node = new Node(element)

    if (!head) {
      head = node
      tail = node
    } else {
      node.prev = tail
      tail.next = node
      tail = node
    }

    length++
  }

  // Add element
  this.insert = function (position, element) {
    // Check of out-of-bound values
    if (position >= 0 && position <= length) {
      const node = new Node(element)
      let current = head
      let previous = 0
      let index = 0

      if (position === 0) {
        if (!head) {
          head = node
          tail = node
        } else {
          node.next = current
          current.prev = node
          head = node
        }
      } else if (position === length) {
        current = tail
        current.next = node
        node.prev = current
        tail = node
      } else {
        while (index++ < position) {
          previous = current
          current = current.next
        }

        node.next = current
        previous.next = node

        // New
        current.prev = node
        node.prev = previous
      }

      length++
      return true
    } else {
      return false
    }
  }

  // Remove element at any position
  this.removeAt = function (position) {
    // look for out-of-bounds value
    if (position > -1 && position < length) {
      let current = head
      let previous = 0
      let index = 0

      // Removing first item
      if (position === 0) {
        head = current.next

        // if there is only one item, update tail //NEW
        if (length === 1) {
          tail = null
        } else {
          head.prev = null
        }
      } else if (position === length - 1) {
        current = tail
        tail = current.prev
        tail.next = null
      } else {
        while (index++ < position) {
          previous = current
          current = current.next
        }

        // link previous with current's next - skip it
        previous.next = current.next
        current.next.prev = previous
      }

      length--
      return current.element
    } else {
      return null
    }
  }

  // Get the indexOf item
  this.indexOf = function (elm) {
    let current = head
    let index = -1

    // If element found then return its position
    while (current) {
      if (elm === current.element) {
        return ++index
      }

      index++
      current = current.next
    }

    // Else return -1
    return -1
  }

  // Find the item in the list
  this.isPresent = (elm) => {
    return this.indexOf(elm) !== -1
  }

  // Delete an item from the list
  this.delete = (elm) => {
    return this.removeAt(this.indexOf(elm))
  }

  // Delete first item from the list
  this.deleteHead = function () {
    this.removeAt(0)
  }

  // Delete last item from the list
  this.deleteTail = function () {
    this.removeAt(length - 1)
  }

  // Print item of the string
  this.toString = function () {
    let current = head
    let string = ''

    while (current) {
      string += current.element + (current.next ? '\n' : '')
      current = current.next
    }

    return string
  }

  // Convert list to array
  this.toArray = function () {
    const arr = []
    let current = head

    while (current) {
      arr.push(current.element)
      current = current.next
    }

    return arr
  }

  // Check if list is empty
  this.isEmpty = function () {
    return length === 0
  }

  // Get the size of the list
  this.size = function () {
    return length
  }

  // Get the head
  this.getHead = function () {
    return head
  }

  // Get the tail
  this.getTail = function () {
    return tail
  }
}

// Example

// const newDoubleLinkedList = new DoubleLinkedList()
// newDoubleLinkedList.append(1)
// newDoubleLinkedList.append(2)
// newDoubleLinkedList.size() // returns 2

export { DoubleLinkedList }

--#

--% C:/work/algos/Javascript/Data-Structures/Linked-List/RotateListRight.js
/**
 * A LinkedList based solution for Rotating a List to the right by k places
 */

function main () {
  /*
  Problem Statement:
  Given a linked list, rotate the list to the right by k places, where k is non-negative.

  Note:
  * While Solving the problem in given link below, don't use main() function.
  * Just use only the code inside main() function.
  * The purpose of using main() function here is to avoid global variables.

  Link for the Problem: https://leetcode.com/problems/rotate-list/
  */
  // Reference to both head and k is given in the problem. So please ignore below two lines
  let head = ''
  let k = ''
  let i = 0
  let current = head
  while (current) {
    i++
    current = current.next
  }
  k %= i
  current = head
  let prev = null
  while (k--) {
    if (!current || !current.next) {
      return current
    } else {
      while (current.next) {
        prev = current
        current = current.next
      }
      prev.next = current.next
      current.next = head
      head = current
    }
  }
  return head
}

main()

--#

--% C:/work/algos/Javascript/Data-Structures/Linked-List/SingleCircularLinkedList.js.js
class Node {
  constructor (data, next = null) {
    this.data = data
    this.next = next
  }
}

class SinglyCircularLinkedList {
  constructor () {
    this.head = null
    this.size = 0
  }

  insert (data) {
    const node = new Node(data)

    if (!this.head) {
      node.next = node
      this.head = node
      this.size++
    } else {
      node.next = this.head

      let current = this.head

      while (current.next.data !== this.head.data) {
        current = current.next
      }

      current.next = node
      this.size++
    }
  }

  insertAt (index, data) {
    const node = new Node(data)

    if (index < 0 || index > this.size) return

    if (index === 0) {
      this.head = node
      this.size = 1
      return
    }

    let previous
    let count = 0
    let current = this.head

    while (count < index) {
      previous = current
      current = current.next
      count++
    }

    node.next = current
    previous.next = node
    this.size++
  }

  remove () {
    if (!this.head) return

    let prev
    let current = this.head

    while (current.next !== this.head) {
      prev = current
      current = current.next
    }

    prev.next = this.head
    this.size--
  }

  printData (output = value => console.log(value)) {
    let count = 0
    let current = this.head

    while (current !== null && count < this.size) {
      output(current.data)
      current = current.next
      count++
    }
  }
}

export { SinglyCircularLinkedList }

--#

--% C:/work/algos/Javascript/Data-Structures/Linked-List/SinglyLinkedList.js
/* SinglyLinkedList!!
* A linked list is similar to an array, it holds a list of values.
* However, links in a linked list do not have indexes. With
* a linked list you do not need to predetermine its size as
* it grows and shrinks as it is edited. This is an example of
* a singly linked list.
*/

// Methods - size, head, addLast, addFirst, addAt, removeFirst, removeLast, remove, removeAt, indexOf, isEmpty,  elementAt, get

class Node {
  constructor (data) {
    this.data = data
    this.next = null
  }
}

class LinkedList {
  constructor () {
    this.headNode = null
    this.length = 0
  }

  // Returns length
  size () {
    return this.length
  }

  // Returns the head
  head () {
    return this.headNode ? this.headNode.data : null
  }

  // add a node at last it to linklist
  addLast (element) {
    const node = new Node(element)

    // Check if its the first element
    if (this.headNode === null) {
      this.headNode = node
    } else {
      let currentNode = this.headNode

      // Loop till there is a node present in the list
      while (currentNode.next) {
        currentNode = currentNode.next
      }

      // Adding node at the end of the list
      currentNode.next = node
    }

    this.length++ // Increment the length
  }

  // add a node at first it to linklist
  addFirst (element) {
    const node = new Node(element)
    node.next = this.headNode
    this.headNode = node
    this.length++ // Increment the length
  }

  // remove the first from the linklist
  removeFirst () {
    if (this.length > 0) {
      this.headNode = this.headNode.next
      this.length--
    }
  }

  // remove the last from the linklist
  removeLast () {
    if (this.length === 1) {
      this.headNode = null
      this.length--
    } else if (this.length > 1) {
      let index = 0
      let currentNode = this.headNode
      while (index !== this.length - 2) {
        index++
        currentNode = currentNode.next
      }

      currentNode.next = null
      this.length--
    }
  }

  // Removes the node with the value as param
  remove (element) {
    let currentNode = this.headNode

    // Check if the head node is the element to remove
    if (currentNode.data === element) {
      this.headNode = currentNode.next
    } else {
      // Check which node is the node to remove
      while (currentNode && currentNode.next) {
        if (currentNode.next.data === element) {
          currentNode.next = currentNode.next.next
          break
        }
        currentNode = currentNode.next
      }
    }

    this.length-- // Decrementing the length
  }

  // Return if the list is empty
  isEmpty () {
    return this.length === 0
  }

  // Returns the index of the element passed as param otherwise -1
  indexOf (element) {
    let currentNode = this.headNode
    let index = 0

    while (currentNode) {
      // Checking if the node is the element we are searching for
      if (currentNode.data === element) {
        return index
      }
      currentNode = currentNode.next
      index++
    }

    return -1
  }

  // Returns the element at an index
  elementAt (index) {
    if (index >= this.length || index < 0) {
      throw new RangeError('Out of Range index')
    }
    let currentNode = this.headNode
    let count = 0
    while (count < index) {
      count++
      currentNode = currentNode.next
    }
    return currentNode.data
  }

  // Adds the element at specified index
  addAt (index, element) {
    const node = new Node(element)

    // Check if index is out of bounds of list
    if (index > this.length || index < 0) {
      throw new RangeError('Out of Range index')
    }

    let currentNode = this.headNode
    let currentIndex = 0
    // Check if index is the start of list
    if (index === 0) {
      node.next = currentNode
      this.headNode = node
    } else {
      while (currentIndex !== index - 1) {
        currentIndex++
        currentNode = currentNode.next
      }

      // Adding the node at specified index
      const temp = currentNode.next
      currentNode.next = node
      node.next = temp
    }

    // Incrementing the length
    this.length++
  }

  // Removes the node at specified index
  removeAt (index) {
    let currentNode = this.headNode
    let currentIndex = 0

    // Check if index is present in list
    if (index < 0 || index >= this.length) {
      throw new RangeError('Out of Range index')
    }

    // Check if element is the first element
    if (index === 0) {
      this.headNode = currentNode.next
    } else {
      while (currentIndex !== index - 1) {
        currentIndex++
        currentNode = currentNode.next
      }
      currentNode.next = currentNode.next.next
    }

    // Decrementing the length
    this.length--
  }

  // Method to get the LinkedList
  get () {
    const list = []
    let currentNode = this.headNode
    while (currentNode) {
      list.push(currentNode.data)
      currentNode = currentNode.next
    }

    return list
  }
}

export { LinkedList }

--#

--% C:/work/algos/Javascript/Data-Structures/Linked-List/test/SinglyLinkedList.test.js
import { LinkedList } from '../SinglyLinkedList'

describe('SinglyLinkedList', () => {
  it('Check addLast', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    list.addLast(1)
    expect(list.get()).toEqual([1])

    list.addLast(2)
    expect(list.get()).toEqual([1, 2])
  })

  it('Check addFirst', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    list.addFirst(1)
    expect(list.get()).toEqual([1])

    list.addFirst(2)
    expect(list.get()).toEqual([2, 1])
  })

  it('Check addAt', () => {
    const list = new LinkedList()
    expect(list.get()).toEqual([])

    list.addAt(0, 10)
    expect(list.get()).toEqual([10])

    list.addAt(1, 20)
    expect(list.get()).toEqual([10, 20])

    list.addAt(1, 30)
    expect(list.get()).toEqual([10, 30, 20])

    list.addAt(3, 40)
    expect(list.get()).toEqual([10, 30, 20, 40])
  })

  it('Check removeLast', () => {
    const list = new LinkedList()
    list.addLast(1)
    list.addLast(2)
    expect(list.get()).toEqual([1, 2])

    list.removeLast()
    expect(list.get()).toEqual([1])

    list.removeLast()
    expect(list.get()).toEqual([])
  })

  it('Check removeFirst', () => {
    const list = new LinkedList()
    list.addLast(1)
    list.addLast(2)
    expect(list.get()).toEqual([1, 2])

    list.removeFirst()
    expect(list.get()).toEqual([2])

    list.removeFirst()
    expect(list.get()).toEqual([])
  })

  it('Check removeAt', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.get()).toEqual([10, 20, 30, 40, 50])

    list.removeAt(0)
    expect(list.get()).toEqual([20, 30, 40, 50])

    list.removeAt(3)
    expect(list.get()).toEqual([20, 30, 40])

    list.removeAt(1)
    expect(list.get()).toEqual([20, 40])
  })

  it('Check remove', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    expect(list.get()).toEqual([10, 20, 30])

    list.remove(20)
    expect(list.get()).toEqual([10, 30])

    list.remove(30)
    expect(list.get()).toEqual([10])
  })

  it('Check indexOf', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.indexOf(10)).toBe(0)
    expect(list.indexOf(30)).toBe(2)
    expect(list.indexOf(50)).toBe(4)
    expect(list.indexOf(70)).toBe(-1)
  })

  it('Check elementAt', () => {
    const list = new LinkedList()
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.elementAt(0)).toBe(10)
    expect(list.elementAt(1)).toBe(20)
    expect(list.elementAt(3)).toBe(40)
    expect(list.elementAt(4)).toBe(50)
  })

  it('Check isEmpty', () => {
    const list = new LinkedList()
    expect(list.isEmpty()).toBe(true)
    list.addLast(10)
    list.addLast(20)
    list.addLast(30)
    list.addLast(40)
    list.addLast(50)
    expect(list.isEmpty()).toBe(false)
  })

  it('Check head', () => {
    const list = new LinkedList()
    expect(list.head()).toBe(null)

    list.addLast(10)
    expect(list.head()).toBe(10)

    list.addLast(20)
    expect(list.head()).toBe(10)

    list.addFirst(30)
    expect(list.head()).toBe(30)
  })

  it('Check size', () => {
    const list = new LinkedList()
    expect(list.size()).toBe(0)

    list.addLast(10)
    expect(list.size()).toBe(1)

    list.addLast(20)
    expect(list.size()).toBe(2)

    list.removeFirst()
    expect(list.size()).toBe(1)
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Queue/CircularQueue.js
// Circular Queues offer a quick to store FIFO data with a maximum size.
// Conserves memory as we only store up to our capacity
// It is opposed to a queue which could continue to grow if input outpaces output
// Doesnt use dynamic memory so No memory leaks

class CircularQueue {
  constructor (maxLength) {
    this.queue = []
    this.front = 0
    this.rear = 0
    this.maxLength = maxLength
  }

  // ADD ELEMENTS TO QUEUE
  enqueue (value) {
    if (this.checkOverflow()) return
    if (this.checkEmpty()) {
      this.front += 1
      this.rear += 1
    } else {
      if (this.rear === this.maxLength) {
        this.rear = 1
      } else this.rear += 1
    }
    this.queue[this.rear] = value
  }

  // REMOVES ELEMENTS
  dequeue () {
    if (this.checkEmpty()) {
      // UNDERFLOW
      return
    }
    const y = this.queue[this.front]
    this.queue[this.front] = '*'
    if (!this.checkSingleelement()) {
      if (this.front === this.maxLength) this.front = 1
      else {
        this.front += 1
      }
    }

    return y // Returns the removed element and replaces it with a star
  }

  // checks if the queue is empty or not
  checkEmpty () {
    if (this.front === 0 && this.rear === 0) {
      return true
    }
  }

  checkSingleelement () {
    if (this.front === this.rear && this.rear !== 0) {
      this.front = this.rear = 0
      return true
    }
  }

  // Checks if max capacity of queue has been reached or not
  checkOverflow () {
    if ((this.front === 1 && this.rear === this.maxLength) || (this.front === this.rear + 1)) {
      // CIRCULAR QUEUE OVERFLOW
      return true
    }
  }

  // Prints the entire array ('*' represents blank space)
  display (output = value => console.log(value)) {
    for (let index = 1; index < this.queue.length; index++) {
      output(this.queue[index])
    }
  }

  // Displays the length of queue
  length () {
    return this.queue.length - 1
  }

  // Display the top most value of queue
  peek () {
    return this.queue[this.front]
  }
}

export { CircularQueue }

--#

--% C:/work/algos/Javascript/Data-Structures/Queue/Queue.js
/* Queue
* A Queue is a data structure that allows you to add an element to the end of
* a list and remove the item at the front. A queue follows a "First In First Out"
* system, where the first item to enter the queue is the first to be removed. This
* implementation uses an array to store the queue.
*/

// Functions: enqueue, dequeue, peek, view, length, empty
class Queue {
  // constructor
  constructor () {
    // This is the array representation of the queue
    this.queue = []
  }

  // methods
  // Add a value to the end of the queue
  enqueue (item) {
    this.queue.push(item)
  }

  // Removes the value at the front of the queue
  dequeue () {
    if (this.empty()) {
      throw new Error('Queue is Empty')
    }

    return this.queue.shift() // remove the item at position 0 from the array and return it
  }

  // Return the length of the queue
  length () {
    return this.queue.length
  }

  // Return the item at the front of the queue
  peek () {
    if (this.empty()) {
      throw new Error('Queue is Empty')
    }

    return this.queue[0]
  }

  // List all the items in the queue
  view (output = value => console.log(value)) {
    output(this.queue)
  }

  // Return Is queue empty ?
  empty () {
    return this.queue.length === 0
  }
}

export { Queue }

--#

--% C:/work/algos/Javascript/Data-Structures/Queue/QueueUsing2Stacks.js
// implementation of Queue using 2 stacks
// contribution made by hamza chabchoub for a university project

class Queue {
  constructor () {
    this.inputStack = []
    this.outputStack = []
  }

  // Push item into the inputstack
  enqueue (item) {
    this.inputStack.push(item)
  }

  dequeue () {
    // push all items to outputstack
    this.outputStack = []
    while (this.inputStack.length > 0) {
      this.outputStack.push(this.inputStack.pop())
    }
    // return the top element of the outputstack if any
    if (this.outputStack.length > 0) {
      const top = this.outputStack.pop()
      // repush all the items to the inputstack
      this.inputStack = []
      while (this.outputStack.length > 0) {
        this.inputStack.push(this.outputStack.pop())
      }
      return top
    }
  }

  // display elements of the inputstack
  listIn (output = value => console.log(value)) {
    let i = 0
    while (i < this.inputStack.length) {
      output(this.inputStack[i])
      i++
    }
  }

  // display element of the outputstack
  listOut (output = value => console.log(value)) {
    let i = 0
    while (i < this.outputStack.length) {
      output(this.outputStack[i])
      i++
    }
  }
}

export { Queue }

--#

--% C:/work/algos/Javascript/Data-Structures/Queue/test/Queue.test.js
import { Queue } from '../Queue'

describe('Queue', () => {
  it('Check enqueue/dequeue', () => {
    const queue = new Queue()
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.dequeue()).toBe(1)
    expect(queue.dequeue()).toBe(2)
  })

  it('Check length', () => {
    const queue = new Queue()

    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.length()).toBe(4)
  })

  it('Check peek', () => {
    const queue = new Queue()

    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.peek()).toBe(1)
  })

  it('Check empty', () => {
    const queue = new Queue()
    expect(queue.empty()).toBeTruthy()

    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.empty()).toBeFalsy()
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Queue/test/QueueUsing2Stacks.test.js
import { Queue } from '../QueueUsing2Stacks'

describe('QueueUsing2Stacks', () => {
  const queue = new Queue()

  it('Check enqueue/dequeue', () => {
    queue.enqueue(1)
    queue.enqueue(2)
    queue.enqueue(8)
    queue.enqueue(9)

    expect(queue.dequeue()).toBe(1)
    expect(queue.dequeue()).toBe(2)
  })
})

--#

--% C:/work/algos/Javascript/Data-Structures/Stack/Stack.js
/* Stack!!
* A stack is exactly what it sounds like. An element gets added to the top of
* the stack and only the element on the top may be removed. This is an example
* of an array implementation of a Stack. So an element can only be added/removed
* from the end of the array.
*/

// Functions: push, pop, peek, view, length

// Creates a stack constructor
const Stack = (function () {
  function Stack () {
    // The top of the Stack
    this.top = 0
    // The array representation of the stack
    this.stack = []
  }

  // Adds a value onto the end of the stack
  Stack.prototype.push = function (value) {
    this.stack[this.top] = value
    this.top++
  }

  // Removes and returns the value at the end of the stack
  Stack.prototype.pop = function () {
    if (this.top === 0) {
      return 'Stack is Empty'
    }

    this.top--
    const result = this.stack[this.top]
    this.stack = this.stack.splice(0, this.top)
    return result
  }

  // Returns the size of the stack
  Stack.prototype.size = function () {
    return this.top
  }

  // Returns the value at the end of the stack
  Stack.prototype.peek = function () {
    return this.stack[this.top - 1]
  }

  // To see all the elements in the stack
  Stack.prototype.view = function (output = value => console.log(value)) {
    for (let i = 0; i < this.top; i++) {
      output(this.stack[i])
    }
  }

  return Stack
}())

export { Stack }

--#

--% C:/work/algos/Javascript/Data-Structures/Stack/StackES6.js
/* Stack data-structure. It's work is based on the LIFO method (last-IN-first-OUT).
 * It means that elements added to the stack are placed on the top and only the
 * last element (from the top) can be reached. After we get access to the last
 * element, he pops from the stack.
 * This is a class-based implementation of a Stack. It provides functions
 * 'push' - to add an element, 'pop' - to remove an element from the top.
 * Also it implements 'length', 'last' and 'isEmpty' properties and
 * static isStack method to check is an object the instance of Stack class.
 */

// Class declaration
class Stack {
  constructor () {
    this.stack = []
    this.top = 0
  }

  // Adds a value to the end of the Stack
  push (newValue) {
    this.stack.push(newValue)
    this.top += 1
  }

  // Returns and removes the last element of the Stack
  pop () {
    if (this.top !== 0) {
      this.top -= 1
      return this.stack.pop()
    }
    throw new Error('Stack Underflow')
  }

  // Returns the number of elements in the Stack
  get length () {
    return this.top
  }

  // Returns true if stack is empty, false otherwise
  get isEmpty () {
    return this.top === 0
  }

  // Returns the last element without removing it
  get last () {
    if (this.top !== 0) {
      return this.stack[this.stack.length - 1]
    }
    return null
  }

  // Checks if an object is the instance os the Stack class
  static isStack (el) {
    return el instanceof Stack
  }
}

export { Stack }

--#

--% C:/work/algos/Javascript/Data-Structures/Tree/AVLTree.js
/**
 * Adelson-Velsky and Landis Tree
 * [Wikipedia](https://en.wikipedia.org/wiki/AVL_tree)
 * [A video lecture](http://www.youtube.com/watch?v=TbvhGcf6UJU)
 */
'use strict'

/**
 * A utility class for comparator
 * A comparator is expected to have following structure
 *
 * comp(a, b) RETURN < 0 if a < b
 * RETURN > 0 if a > b
 * MUST RETURN 0 if a == b
 */
let utils;
(function (_utils) {
  function comparator () {
    return function (v1, v2) {
      if (v1 < v2) {
        return -1
      } else if (v2 < v1) {
        return 1
      } else {
        return 0
      }
    }
  }
  _utils.comparator = comparator
})(utils || (utils = {}))

/**
 * @constructor
 * A class for AVL Tree
 * @argument comp - A function used by AVL Tree For Comparison
 * If no argument is sent it uses utils.comparator
 */
const AVLTree = (function () {
  function _avl (comp) {
    /** @public comparator function */
    this._comp = undefined
    if (comp !== undefined) {
      this._comp = comp
    } else {
      this._comp = utils.comparator()
    }
    /** @public root of the AVL Tree */
    this.root = null
    /** @public number of elements in AVL Tree */
    this.size = 0
  }
  // creates new Node Object
  const Node = function (val) {
    this._val = val
    this._left = null
    this._right = null
    this._height = 1
  }
  // get height of a node
  const getH = function (node) {
    if (node == null) { return 0 }
    return node._height
  }
  // height difference or balance factor of a node
  const getHDiff = function (node) {
    if (node == null) { return 0 } else { return getH(node._left) - getH(node._right) }
  }
  // update height of a node based on children's heights
  const updateH = function (node) {
    if (node == null) {
      return
    }
    node._height = Math.max(getH(node._left), getH(node._right)) + 1
  }
  // rotations of AVL Tree
  const leftRotate = function (node) {
    const temp = node._right
    node._right = temp._left
    temp._left = node
    updateH(node)
    updateH(temp)
    return temp
  }
  const rightRotate = function (node) {
    const temp = node._left
    node._left = temp._right
    temp._right = node
    updateH(node)
    updateH(temp)
    return temp
  }
  // check if tree is balanced else balance it for insertion
  const insertBalance = function (node, _val, balanceFactor) {
    if (balanceFactor > 1 && _val < node._left._val) {
      return rightRotate(node) // Left Left Case
    } else if (balanceFactor < 1 && _val > node._right._val) {
      return leftRotate(node) // Right Right Case
    } else if (balanceFactor > 1 && _val > node._left._val) {
      node._left = leftRotate(node._left) // Left Right Case
      return rightRotate(node)
    }
    node._right = rightRotate(node._right)
    return leftRotate(node)
  }
  // check if tree is balanced after deletion
  const delBalance = function (node) {
    const balanceFactor1 = getHDiff(node)
    if (balanceFactor1 === 0 || balanceFactor1 === 1 || balanceFactor1 === -1) {
      return node
    }
    if (balanceFactor1 > 1) {
      if (getHDiff(node._left) >= 0) {
        return rightRotate(node) // Left Left
      }
      node._left = leftRotate(node._left)
      return rightRotate(node) // Left Right
    }
    if (getHDiff(node._right) > 0) {
      node._right = rightRotate(node._right)
      return leftRotate(node) // Right Left
    }
    return leftRotate(node) // Right Right
  }
  // implement avl tree insertion
  const insert = function (root, val, tree) {
    if (root == null) {
      tree.size++
      return new Node(val)
    } else if (tree._comp(root._val, val) < 0) {
      root._right = insert(root._right, val, tree)
    } else if (tree._comp(root._val, val) > 0) {
      root._left = insert(root._left, val, tree)
    } else {
      return root
    }
    updateH(root)
    const balanceFactor = getHDiff(root)
    if (balanceFactor === 0 || balanceFactor === 1 || balanceFactor === -1) {
      return root
    }
    return insertBalance(root, val, balanceFactor)
  }
  // delete a element
  const del = function (root, _val, tree) {
    if (root == null) {
      return root
    } else if (tree._comp(root._val, _val) === 0) { // key found case
      if (root._left === null && root._right === null) {
        root = null
        tree.size--
      } else if (root._left === null) {
        root = root._right
        tree.size--
      } else if (root._right === null) {
        root = root._left
        tree.size--
      } else {
        let temp = root._right
        while (temp._left != null) {
          temp = temp._left
        }
        root._val = temp._val
        root._right = del(root._right, temp._val, tree)
      }
    } else {
      if (tree._comp(root._val, _val) < 0) {
        root._right = del(root._right, _val, tree)
      } else {
        root._left = del(root._left, _val, tree)
      }
    }
    updateH(root)
    root = delBalance(root)
    return root
  }
  // search tree for a element
  const search = function (root, val, tree) {
    if (root == null) {
      return null
    } else if (tree._comp(root._val, val) === 0) {
      return root
    } else if (tree._comp(root._val, val) < 0) {
      return search(root._right, val, tree)
    }
    return search(root._left, val, tree)
  }

  /* Public Functions */
  /**
   * For Adding Elements to AVL Tree
   * @param {any} _val
   * Since in AVL Tree an element can only occur once so
   * if a element exists it return false
   * @returns {Boolean} element added or not
   */
  _avl.prototype.add = function (_val) {
    const prevSize = this.size
    this.root = insert(this.root, _val, this)
    if (this.size === prevSize) {
      return false
    }
    return true
  }
  /**
   * TO check is a particular element exists or not
   * @param {any} _val
   * @returns {Boolean} exists or not
   */
  _avl.prototype.find = function (_val) {
    const temp = search(this.root, _val, this)
    if (temp != null) {
      return true
    }
    return false
  }
  /**
   *
   * @param {any} _val
   * It is possible that element doesn't exists in tree
   * in that case it return false
   * @returns {Boolean} if element was found and deleted
   */
  _avl.prototype.remove = function (_val) {
    const prevSize = this.size
    this.root = del(this.root, _val, this)
    if (prevSize === this.size) {
      return false
    }
    return true
  }
  return _avl
}())

/**
 * A Code for Testing the AVLTree
 */
// (function test () {
//   const newAVL = new AVLTree()
//   const size = Math.floor(Math.random() * 1000000)
//   let uniques = 0
//   let i, temp, j
//   const array = []
//   for (i = 0; i < size; i++) {
//     temp = Math.floor(Math.random() * Number.MAX_VALUE)
//     if (newAVL.add(temp)) {
//       uniques++
//       array.push(temp)
//     }
//   }
//   if (newAVL.size !== uniques) {
//     throw new Error('elements not inserted properly')
//   }
//   const findTestSize = Math.floor(Math.random() * uniques)
//   for (i = 0; i < findTestSize; i++) {
//     j = Math.floor(Math.random() * uniques)
//     if (!newAVL.find(array[j])) {
//       throw new Error('inserted elements not found')
//     }
//   }
//   const deleteTestSize = Math.floor(uniques * Math.random())
//   for (i = 0; i < deleteTestSize; i++) {
//     j = Math.floor(Math.random() * uniques)
//     temp = array[j]
//     if (newAVL.find(temp)) {
//       if (!newAVL.remove(temp)) {
//         throw new Error('delete not working properly')
//       }
//     }
//   }
// })()

export { AVLTree }

--#

--% C:/work/algos/Javascript/Data-Structures/Tree/BinarySearchTree.js
/* Binary Search Tree!!
*
* Nodes that will go on the Binary Tree.
* They consist of the data in them, the node to the left, the node
* to the right, and the parent from which they came from.
*
* A binary tree is a data structure in which an element
* has two successors(children). The left child is usually
* smaller than the parent, and the right child is usually
* bigger.
*/

// class Node
const Node = (function Node () {
  // Node in the tree
  function Node (val) {
    this.value = val
    this.left = null
    this.right = null
  }

  // Search the tree for a value
  Node.prototype.search = function (val) {
    if (this.value === val) {
      return this
    } else if (val < this.value && this.left !== null) {
      return this.left.search(val)
    } else if (val > this.value && this.right !== null) {
      return this.right.search(val)
    }
    return null
  }

  // Visit a node
  Node.prototype.visit = function (output = value => console.log(value)) {
    // Recursively go left
    if (this.left !== null) {
      this.left.visit()
    }
    // Print out value
    output(this.value)
    // Recursively go right
    if (this.right !== null) {
      this.right.visit()
    }
  }

  // Add a node
  Node.prototype.addNode = function (n) {
    if (n.value < this.value) {
      if (this.left === null) {
        this.left = n
      } else {
        this.left.addNode(n)
      }
    } else if (n.value > this.value) {
      if (this.right === null) {
        this.right = n
      } else {
        this.right.addNode(n)
      }
    }
  }

  // remove a node
  Node.prototype.removeNode = function (val) {
    if (val === this.value) {
      if (!this.left && !this.right) {
        return null
      } else {
        if (this.left) {
          const leftMax = maxVal(this.left)
          this.value = leftMax
          this.left = this.left.removeNode(leftMax)
        } else {
          const rightMin = minVal(this.right)
          this.value = rightMin
          this.right = this.right.removeNode(rightMin)
        }
      }
    } else if (val < this.value) {
      this.left = this.left && this.left.removeNode(val)
    } else if (val > this.value) {
      this.right = this.right && this.right.removeNode(val)
    }
    return this
  }

  // find maximum value in the tree
  const maxVal = function (node) {
    if (!node.right) {
      return node.value
    }
    return maxVal(node.right)
  }

  // find minimum value in the tree
  const minVal = function (node) {
    if (!node.left) {
      return node.value
    }
    return minVal(node.left)
  }
  // returns the constructor
  return Node
}())

// class Tree
const Tree = (function () {
  function Tree () {
    // Just store the root
    this.root = null
  };

  // Inorder traversal
  Tree.prototype.traverse = function () {
    if (!this.root) {
      // No nodes are there in the tree till now
      return
    }
    this.root.visit()
  }

  // Start by searching the root
  Tree.prototype.search = function (val) {
    const found = this.root.search(val)
    if (found !== null) {
      return found.value
    }
    // not found
    return null
  }

  // Add a new value to the tree
  Tree.prototype.addValue = function (val) {
    const n = new Node(val)
    if (this.root === null) {
      this.root = n
    } else {
      this.root.addNode(n)
    }
  }

  // remove a value from the tree
  Tree.prototype.removeValue = function (val) {
    // remove something if root exists
    this.root = this.root && this.root.removeNode(val)
  }

  // returns the constructor
  return Tree
}())

export { Tree }

--#

--% C:/work/algos/Javascript/Data-Structures/Tree/Trie.js
const TrieNode = function TrieNode (key, parent) {
  this.key = key
  this.count = 0
  this.children = Object.create(null)
  if (parent === undefined) {
    this.parent = null
  } else {
    this.parent = parent
  }
}

function Trie () {
  // create only root with null key and parent
  this.root = new TrieNode(null, null)
}

// Recursively finds the occurrence of all words in a given node
Trie.findAllWords = function (root, word, output) {
  if (root === null) return
  if (root.count > 0) {
    if (typeof output === 'object') { output.push({ word: word, count: root.count }) }
  }
  let key
  for (key in root.children) {
    word += key
    this.findAllWords(root.children[key], word, output)
    word = word.slice(0, -1)
  }
}

Trie.prototype.insert = function (word) {
  if (typeof word !== 'string') return
  if (word === '') {
    this.root.count += 1
    return
  }
  let node = this.root
  const len = word.length
  let i
  for (i = 0; i < len; i++) {
    if (node.children[word.charAt(i)] === undefined) { node.children[word.charAt(i)] = new TrieNode(word.charAt(i), node) }
    node = node.children[word.charAt(i)]
  }
  node.count += 1
}

Trie.prototype.findPrefix = function (word) {
  if (typeof word !== 'string') return null
  let node = this.root
  const len = word.length
  let i
  // After end of this loop node will be at desired prefix
  for (i = 0; i < len; i++) {
    if (node.children[word.charAt(i)] === undefined) return null // No such prefix exists
    node = node.children[word.charAt(i)]
  }
  return node
}

Trie.prototype.remove = function (word, count) {
  if (typeof word !== 'string') return
  if (typeof count !== 'number') count = 1
  else if (count <= 0) return

  // for empty string just delete count of root
  if (word === '') {
    if (this.root.count >= count) this.root.count -= count
    else this.root.count = 0
    return
  }

  let child = this.root
  const len = word.length
  let i, key
  // child: node which is to be deleted
  for (i = 0; i < len; i++) {
    key = word.charAt(i)
    if (child.children[key] === undefined) return
    child = child.children[key]
  }

  // Delete no of occurrences specified
  if (child.count >= count) child.count -= count
  else child.count = 0

  // If some occurrences are left we dont delete it or else
  // if the object forms some other objects prefix we dont delete it
  // For checking an empty object
  // https://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object
  if (child.count <= 0 && (Object.keys(child.children).length && child.children.constructor === Object)) {
    child.parent.children[child.key] = undefined
  }
}

Trie.prototype.findAllWords = function (prefix) {
  const output = []
  // find the node with provided prefix
  const node = this.findPrefix(prefix)
  // No such prefix exists
  if (node === null) return output
  Trie.findAllWords(node, prefix, output)
  return output
}

Trie.prototype.contains = function (word) {
  // find the node with given prefix
  const node = this.findPrefix(word)
  // No such word exists
  if (node === null || node.count === 0) return false
  return true
}

Trie.prototype.findOccurences = function (word) {
  // find the node with given prefix
  const node = this.findPrefix(word)
  // No such word exists
  if (node === null) return 0
  return node.count
}

export { Trie }

--#

--% C:/work/algos/Javascript/Data-Structures/Vectors/Vector2.js
/**
 * In mathematics and physics, a vector is an element of a vector space.
 *
 * The Vector2-class implements 2-dimensional vectors together with various vector-operations.
 * @see https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics).
 */

class Vector2 {
  constructor (x, y) {
    this.x = x
    this.y = y
  }

  /**
   * Check for exact vector equality.
   *
   * @param vector The vector to compare to.
   * @returns Whether they are exactly equal or not.
   */
  equalsExactly (vector) {
    return this.x === vector.x && this.y === vector.y
  }

  /**
   * Check for approximate vector equality.
   *
   * @param vector The vector to compare to.
   * @param epsilon The allowed discrepancy for the x-values and the y-values.
   * @returns Whether they are approximately equal or not.
   */
  equalsApproximately (vector, epsilon) {
    return (Math.abs(this.x - vector.x) < epsilon && Math.abs(this.y - vector.y) < epsilon)
  }

  /**
   * Vector length.
   *
   * @returns The length of the vector.
   */
  length () {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }

  /**
   * Normalization sets the vector to length 1 while maintaining its direction.
   *
   * @returns The normalized vector.
   */
  normalize () {
    const length = this.length()
    if (length === 0) {
      throw new Error('Cannot normalize vectors of length 0')
    }
    return new Vector2(this.x / length, this.y / length)
  }

  /**
   * Vector addition
   *
   * @param vector The vector to be added.
   * @returns The sum-vector.
   */
  add (vector) {
    const x = this.x + vector.x
    const y = this.y + vector.y
    return new Vector2(x, y)
  }

  /**
   * Vector subtraction
   *
   * @param vector The vector to be subtracted.
   * @returns The difference-vector.
   */
  subtract (vector) {
    const x = this.x - vector.x
    const y = this.y - vector.y
    return new Vector2(x, y)
  }

  /**
   * Vector scalar multiplication
   *
   * @param scalar The factor by which to multiply the vector.
   * @returns The scaled vector.
   */
  multiply (scalar) {
    const x = this.x * scalar
    const y = this.y * scalar
    return new Vector2(x, y)
  }

  /**
   * Distance between this vector and another vector.
   *
   * @param vector The vector to which to calculate the distance.
   * @returns The distance.
   */
  distance (vector) {
    const difference = vector.subtract(this)
    return difference.length()
  }

  /**
   * Vector dot product
   *
   * @param vector The vector used for the multiplication.
   * @returns The resulting dot product.
   */
  dotProduct (vector) {
    return this.x * vector.x + this.y * vector.y
  }

  /**
   * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)
   *
   * @param angleInRadians The angle in radians by which to rotate the vector.
   * @returns The rotated vector.
   */
  rotate (angleInRadians) {
    const ca = Math.cos(angleInRadians)
    const sa = Math.sin(angleInRadians)
    const x = ca * this.x - sa * this.y
    const y = sa * this.x + ca * this.y
    return new Vector2(x, y)
  }

  /**
   * Measure angle between two vectors
   *
   * @param vector The 2nd vector for the measurement.
   * @returns The angle in radians.
   */
  angleBetween (vector) {
    return Math.atan2(vector.y, vector.x) - Math.atan2(this.y, this.x)
  }
}

export { Vector2 }

--#

--% C:/work/algos/Javascript/Data-Structures/Vectors/test/Vector2.test.js
import { Vector2 } from '../Vector2.js'

describe('Vector2', () => {
  describe('#equalsExactly', () => {
    it('should compare equality correctly', () => {
      expect(new Vector2(1, 0).equalsExactly(new Vector2(1, 0))).toBe(true)

      expect(new Vector2(1.23, 4.56).equalsExactly(new Vector2(0, 0))).toBe(false)
    })
  })

  describe('#equalsApproximately', () => {
    it('should compare equality (approximately) correctly', () => {
      expect(new Vector2(1, 0).equalsApproximately(new Vector2(1, 0.0000001), 0.000001))
        .toBe(true)

      expect(new Vector2(1.23, 4.56).equalsApproximately(new Vector2(1.24, 4.56), 0.000001))
        .toBe(false)
    })
  })

  describe('#add', () => {
    it('should add two vectors correctly', () => {
      expect(new Vector2(1, 0).add(new Vector2(0, 1)).equalsApproximately(new Vector2(1, 1), 0.000001))
        .toBe(true)

      expect(new Vector2(-3.3, -9).add(new Vector2(-2.2, 3)).equalsApproximately(new Vector2(-5.5, -6), 0.000001))
        .toBe(true)
    })
  })

  describe('#subtract', () => {
    it('should subtract two vectors correctly', () => {
      expect(new Vector2(1, 0).subtract(new Vector2(0, 1)).equalsApproximately(new Vector2(1, -1), 0.000001))
        .toBe(true)

      expect(new Vector2(234.5, 1.7).subtract(new Vector2(3.3, 2.7)).equalsApproximately(new Vector2(231.2, -1), 0.000001))
        .toBe(true)
    })
  })

  describe('#multiply', () => {
    it('should multiply two vectors correctly', () => {
      expect(new Vector2(1, 0).multiply(5).equalsApproximately(new Vector2(5, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(3.41, -7.12).multiply(-3.1).equalsApproximately(new Vector2(-10.571, 22.072), 0.000001))
        .toBe(true)
    })
  })

  describe('#length', () => {
    it('should calculate it\'s length correctly', () => {
      expect(new Vector2(1, 0).length()).toBe(1)

      expect(new Vector2(-1, 1).length()).toBe(Math.sqrt(2))
    })
  })

  describe('#normalize', () => {
    it('should normalize vectors correctly', () => {
      expect(new Vector2(1, 0).normalize().equalsApproximately(new Vector2(1, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(1, -1).normalize().equalsApproximately(new Vector2(Math.sqrt(2) / 2, -Math.sqrt(2) / 2), 0.000001))
        .toBe(true)
    })
  })

  describe('#distance', () => {
    it('should calculate the distance between two vectors correctly', () => {
      expect(new Vector2(0, 0).distance(new Vector2(0, -1))).toBe(1)

      expect(new Vector2(1, 0).distance(new Vector2(0, 1))).toBe(Math.sqrt(2))
    })
  })

  describe('#dotProduct', () => {
    it('should calculate the dot product correctly', () => {
      expect(new Vector2(1, 0).dotProduct(new Vector2(0, 1))).toBe(0)

      expect(new Vector2(1, 2).dotProduct(new Vector2(3, 4))).toBe(11) // 1 * 3 + 2 * 4
    })
  })

  describe('#rotate', () => {
    it('should rotate a vector correctly', () => {
      expect(new Vector2(0, -1).rotate(Math.PI / 2).equalsApproximately(new Vector2(1, 0), 0.000001))
        .toBe(true)

      expect(new Vector2(1.23, -4.56).rotate(Math.PI).equalsApproximately(new Vector2(-1.23, 4.56), 0.000001))
        .toBe(true)
    })
  })

  describe('#angleBetween', () => {
    it('should calculate the angle between two vectors correctly', () => {
      expect(new Vector2(1, 0).angleBetween(new Vector2(0, 1))).toBe(Math.PI / 2)

      expect(new Vector2(1, 0).angleBetween(new Vector2(1, -1))).toBe(-Math.PI / 4)
    })
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/ClimbingStairs.js
/**
 * @function ClimbStairs
 * @description You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 * @param {Integer} n - The input integer
 * @return {Integer} distinct ways can you climb to the top.
 * @see [Climb_Stairs](https://www.geeksforgeeks.org/count-ways-reach-nth-stair/)
 */

const climbStairs = (n) => {
  let prev = 0
  let cur = 1
  let temp

  for (let i = 0; i < n; i++) {
    temp = prev
    prev = cur
    cur += temp
  }
  return cur
}

export { climbStairs }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/CoinChange.js
/**
 * @params {Array} coins
 * @params {Number} amount
 */
export const change = (coins, amount) => {
  // Create and initialize the storage
  const combinations = new Array(amount + 1).fill(0)
  combinations[0] = 1
  // Determine the direction of smallest sub-problem
  for (let i = 0; i < coins.length; i++) {
    // Travel and fill the combinations array
    for (let j = coins[i]; j < combinations.length; j++) {
      combinations[j] += combinations[j - coins[i]]
    }
  }
  return combinations[amount]
}
/**
 * @params {Array} coins
 * @params {Number} amount
 */
export const coinChangeMin = (coins, amount) => {
  const map = { 0: 1 }
  for (let i = 1; i <= amount; i++) {
    let min = Infinity
    for (const coin of coins) {
      if (i < coin) continue
      min = Math.min(min, 1 + map[i - coin])
    }
    map[i] = min
  }
  return map[amount] === Infinity ? -1 : map[amount] - 1
}

--#

--% C:/work/algos/Javascript/Dynamic-Programming/EditDistance.js
/*
Wikipedia -> https://en.wikipedia.org/wiki/Edit_distance

Q. -> Given two strings `word1` and `word2`. You can perform these operations on any of the string to make both strings similar.
    - Insert
    - Remove
    - Replace
Find the minimum operation cost required to make both same. Each operation cost is 1.

Algorithm details ->
time complexity - O(n*m)
space complexity - O(n*m)
*/

const minimumEditDistance = (word1, word2) => {
  const n = word1.length
  const m = word2.length
  const dp = new Array(m + 1).fill(0).map(item => [])

  /*
    fill dp matrix with default values -
        - first row is filled considering no elements in word2.
        - first column filled considering no elements in word1.
    */

  for (let i = 0; i < n + 1; i++) {
    dp[0][i] = i
  }

  for (let i = 0; i < m + 1; i++) {
    dp[i][0] = i
  }

  /*
        indexing is 1 based for dp matrix as we defined some known values at first row and first column/
    */

  for (let i = 1; i < m + 1; i++) {
    for (let j = 1; j < n + 1; j++) {
      const letter1 = word1[j - 1]
      const letter2 = word2[i - 1]

      if (letter1 === letter2) {
        dp[i][j] = dp[i - 1][j - 1]
      } else {
        dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1
      }
    }
  }

  return dp[m][n]
}

export { minimumEditDistance }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/FibonacciNumber.js
/**
 * @function Fibonacci
 * @description Fibonacci is the sum of previous two fibonacci numbers.
 * @param {Integer} N - The input integer
 * @return {Integer} fibonacci of N.
 * @see [Fibonacci_Numbers](https://en.wikipedia.org/wiki/Fibonacci_number)
 */
const fibonacci = (N) => {
  // creating array to store values
  const memo = new Array(N + 1)
  memo[0] = 0
  memo[1] = 1
  for (let i = 2; i <= N; i++) {
    memo[i] = memo[i - 1] + memo[i - 2]
  }
  return memo[N]
}

export { fibonacci }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/FindMonthCalendar.js
/*
*  This algorithm accepts a month in the format mm/yyyy.
*  And prints out the month's calendar.
*  It uses an epoch of 1/1/1900, Monday.
*/

class Month {
  constructor () {
    this.Days = ['M', 'T', 'W', 'Th', 'F', 'S', 'Su']
    this.BDays = ['M', 'Su', 'S', 'F', 'Th', 'W', 'T']
    this.epoch = { month: 1, year: 1900 }
    this.monthDays = [31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    this.monthDaysLeap = [31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
  }

  printCal (days, startDay, output = value => console.log(value)) {
    output('M   T   W   Th  F   S   Su')
    const dates = []; let i
    for (i = 1; i <= days; i++) {
      dates.push(i)
    }
    for (i = 0; i < this.Days.indexOf(startDay); i++) {
      dates.unshift(' ')
    }
    while (true) {
      let row = ''
      for (i = 0; (i < 7) && (dates.length !== 0); i++) {
        row += dates.shift()
        while ((row.length % 4) !== 0) {
          row += ' '
        }
      }
      output(row)
      if (dates.length === 0) break
    }
  }

  parseDate (date) {
    const dateAr = []; let block = ''; let i
    for (i = 0; i < date.length; i++) {
      if (date[i] === '/') {
        dateAr.push(parseInt(block))
        block = ''
        continue
      }
      block += date[i]
    }
    dateAr.push(parseInt(block))
    if (dateAr.length !== 2) throw new Error('Improper string encoding')
    const dateOb = { month: dateAr[0], year: dateAr[1] }
    return dateOb
  }

  isLeapYear (year) {
    if (((year % 400) === 0) || (((year % 100) !== 0) && ((year % 4) === 0))) return true
    return false
  }

  isGreater (startDate, endDate) {
    if (startDate.year > endDate.year) {
      return true
    } else if (startDate.year < endDate.year) {
      return false
    } else if (startDate.month > endDate.month) {
      return true
    } else if (startDate.month < endDate.month) {
      return false
    }
    return true
  }

  getDayDiff (startDate, endDate) {
    if (this.isGreater(startDate, endDate) === null) {
      return 0
    } else if ((this.isGreater(startDate, endDate) === true)) {
      const midDate = startDate
      startDate = endDate
      endDate = midDate
    }
    let diff = 0
    while (startDate.year !== endDate.year) {
      diff += (this.isLeapYear(startDate.year)) ? 366 : 365
      startDate.year = startDate.year + 1
    }
    while (startDate.month !== endDate.month) {
      if (startDate.month < endDate.month) {
        if (this.isLeapYear(startDate.year)) diff += this.monthDaysLeap[startDate.month]
        else diff += this.monthDays[startDate.month]
        startDate.month = startDate.month + 1
      } else {
        if (this.isLeapYear(startDate.year)) diff -= this.monthDaysLeap[startDate.month - 1]
        else diff -= this.monthDays[startDate.month - 1]
        startDate.month = startDate.month - 1
      }
    }
    return diff
  }

  generateMonthCal (date) {
    const Month = this.parseDate(date); let day = ''
    let difference = this.getDayDiff(this.epoch, Month)
    difference = difference % 7
    let Month2 = this.parseDate(date)
    day = (this.isGreater(Month2, this.epoch)) ? this.Days[difference] : this.BDays[difference]
    Month2 = this.parseDate(date)
    if (this.isLeapYear(Month2.year)) this.printCal(this.monthDaysLeap[Month2.month], day)
    else this.printCal(this.monthDays[Month2.month], day)
  }
}

export { Month }

// const x = new Month()
// x.generateMonthCal('1/2021')

--#

--% C:/work/algos/Javascript/Dynamic-Programming/KadaneAlgo.js
/* Kadane's algorithm is one of the most efficient ways to
 * calculate the maximum contiguous subarray sum for a given array.
 * Below is the implementation of kadanes's algorithm along with
 * some sample test cases.
 * There might be a special case in this problem if al the elements
 * of the given array are negative. In such a case, the maximum negative
 * value present in the array is the answer.
 *
 * Reference article :- https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/
 */

export function kadaneAlgo (array) {
  let cummulativeSum = 0
  let maxSum = Number.NEGATIVE_INFINITY // maxSum has the least possible value
  for (let i = 0; i < array.length; i++) {
    cummulativeSum = cummulativeSum + array[i]
    if (maxSum < cummulativeSum) {
      maxSum = cummulativeSum
    } else if (cummulativeSum < 0) {
      cummulativeSum = 0
    }
  }
  return maxSum
  // This function returns largest sum contiguous sum in a array
}

--#

--% C:/work/algos/Javascript/Dynamic-Programming/LevenshteinDistance.js
/**
 * A Dynamic Programming based solution for calculation of the Levenshtein Distance
 * https://en.wikipedia.org/wiki/Levenshtein_distance
 */

function minimum (a, b, c) {
  if (a < b && a < c) {
    return a
  } else if (b < a && b < c) {
    return b
  } else {
    return c
  }
}

function costOfSubstitution (x, y) {
  return x === y ? 0 : 1
}

// Levenshtein distance between x and y
function calculate (x, y) {
  const dp = new Array(x.length + 1)
  for (let i = 0; i < x.length + 1; i++) {
    dp[i] = new Array(y.length + 1)
  }

  for (let i = 0; i < x.length + 1; i++) {
    for (let j = 0; j < y.length + 1; j++) {
      if (i === 0) {
        dp[i][j] = j
      } else if (j === 0) {
        dp[i][j] = i
      } else {
        dp[i][j] = minimum(dp[i - 1][j - 1] + costOfSubstitution(x.charAt(i - 1), y.charAt(j - 1)), dp[i - 1][j] + 1, dp[i][j - 1] + 1)
      }
    }
  }

  return dp[x.length][y.length]
}

export { calculate }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/LongestCommonSubsequence.js
/*
Problem:
Given two sequences, find the length of longest subsequence present in both of them.
A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.
For example, abc, abg, bdf, aeg, acefg, .. etc are subsequences of abcdefg

Our Solution:
We use recursion with tabular memoization.
Time complexity: O(M x N)
Solving each subproblem has a cost of O(1). Again, there are MxN subproblems,
and so we get a total time complexity of O(MxN).
Space complexity: O(M x N)
We need to store the answer for each of the MxN subproblems.

Improvement:
It's possible to optimize space complexity to O(min(M, N)) or time to O((N + r)log(N))
where r is the number of matches between the two sequences. Try to figure out how.

References:
[wikipedia](https://en.wikipedia.org/wiki/Longest_common_subsequence_problem)
[leetcode](https://leetcode.com/problems/longest-common-subsequence/)
*/

/**
 * Finds length of the longest common subsequence among the two input string
 * @param {string} str1 Input string #1
 * @param {string} str2 Input string #2
 * @returns {number} Length of the longest common subsequence
 */
function longestCommonSubsequence (str1, str2) {
  const memo = new Array(str1.length + 1).fill(null)
    .map(() => new Array(str2.length + 1).fill(null))

  function recursive (end1, end2) {
    if (end1 === -1 || end2 === -1) {
      return 0
    }

    if (memo[end1][end2] !== null) {
      return memo[end1][end2]
    }

    if (str1[end1] === str2[end2]) {
      memo[end1][end2] = 1 + recursive(end1 - 1, end2 - 1)
      return memo[end1][end2]
    } else {
      memo[end1][end2] = Math.max(
        recursive(end1 - 1, end2),
        recursive(end1, end2 - 1)
      )
      return memo[end1][end2]
    }
  }

  return recursive(str1.length - 1, str2.length - 1)
}

export { longestCommonSubsequence }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/LongestIncreasingSubsequence.js
/**
 * A Dynamic Programming based solution for calculating Longest Increasing Subsequence
 * https://en.wikipedia.org/wiki/Longest_increasing_subsequence
 */

// Return the length of the Longest Increasing Subsequence, given array x
function longestIncreasingSubsequence (x) {
  const length = x.length
  const dp = Array(length).fill(1)

  let res = 1

  for (let i = 0; i < length; i++) {
    for (let j = 0; j < i; j++) {
      if (x[i] > x[j]) {
        dp[i] = Math.max(dp[i], 1 + dp[j])
        if (dp[i] > res) {
          res = dp[i]
        }
      }
    }
  }

  return res
}

export { longestIncreasingSubsequence }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/LongestPalindromicSubsequence.js
/*
  LeetCode -> https://leetcode.com/problems/longest-palindromic-subsequence/

  Given a string s, find the longest palindromic subsequence's length in s.
  You may assume that the maximum length of s is 1000.

*/

export const longestPalindromeSubsequence = function (s) {
  const n = s.length

  const dp = new Array(n).fill(0).map(item => new Array(n).fill(0).map(item => 0))

  // fill predefined for single character
  for (let i = 0; i < n; i++) {
    dp[i][i] = 1
  }

  for (let i = 1; i < n; i++) {
    for (let j = 0; j < n - i; j++) {
      const col = j + i
      if (s[j] === s[col]) {
        dp[j][col] = 2 + dp[j + 1][col - 1]
      } else {
        dp[j][col] = Math.max(dp[j][col - 1], dp[j + 1][col])
      }
    }
  }

  return dp[0][n - 1]
}

--#

--% C:/work/algos/Javascript/Dynamic-Programming/LongestValidParentheses.js
/*
  LeetCode -> https://leetcode.com/problems/longest-valid-parentheses/

  Given a string containing just the characters '(' and ')',
  find the length of the longest valid (well-formed) parentheses substring.
*/

export const longestValidParentheses = (s) => {
  const n = s.length
  const stack = []

  // storing results
  const res = new Array(n).fill(-Infinity)

  for (let i = 0; i < n; i++) {
    const bracket = s[i]

    if (bracket === ')' && s[stack[stack.length - 1]] === '(') {
      res[i] = 1
      res[stack[stack.length - 1]] = 1
      stack.pop()
    } else {
      stack.push(i)
    }
  }

  // summing all adjacent valid
  for (let i = 1; i < n; i++) {
    res[i] = Math.max(res[i], res[i] + res[i - 1])
  }

  // adding 0 if there are none so it will return 0 instead of -Infinity
  res.push(0)
  return Math.max(...res)
}

--#

--% C:/work/algos/Javascript/Dynamic-Programming/MaxNonAdjacentSum.js
function maximumNonAdjacentSum (nums) {
  /*
         * Find the maximum non-adjacent sum of the integers in the nums input list
         * :param nums: Array of Numbers
         * :return: The maximum non-adjacent sum
    */

  if (nums.length < 0) return 0

  let maxIncluding = nums[0]
  let maxExcluding = 0

  for (const num of nums.slice(1)) {
    const temp = maxIncluding
    maxIncluding = maxExcluding + num
    maxExcluding = Math.max(temp, maxExcluding)
  }

  return Math.max(maxExcluding, maxIncluding)
}

// Example

// maximumNonAdjacentSum([1, 2, 3]))
// maximumNonAdjacentSum([1, 5, 3, 7, 2, 2, 6]))
// maximumNonAdjacentSum([-1, -5, -3, -7, -2, -2, -6]))
// maximumNonAdjacentSum([499, 500, -3, -7, -2, -2, -6]))

export { maximumNonAdjacentSum }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/MaxProductOfThree.js
/**
 *  Given an array of numbers, return the maximum product
 *  of 3 numbers from the array
 *  https://wsvincent.com/javascript-three-sum-highest-product-of-three-numbers/
 * @param {number[]} arrayItems
 * @returns number
 */
export function maxProductOfThree (arrayItems) {
  // if size is less than 3, no triplet exists
  const n = arrayItems.length
  if (n < 3) throw new Error('Triplet cannot exist with the given array')
  let max1 = arrayItems[0]
  let max2 = -1
  let max3 = -1
  let min1 = arrayItems[0]
  let min2 = -1
  for (let i = 1; i < n; i++) {
    if (arrayItems[i] > max1) {
      max3 = max2
      max2 = max1
      max1 = arrayItems[i]
    } else if (max2 === -1 || arrayItems[i] > max2) {
      max3 = max2
      max2 = arrayItems[i]
    } else if (max3 === -1 || arrayItems[i] > max3) {
      max3 = arrayItems[i]
    }
    if (arrayItems[i] < min1) {
      min2 = min1
      min1 = arrayItems[i]
    } else if (min2 === -1 || arrayItems[i] < min2) {
      min2 = arrayItems[i]
    }
  }
  const prod1 = max1 * max2 * max3
  const prod2 = max1 * min1 * min2
  return Math.max(prod1, prod2)
}

--#

--% C:/work/algos/Javascript/Dynamic-Programming/MinimumCostPath.js
// Problem Statement => https://www.youtube.com/watch?v=lBRtnuxg-gU

const minCostPath = (matrix) => {
  /*
        Find the min cost path from top-left to bottom-right in matrix
        >>> minCostPath([[2, 1], [3, 1], [4, 2]])
        >>> 6
    */

  const n = matrix.length
  const m = matrix[0].length

  // moves[i][j] => minimum number of moves to reach cell i, j
  const moves = new Array(n)
  for (let i = 0; i < moves.length; i++) moves[i] = new Array(m)

  // base conditions
  moves[0][0] = matrix[0][0] // to reach cell (0, 0) from (0, 0) is of no moves
  for (let i = 1; i < m; i++) moves[0][i] = moves[0][i - 1] + matrix[0][i]
  for (let i = 1; i < n; i++) moves[i][0] = moves[i - 1][0] + matrix[i][0]

  for (let i = 1; i < n; i++) {
    for (let j = 1; j < m; j++) { moves[i][j] = Math.min(moves[i - 1][j], moves[i][j - 1]) + matrix[i][j] }
  }

  return moves[n - 1][m - 1]
}

export { minCostPath }

// Example

// minCostPath([
//   [2, 1],
//   [3, 1],
//   [4, 2]
// ])

// minCostPath([
//   [2, 1, 4],
//   [2, 1, 3],
//   [3, 2, 1]
// ])

--#

--% C:/work/algos/Javascript/Dynamic-Programming/NumberOfSubsetEqualToGivenSum.js
/*
Given an array of non-negative integers and a value sum,
determine the total number of the subset with sum
equal to the given sum.
*/
/*
 Given solution is O(n*sum) Time complexity and O(sum) Space complexity
*/
function NumberOfSubsetSum (array, sum) {
  const dp = [] // create an dp array where dp[i] denote number of subset with sum equal to i
  for (let i = 1; i <= sum; i++) {
    dp[i] = 0
  }
  dp[0] = 1 // since sum equal to 0 is always possible with no element in subset

  for (let i = 0; i < array.length; i++) {
    for (let j = sum; j >= array[i]; j--) {
      if (j - array[i] >= 0) {
        dp[j] += dp[j - array[i]]
      }
    }
  }
  return dp[sum]
}

// example

// const array = [1, 1, 2, 2, 3, 1, 1]
// const sum = 4
// const result = NumberOfSubsetSum(array, sum)

export { NumberOfSubsetSum }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/RodCutting.js
/*
  * You are given a rod of 'n' length and an array of prices associated with all the lengths less than 'n'.
  * Find the maximum profit possible by cutting the rod and selling the pieces.
*/

export function rodCut (prices, n) {
  const memo = new Array(n + 1)
  memo[0] = 0

  for (let i = 1; i <= n; i++) {
    let maxVal = Number.MIN_VALUE
    for (let j = 0; j < i; j++) { maxVal = Math.max(maxVal, prices[j] + memo[i - j - 1]) }
    memo[i] = maxVal
  }

  return memo[n]
}

--#

--% C:/work/algos/Javascript/Dynamic-Programming/Shuf.js
/*
Given a data set of an unknown size,
Get a random sample in a random order
It's used in data analytics, often as a way to get a small random sample from a data lake or warehouse, or from a large CSV file
*/
function shuf (datasetSource, sampleSize) {
  const output = fillBaseSample(datasetSource, sampleSize)

  return randomizeOutputFromDataset(datasetSource, output)
}

/**
 * Fills the output if possible, with the minimum number of values
 * @param {Iterable.<T>} datasetSource The iterable source of data
 * @param {number} sampleSize The size of the sample to extract from the dataset
 * @returns {Array.<T>} The random sample, as an array
 * @template T
 */
function fillBaseSample (datasetSource, sampleSize) {
  let filledIndexes = []
  let output = new Array(sampleSize)

  // Spread data out filling the array
  while (true) {
    const iterator = datasetSource.next()
    if (iterator.done) break

    let insertTo = Math.floor(Math.random() * output.length)
    while (filledIndexes.includes(insertTo)) {
      insertTo++
      if (insertTo === output.length) {
        insertTo = 0
      }
    }
    output[insertTo] = {
      value: iterator.value
    }

    filledIndexes = [...filledIndexes, insertTo]

    if (filledIndexes.length === sampleSize) {
      break
    }
  }

  if (filledIndexes.length < output.length) {
    // Not a large enough dataset to fill the sample - trim empty values
    output = output.filter((_, i) => filledIndexes.includes(i))
  }

  return output.map((o) => o.value)
}

/**
 * Replaces values in the output randomly with new ones from the dataset
 * @param {Iterable.<T>} datasetSource The iterable source of data
 * @param {Array.<T>} output The output so far, filled with data
 * @returns {Array.<T>} The random sample, as an array
 * @template T
 */
function randomizeOutputFromDataset (datasetSource, output) {
  const newOutput = [...output]
  let readSoFar = output.length

  while (true) {
    const iterator = datasetSource.next()
    if (iterator.done) break
    readSoFar++

    const insertTo = Math.floor(Math.random() * readSoFar)
    if (insertTo < newOutput.length) {
      newOutput[insertTo] = iterator.value
    }
  }

  return newOutput
}

// Example

/**
 * Generates a random range of data, with values between 0 and 2^31 - 1
 * @param {number} length The number of data items to generate
 * @returns {Iterable<number>} Random iterable data
*/
function * generateRandomData (length) {
  const maxValue = Math.pow(2, 31) - 1
  for (let i = 0; i < length; i++) {
    yield Math.floor(Math.random() * maxValue)
  }
}

// const source = generateRandomData(1000)
// const result = shuf(source, 10)

export { shuf, generateRandomData }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/SieveOfEratosthenes.js
/**
 * @function SieveOfEratosthenes
 * @description Calculates prime numbers till input number n
 * @param {Number} n - The input integer
 * @return {Number[]} List of Primes till n.
 * @see [Sieve_of_Eratosthenes](https://www.geeksforgeeks.org/sieve-of-eratosthenes/)
 */
function sieveOfEratosthenes (n) {
  if (n <= 1) return []
  const primes = new Array(n + 1).fill(true) // set all as true initially
  primes[0] = primes[1] = false // Handling case for 0 and 1
  for (let i = 2; i * i <= n; i++) {
    if (primes[i]) {
      for (let j = i * i; j <= n; j += i) {
        primes[j] = false
      }
    }
  }

  return primes.reduce((result, isPrime, index) => {
    if (isPrime) {
      result.push(index)
    }
    return result
  }, [])
}

// Example

// const n = 69 // number till where we wish to find primes
// const primes = sieveOfEratosthenes(n)

export { sieveOfEratosthenes }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/SudokuSolver.js

const isValid = (board, row, col, k) => {
  for (let i = 0; i < 9; i++) {
    const m = 3 * Math.floor(row / 3) + Math.floor(i / 3)
    const n = 3 * Math.floor(col / 3) + i % 3
    if (board[row][i] === k || board[i][col] === k || board[m][n] === k) {
      return false
    }
  }
  return true
}

const sudokuSolver = (data) => {
  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      if (data[i][j] === '.') {
        for (let k = 1; k <= 9; k++) {
          if (isValid(data, i, j, `${k}`)) {
            data[i][j] = `${k}`
            if (sudokuSolver(data)) {
              return true
            } else {
              data[i][j] = '.'
            }
          }
        }
        return false
      }
    }
  }
  return true
}

// testing

// const board = [
//   ['.', '9', '.', '.', '4', '2', '1', '3', '6'],
//   ['.', '.', '.', '9', '6', '.', '4', '8', '5'],
//   ['.', '.', '.', '5', '8', '1', '.', '.', '.'],
//   ['.', '.', '4', '.', '.', '.', '.', '.', '.'],
//   ['5', '1', '7', '2', '.', '.', '9', '.', '.'],
//   ['6', '.', '2', '.', '.', '.', '3', '7', '.'],
//   ['1', '.', '.', '8', '.', '4', '.', '2', '.'],
//   ['7', '.', '6', '.', '.', '.', '8', '1', '.'],
//   ['3', '.', '.', '.', '9', '.', '.', '.', '.']
// ]
// sudokuSolver(board) // -> board updated by reference

export { sudokuSolver }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/TrappingRainWater.js
/**
 * @param {number[]} height
 * @return {number}
 */

/* 42. Trapping Rain Water
https://leetcode.com/problems/trapping-rain-water/

Helpful animation of this prompt: https://youtu.be/HmBbcDiJapY?t=51

Given n non-negative integers representing an elevation map where
the width of each bar is 1, compute how much water it is able to trap
after raining.

VIEW ELEVATION MAP ON LEETCODE

Example:

Input:            [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6

Plan:
iterate through and find left maxes
iterate through and find right maxes
create minheight and assign it to the min(leftmax, rightmax)
if current height(element) < minheight
  push minheight - height into water array
else
  push 0 onto water array

sum up water array and return

left maxes =      [0,0,1,1,2,2,2,2,3,3,3,3]
right maxes =     [3,3,3,3,3,3,3,2,2,2,1,0]
water contained = [0,0,1,0,1,2,1,0,0,1,0,0] -> sum = 6
*/

export const trap = (heights) => {
  const maxes = new Array(heights.length).fill(0)

  let leftMax = 0
  for (let i = 0; i < heights.length; i++) {
    const height = heights[i]
    maxes[i] = leftMax
    leftMax = Math.max(leftMax, height)
  }

  let rightMax = 0
  for (let i = heights.length - 1; i >= 0; i -= 1) {
    const height = heights[i]
    const minHeight = Math.min(rightMax, maxes[i])

    if (height < minHeight) {
      maxes[i] = minHeight - height
    } else {
      maxes[i] = 0
    }
    rightMax = Math.max(rightMax, height)
  }
  return maxes.reduce((a, b) => a + b, 0)
}

--#

--% C:/work/algos/Javascript/Dynamic-Programming/TribonacciNumber.js
/**
 * @function Tribonacci
 * @description Tribonacci is the sum of previous three tribonacci numbers.
 * @param {Integer} n - The input integer
 * @return {Integer} tribonacci of n.
 * @see [Tribonacci_Numbers](https://www.geeksforgeeks.org/tribonacci-numbers/)
 */
const tribonacci = (n) => {
  // creating array to store previous tribonacci numbers
  const dp = new Array(n + 1)
  dp[0] = 0
  dp[1] = 1
  dp[2] = 1
  for (let i = 3; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
  }
  return dp[n]
}

export { tribonacci }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/ZeroOneKnapsack.js
/**
 * A Dynamic Programming based solution for calculating Zero One Knapsack
 * https://en.wikipedia.org/wiki/Knapsack_problem
 */

const zeroOneKnapsack = (arr, n, cap, cache) => {
  if (cap === 0 || n === 0) {
    cache[n][cap] = 0
    return cache[n][cap]
  }
  if (cache[n][cap] !== -1) {
    return cache[n][cap]
  }
  if (arr[n - 1][0] <= cap) {
    cache[n][cap] = Math.max(arr[n - 1][1] + zeroOneKnapsack(arr, n - 1, cap - arr[n - 1][0], cache), zeroOneKnapsack(arr, n - 1, cap, cache))
    return cache[n][cap]
  } else {
    cache[n][cap] = zeroOneKnapsack(arr, n - 1, cap, cache)
    return cache[n][cap]
  }
}

const example = () => {
  /*
  Problem Statement:
  You are a thief carrying a single bag with limited capacity S. The museum you stole had N artifact that you could steal. Unfortunately you might not be able to steal all the artifact because of your limited bag capacity.
  You have to cherry pick the artifact in order to maximize the total value of the artifacts you stole.

  Link for the Problem: https://www.hackerrank.com/contests/srin-aadc03/challenges/classic-01-knapsack
  */
  let input = `1
    4 5
    1 8
    2 4
    3 0
    2 5
    2 3`

  input = input.trim().split('\n')
  input.shift()
  const length = input.length

  const output = []

  let i = 0
  while (i < length) {
    const cap = Number(input[i].trim().split(' ')[0])
    const currlen = Number(input[i].trim().split(' ')[1])
    let j = i + 1
    const arr = []
    while (j <= i + currlen) {
      arr.push(input[j])
      j++
    }
    const newArr = arr.map(e =>
      e.trim().split(' ').map(Number)
    )
    const cache = []
    for (let i = 0; i <= currlen; i++) {
      const temp = []
      for (let j = 0; j <= cap; j++) {
        temp.push(-1)
      }
      cache.push(temp)
    }
    const result = zeroOneKnapsack(newArr, currlen, cap, cache)
    output.push(result)
    i += currlen + 1
  }

  return output
}

export { zeroOneKnapsack, example }

--#

--% C:/work/algos/Javascript/Dynamic-Programming/Sliding-Window/LongestSubstringWithoutRepeatingCharacters.js
/**
 *  @name The-Sliding-Window Algorithm is primarily used for the problems dealing with linear data structures like Arrays, Lists, Strings etc.
 *  These problems can easily be solved using Brute Force techniques which result in quadratic or exponential time complexity.
 *  Sliding window technique reduces the required time to linear O(n).
 *  @see [The-Sliding-Window](https://www.geeksforgeeks.org/window-sliding-technique/)
 */

/**
 * @function LongestSubstringWithoutRepeatingCharacters
 * @description Get the length of the longest substring without repeating characters
 * @param {String} s - The input string
 */
export function LongestSubstringWithoutRepeatingCharacters (s) {
  let maxLength = 0
  let start = 0
  let end = 0
  const map = {}
  while (end < s.length) {
    if (map[s[end]] === undefined) {
      map[s[end]] = 1
      maxLength = Math.max(maxLength, end - start + 1)
      end++
    } else {
      while (s[start] !== s[end]) {
        delete map[s[start]]
        start++
      }
      delete map[s[start]]
      start++
    }
  }
  return maxLength
}

// Example 1:
// Input: s = "abcabcbb"
// Output: 3
// Explanation: The answer is "abc", with the length of 3.

// Example 2:
// Input: s = "bbbbb"
// Output: 1
// Explanation: The answer is "b", with the length of 1.

// Example 3:
// Input: s = "pwwkew"
// Output: 3
// Explanation: The answer is "wke", with the length of 3.
// Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

--#

--% C:/work/algos/Javascript/Dynamic-Programming/Sliding-Window/PermutationinString.js
/**
 *  @name The-Sliding-Window Algorithm is primarily used for the problems dealing with linear data structures like Arrays, Lists, Strings etc.
 *  These problems can easily be solved using Brute Force techniques which result in quadratic or exponential time complexity.
 *  Sliding window technique reduces the required time to linear O(n).
 *  @see [The-Sliding-Window](https://www.geeksforgeeks.org/window-sliding-technique/)
 */
/**
 * @function PermutationinString
 * @description Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
 * @param {String} s1 - The input string
 * @param {String} s2 - The input string
 * @return {boolean} - Returns true if s2 contains a permutation of s1, or false otherwise.
 */

export function PermutationinString (s1, s2) {
  if (s1.length > s2.length) return false
  let start = 0
  let end = s1.length - 1
  const s1Set = SetHash()
  const s2Set = SetHash()
  for (let i = 0; i < s1.length; i++) {
    s1Set[s1[i]]++
    s2Set[s2[i]]++
  }
  if (equals(s1Set, s2Set)) return true
  while (end < s2.length - 1) {
    if (equals(s1Set, s2Set)) return true
    end++
    const c1 = s2[start]
    const c2 = s2[end]
    if (s2Set[c1] > 0) s2Set[c1]--
    s2Set[c2]++
    start++
    if (equals(s1Set, s2Set)) return true
  }
  return false
}
function equals (a, b) {
  return JSON.stringify(a) === JSON.stringify(b)
}

function SetHash () {
  const set = new Set()
  const alphabets = 'abcdefghijklmnopqrstuvwxyz'
  for (let i = 0; i < alphabets.length; i++) {
    set[alphabets[i]] = 0
  }
  return set
}

// Example 1:
// Input: s1 = "ab", s2 = "eidbaooo"
// Output: true
// Explanation: s2 contains one permutation of s1 ("ba").

// Example 2:
// Input: s1 = "ab", s2 = "eidboaoo"
// Output: false

--#

--% C:/work/algos/Javascript/Dynamic-Programming/Sliding-Window/test/LongestSubstringWithoutRepeatingCharacters.test.js
import { LongestSubstringWithoutRepeatingCharacters } from '../LongestSubstringWithoutRepeatingCharacters.js'

describe('LongestSubstringWithoutRepeatingCharacters', () => {
  it('should return longest substring without repeating characters', () => {
    expect(LongestSubstringWithoutRepeatingCharacters('abcabcbb')).toEqual(3)
    expect(LongestSubstringWithoutRepeatingCharacters('bbbbb')).toEqual(1)
    expect(LongestSubstringWithoutRepeatingCharacters('pwwkew')).toEqual(3)
    expect(LongestSubstringWithoutRepeatingCharacters('a')).toEqual(1)
    expect(LongestSubstringWithoutRepeatingCharacters('')).toEqual(0)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/Sliding-Window/test/PermutationinString.test.js
import { PermutationinString } from '../PermutationinString.js'

describe('PermutationinString', () => {
  it("should  return true if one of s1's permutations is the substring of s2", () => {
    expect(PermutationinString('ab', 'eidbaooo')).toEqual(true)
    expect(PermutationinString('abc', 'bcab')).toEqual(true)
    expect(PermutationinString('ab', 'eidboaoo')).toEqual(false)
    expect(PermutationinString('abc', '')).toEqual(false)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/ClimbingStairs.test.js
import { climbStairs } from '../ClimbingStairs'

describe('ClimbingStairs', () => {
  it('climbStairs of 0', () => {
    expect(climbStairs(0)).toBe(1)
  })

  it('climbStairs of 1', () => {
    expect(climbStairs(1)).toBe(1)
  })

  it('climbStairs of 10', () => {
    expect(climbStairs(10)).toBe(89)
  })

  it('climbStairs of 15', () => {
    expect(climbStairs(15)).toBe(987)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/CoinChange.test.js
import { change, coinChangeMin } from '../CoinChange'

test('Base Case 1', () => {
  const coins = [2, 3, 5]
  const amount = 0
  expect(change(coins, amount)).toBe(1)
  expect(coinChangeMin(coins, amount)).toBe(0)
})
test('Base Case 2', () => {
  const coins = []
  const amount = 100
  expect(change(coins, amount)).toBe(0)
  expect(coinChangeMin(coins, amount)).toBe(-1)
})
test('Test Case 1', () => {
  const coins = [2, 4, 5]
  const amount = 12
  expect(change(coins, amount)).toBe(5)
  expect(coinChangeMin(coins, amount)).toBe(3)
})
test('Test Case 2', () => {
  const coins = [5, 2, 3, 7, 6, 1, 12, 11, 9, 15]
  const amount = 45
  expect(change(coins, amount)).toBe(12372)
  expect(coinChangeMin(coins, amount)).toBe(3)
})
test('Test Case 3', () => {
  const coins = [2]
  const amount = 3
  expect(change(coins, amount)).toBe(0)
  expect(coinChangeMin(coins, amount)).toBe(-1)
})
test('Test Case 4', () => {
  const coins = [3, 5, 7, 8, 9, 10, 11]
  const amount = 500
  expect(change(coins, amount)).toBe(35502874)
  expect(coinChangeMin(coins, amount)).toBe(46)
})
test('Test Case 5', () => {
  const coins = [10]
  const amount = 10
  expect(change(coins, amount)).toBe(1)
  expect(coinChangeMin(coins, amount)).toBe(1)
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/FibonacciNumber.test.js
import { fibonacci } from '../FibonacciNumber'

describe('FibonacciNumber', () => {
  it('fibonacci of 0', () => {
    expect(fibonacci(0)).toBe(0)
  })

  it('fibonacci of 1', () => {
    expect(fibonacci(1)).toBe(1)
  })

  it('fibonacci of 10', () => {
    expect(fibonacci(10)).toBe(55)
  })

  it('fibonacci of 25', () => {
    expect(fibonacci(25)).toBe(75025)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/KadaneAlgo.test.js
import { kadaneAlgo } from '../KadaneAlgo'
test('it is being checked that 15 is the answer to the corresponding array input', () => {
  expect(kadaneAlgo([1, 2, 3, 4, 5])).toBe(15)
})

test('it is being checked that 5 is the answer to the corresponding array input', () => {
  expect(kadaneAlgo([-1, -2, -3, -4, 5])).toBe(5)
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/LongestCommonSubsequence.test.js
import { longestCommonSubsequence } from '../LongestCommonSubsequence'

describe('LongestCommonSubsequence', () => {
  it('expects to return an empty string for empty inputs', () => {
    expect(longestCommonSubsequence('', '')).toEqual(''.length)
    expect(longestCommonSubsequence('aaa', '')).toEqual(''.length)
    expect(longestCommonSubsequence('', 'bbb')).toEqual(''.length)
  })

  it('expects to return an empty string for inputs without a common subsequence', () => {
    expect(longestCommonSubsequence('abc', 'deffgf')).toEqual(''.length)
    expect(longestCommonSubsequence('de', 'ghm')).toEqual(''.length)
    expect(longestCommonSubsequence('aupj', 'xyz')).toEqual(''.length)
  })

  it('expects to return the longest common subsequence, short inputs', () => {
    expect(longestCommonSubsequence('abc', 'abc')).toEqual('abc'.length)
    expect(longestCommonSubsequence('abc', 'abcd')).toEqual('abc'.length)
    expect(longestCommonSubsequence('abc', 'ab')).toEqual('ab'.length)
    expect(longestCommonSubsequence('abc', 'a')).toEqual('a'.length)
    expect(longestCommonSubsequence('abc', 'b')).toEqual('b'.length)
    expect(longestCommonSubsequence('abc', 'c')).toEqual('c'.length)
    expect(longestCommonSubsequence('abd', 'abcd')).toEqual('abd'.length)
    expect(longestCommonSubsequence('abd', 'ab')).toEqual('ab'.length)
    expect(longestCommonSubsequence('abc', 'abd')).toEqual('ab'.length)
  })

  it('expects to return the longest common subsequence, medium-length inputs', () => {
    expect(longestCommonSubsequence('bsbininm', 'jmjkbkjkv')).toEqual('b'.length)
    expect(longestCommonSubsequence('oxcpqrsvwf', 'shmtulqrypy')).toEqual('qr'.length)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/LongestPalindromicSubsequence.test.js
import { longestPalindromeSubsequence } from '../LongestPalindromicSubsequence'

describe('LongestPalindromicSubsequence', () => {
  it('expects to return 1 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('abcdefgh')).toBe(1)
  })

  it('expects to return 4 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('bbbab')).toBe(4)
  })

  it('expects to return 2 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('cbbd')).toBe(2)
  })

  it('expects to return 7 as longest palindromic subsequence', () => {
    expect(longestPalindromeSubsequence('racexyzcxar')).toBe(7)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/LongestValidParentheses.test.js
import { longestValidParentheses } from '../LongestValidParentheses'

describe('longestValidParentheses', () => {
  it('expects to return 0 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('')).toBe(0)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('(()')).toBe(2)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses(')()())')).toBe(4)
  })

  it('expects to return 2 as longest valid parentheses substring', () => {
    expect(longestValidParentheses('(((')).toBe(0)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/MaxProductOfThree.test.js
import { maxProductOfThree } from '../MaxProductOfThree'

describe('MaxProductOfThree', () => {
  it('expects to throw error for array with only 2 numbers', () => {
    expect(() => {
      maxProductOfThree([1, 3])
    }).toThrow('Triplet cannot exist with the given array')
  })

  it('expects to return 300 as the maximum product', () => {
    expect(maxProductOfThree([10, 6, 5, 3, 1, -10])).toBe(300)
  })

  it('expects to return 300 as the maximum product', () => {
    expect(maxProductOfThree([10, -6, 5, 3, 1, -10])).toBe(600)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/RodCutting.test.js
import { rodCut } from '../RodCutting'

test('Test Case 1', () => {
  expect(rodCut([1, 5, 8, 9, 10, 17, 17, 20], 8)).toBe(22)
})

test('Test Case 2', () => {
  expect(rodCut([1, 5, 4, 2, 1, 11, 19, 12], 8)).toBe(20)
})

test('Test Case 3', () => {
  expect(rodCut([1, 2, 1], 3)).toBe(3)
})

test('Test Case 4', () => {
  expect(rodCut([5, 4, 3, 2, 1], 5)).toBe(25)
})

test('Test Case 5', () => {
  expect(rodCut([3, 5, 8, 8, 10, 16, 14, 19], 8)).toBe(24)
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/SieveOfEratosthenes.test.js
import { sieveOfEratosthenes } from '../SieveOfEratosthenes'

describe('SieveOfEratosthenes', () => {
  it('Primes till 0', () => {
    expect(sieveOfEratosthenes(0)).toEqual([])
  })

  it('Primes till 1', () => {
    expect(sieveOfEratosthenes(1)).toEqual([])
  })

  it('Primes till 10', () => {
    expect(sieveOfEratosthenes(10)).toEqual([2, 3, 5, 7])
  })

  it('Primes till 23', () => {
    expect(sieveOfEratosthenes(23)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23])
  })

  it('Primes till 70', () => {
    expect(sieveOfEratosthenes(70)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67])
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/TrappingRainWater.test.js
import { trap } from '../TrappingRainWater'

describe('TrappingRainWater', () => {
  it('expects 6 units of rain water are being trapped', () => {
    expect(trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])).toBe(6)
  })

  it('expects 9 units of rain water are being trapped', () => {
    expect(trap([4, 2, 0, 3, 2, 5])).toBe(9)
  })
})

--#

--% C:/work/algos/Javascript/Dynamic-Programming/tests/TribonacciNumber.test.js
import { tribonacci } from '../TribonacciNumber'

describe('TribonacciNumber', () => {
  it('tribonacci of 0', () => {
    expect(tribonacci(0)).toBe(0)
  })

  it('tribonacci of 1', () => {
    expect(tribonacci(1)).toBe(1)
  })

  it('tribonacci of 2', () => {
    expect(tribonacci(2)).toBe(1)
  })

  it('tribonacci of 10', () => {
    expect(tribonacci(10)).toBe(149)
  })

  it('tribonacci of 25', () => {
    expect(tribonacci(25)).toBe(1389537)
  })
})

--#

--% C:/work/algos/Javascript/Geometry/ConvexHullGraham.js
/**
 * Author: Arnab Ray
 * ConvexHull using Graham Scan
 * Wikipedia: https://en.wikipedia.org/wiki/Graham_scan
 * Given a set of points in the plane. The Convex hull of the set is the smallest
 * convex polygon that contains all the points of it.
 */

function compare (a, b) {
  // Compare Function to Sort the points, a and b are points to compare
  if (a.x < b.x) return -1
  if (a.x === b.x && a.y < b.y) return -1
  return 1
}
function orientation (a, b, c) {
  // Check orientation of Line(a,b) and Line(b,c)
  const alpha = (b.y - a.y) / (b.x - a.x)
  const beta = (c.y - b.y) / (c.x - b.x)

  // Clockwise
  if (alpha > beta) return 1
  // Anticlockwise
  else if (beta > alpha) return -1
  // Colinear
  return 0
}

function convexHull (points) {
  const pointsLen = points.length
  if (pointsLen <= 2) {
    throw new Error('Minimum of 3 points is required to form closed polygon!')
  }

  points.sort(compare)
  const p1 = points[0]; const p2 = points[pointsLen - 1]

  // Divide Hull in two halves
  const upperPoints = []; const lowerPoints = []

  upperPoints.push(p1)
  lowerPoints.push(p1)

  for (let i = 1; i < pointsLen; i++) {
    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== -1) {
      let upLen = upperPoints.length

      while (upLen >= 2 && orientation(upperPoints[upLen - 2], upperPoints[upLen - 1], points[i]) === -1) {
        upperPoints.pop()
        upLen = upperPoints.length
      }
      upperPoints.push(points[i])
    }
    if (i === pointsLen - 1 || orientation(p1, points[i], p2) !== 1) {
      let lowLen = lowerPoints.length
      while (lowLen >= 2 && orientation(lowerPoints[lowLen - 2], lowerPoints[lowLen - 1], points[i]) === 1) {
        lowerPoints.pop()
        lowLen = lowerPoints.length
      }
      lowerPoints.push(points[i])
    }
  }
  const hull = []
  for (let i = 1; i < upperPoints.length - 1; i++) {
    hull.push(upperPoints[i])
  }
  for (let i = lowerPoints.length - 1; i >= 0; i--) {
    hull.push(lowerPoints[i])
  }

  return hull
}

export { convexHull }

// Example

// const points = [
//   { x: 0, y: 3 },
//   { x: 1, y: 1 },
//   { x: 2, y: 2 },
//   { x: 4, y: 4 },
//   { x: 0, y: 0 },
//   { x: 1, y: 2 },
//   { x: 3, y: 1 },
//   { x: 3, y: 3 }]

// convexHull(points)

--#

--% C:/work/algos/Javascript/Graphs/BellmanFord.js
/*
The BellmanFord algorithm is an algorithm that computes shortest paths
from a single source vertex to all of the other vertices in a weighted digraph.
It also detects negative weight cycle.

Complexity:
    Worst-case performance O(VE)
    Best-case performance O(E)
    Worst-case space complexity O(V)

Reference:
    https://en.wikipedia.org/wiki/BellmanFord_algorithm
    https://cp-algorithms.com/graph/bellman_ford.html

*/

/**
 *
 * @param graph Graph in the format (u, v, w) where
 *  the edge is from vertex u to v. And weight
 *  of the edge is w.
 * @param V Number of vertices in graph
 * @param E Number of edges in graph
 * @param src Starting node
 * @param dest Destination node
 * @returns Shortest distance from source to destination
 */
function BellmanFord (graph, V, E, src, dest) {
  // Initialize distance of all vertices as infinite.
  const dis = Array(V).fill(Infinity)
  // initialize distance of source as 0
  dis[src] = 0

  // Relax all edges |V| - 1 times. A simple
  // shortest path from src to any other
  // vertex can have at-most |V| - 1 edges
  for (let i = 0; i < V - 1; i++) {
    for (let j = 0; j < E; j++) {
      if ((dis[graph[j][0]] + graph[j][2]) < dis[graph[j][1]]) { dis[graph[j][1]] = dis[graph[j][0]] + graph[j][2] }
    }
  }
  // check for negative-weight cycles.
  for (let i = 0; i < E; i++) {
    const x = graph[i][0]
    const y = graph[i][1]
    const weight = graph[i][2]
    if ((dis[x] !== Infinity) && (dis[x] + weight < dis[y])) {
      return null
    }
  }
  for (let i = 0; i < V; i++) {
    if (i === dest) return dis[i]
  }
}

export { BellmanFord }

--#

--% C:/work/algos/Javascript/Graphs/BreadthFirstSearch.js
/**
 * Breadth-first search is an algorithm for traversing a graph.
 *
 * It discovers all nodes reachable from the starting position by exploring all of the neighbor nodes at the present
 * depth prior to moving on to the nodes at the next depth level.
 *
 * (description adapted from https://en.wikipedia.org/wiki/Breadth-first_search)
 * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core
 */
export function breadthFirstSearch (graph, startingNode) {
  // visited keeps track of all nodes visited
  const visited = new Set()

  // queue contains the nodes to be explored in the future
  const queue = [startingNode]

  while (queue.length > 0) {
    // start with the queue's first node
    const node = queue.shift()

    if (!visited.has(node)) {
      // mark the node as visited
      visited.add(node)
      const neighbors = graph[node]

      // put all its neighbors into the queue
      for (let i = 0; i < neighbors.length; i++) {
        queue.push(neighbors[i])
      }
    }
  }

  return visited
}

--#

--% C:/work/algos/Javascript/Graphs/BreadthFirstShortestPath.js
/**
 * Breadth-first approach can be applied to determine the shortest path between two nodes in an equi-weighted graph.
 *
 * It searches the target node among all neighbors of the starting node, then the process is repeated on the level of
 * the neighbors of the neighbors and so on.
 *
 * @see https://en.wikipedia.org/wiki/Breadth-first_search
 * @see https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core
 */
export function breadthFirstShortestPath (graph, startNode, targetNode) {
  // check if startNode & targetNode are identical
  if (startNode === targetNode) {
    return [startNode]
  }

  // visited keeps track of all nodes visited
  const visited = new Set()

  // queue contains the paths to be explored in the future
  const initialPath = [startNode]
  const queue = [initialPath]

  while (queue.length > 0) {
    // start with the queue's first path
    const path = queue.shift()
    const node = path[path.length - 1]

    // explore this node if it hasn't been visited yet
    if (!visited.has(node)) {
      // mark the node as visited
      visited.add(node)

      const neighbors = graph[node]

      // create a new path in the queue for each neighbor
      for (let i = 0; i < neighbors.length; i++) {
        const newPath = path.concat([neighbors[i]])

        // the first path to contain the target node is the shortest path
        if (neighbors[i] === targetNode) {
          return newPath
        }

        // queue the new path
        queue.push(newPath)
      }
    }
  }

  // the target node was not reachable
  return []
}

--#

--% C:/work/algos/Javascript/Graphs/ConnectedComponents.js
class GraphUnweightedUndirectedAdjacencyList {
  // Unweighted Undirected Graph class
  constructor () {
    this.connections = {}
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSComponent (components, node, visited) {
    // Helper function to populate the visited set with the nodes in each component

    // adding the first visited node in the component to the array
    components.push(node)
    const stack = [node]
    // populating the visited set using DFS (Iterative)
    while (stack.length > 0) {
      const curr = stack.pop()
      visited.add(curr.toString())
      for (const neighbour of this.connections[curr].keys()) {
        if (!visited.has(neighbour.toString())) { stack.push(neighbour) }
      }
    }
  }

  connectedComponents () {
    // Function to generate the Connected Components
    // Result is an array containing 1 node from each component
    const visited = new Set()
    const components = []
    for (const node of Object.keys(this.connections)) {
      if (!visited.has(node.toString())) { this.DFSComponent(components, node, visited) }
    }
    return components
  }
}

export { GraphUnweightedUndirectedAdjacencyList }

// Example

// const graph = new GraphUnweightedUndirectedAdjacencyList()
// graph.addEdge(1, 2) // Component 1
// graph.addEdge(3, 4) // Component 2
// graph.addEdge(3, 5) // Component 2
// const components = graph.connectedComponents()

--#

--% C:/work/algos/Javascript/Graphs/Density.js
/*
The density of a network is a measure of how many edges exist proportional to
how many edges would exist in a complete network (where all possible edges).
https://networkx.org/documentation/networkx-1.9/reference/generated/networkx.classes.function.density.html
*/
function density (numberOfNodes, numberOfEdges, isDirected = false) {
  const multi = isDirected ? 1 : 2
  return (multi * numberOfEdges) / (numberOfNodes * (numberOfNodes - 1))
}

export { density }

--#

--% C:/work/algos/Javascript/Graphs/DepthFirstSearchIterative.js
class GraphUnweightedUndirected {
  // Unweighted Undirected Graph class
  constructor () {
    this.connections = {}
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSIterative (node, value) {
    // DFS Function to search if a node with the given value is present in the graph
    const stack = [node]
    const visited = new Set()
    while (stack.length > 0) {
      const currNode = stack.pop()
      // if the current node contains the value being searched for, true is returned
      if (currNode === value) { return true }
      // adding the current node to the visited set
      visited.add(currNode)
      // adding neighbours in the stack
      for (const neighbour of this.connections[currNode]) {
        if (!visited.has(neighbour)) {
          stack.push(neighbour)
        }
      }
    }
    return false
  }
}

export { GraphUnweightedUndirected }

// Example

// const graph = new GraphUnweightedUndirected()
// graph.addEdge(1, 2)
// graph.addEdge(2, 3)
// graph.addEdge(2, 4)
// graph.addEdge(3, 5)
// graph.DFSIterative(5, 1)
// graph.DFSIterative(5, 100)

--#

--% C:/work/algos/Javascript/Graphs/DepthFirstSearchRecursive.js
class GraphUnweightedUndirected {
  // Unweighted Undirected Graph class
  constructor () {
    this.connections = {}
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = new Set()
  }

  addEdge (node1, node2) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1].add(node2)
    this.connections[node2].add(node1)
  }

  DFSRecursive (node, value, visited = new Set()) {
    // DFS Function to search if a node with the given value is present in the graph
    // checking if the searching node has been found
    if (node === value) { return true }
    // adding the current node to the visited set
    visited.add(node)
    // calling the helper function recursively for all unvisited nodes
    for (const neighbour of this.connections[node]) {
      if (!visited.has(neighbour)) {
        if (this.DFSRecursive(neighbour, value, visited)) { return true }
      }
    }
    return false
  }
}

export { GraphUnweightedUndirected }

// const graph = new GraphUnweightedUndirected()
// graph.addEdge(1, 2)
// graph.addEdge(2, 3)
// graph.addEdge(2, 4)
// graph.addEdge(3, 5)
// graph.DFSRecursive(5, 1)
// graph.DFSRecursive(5, 100)

--#

--% C:/work/algos/Javascript/Graphs/Dijkstra.js
/**
 * Author: Samarth Jain
 * Dijkstra's Algorithm implementation in JavaScript
 * Dijkstra's Algorithm calculates the minimum distance between two nodes.
 * It is used to find the shortest path.
 * It uses graph data structure.
 */

function createGraph (V, E) {
  // V - Number of vertices in graph
  // E - Number of edges in graph (u,v,w)
  const adjList = [] // Adjacency list
  for (let i = 0; i < V; i++) {
    adjList.push([])
  }
  for (let i = 0; i < E.length; i++) {
    adjList[E[i][0]].push([E[i][1], E[i][2]])
    adjList[E[i][1]].push([E[i][0], E[i][2]])
  }
  return adjList
}

function djikstra (graph, V, src) {
  const vis = Array(V).fill(0)
  const dist = []
  for (let i = 0; i < V; i++) dist.push([10000, -1])
  dist[src][0] = 0

  for (let i = 0; i < V - 1; i++) {
    let mn = -1
    for (let j = 0; j < V; j++) {
      if (vis[j] === 0) {
        if (mn === -1 || dist[j][0] < dist[mn][0]) mn = j
      }
    }

    vis[mn] = 1
    for (let j = 0; j < graph[mn].length; j++) {
      const edge = graph[mn][j]
      if (vis[edge[0]] === 0 && dist[edge[0]][0] > dist[mn][0] + edge[1]) {
        dist[edge[0]][0] = dist[mn][0] + edge[1]
        dist[edge[0]][1] = mn
      }
    }
  }

  return dist
}

export { createGraph, djikstra }

// const V = 9
// const E = [
//   [0, 1, 4],
//   [0, 7, 8],
//   [1, 7, 11],
//   [1, 2, 8],
//   [7, 8, 7],
//   [6, 7, 1],
//   [2, 8, 2],
//   [6, 8, 6],
//   [5, 6, 2],
//   [2, 5, 4],
//   [2, 3, 7],
//   [3, 5, 14],
//   [3, 4, 9],
//   [4, 5, 10]
// ]

// const graph = createGraph(V, E)
// const distances = djikstra(graph, V, 0)

/**
 * The first value in the array determines the minimum distance and the
 * second value represents the parent node from which the minimum distance has been calculated
 */

--#

--% C:/work/algos/Javascript/Graphs/DijkstraSmallestPath.js
// starting at s
function solve (graph, s) {
  const solutions = {}
  solutions[s] = []
  solutions[s].dist = 0

  while (true) {
    let p = null
    let neighbor = null
    let dist = Infinity

    for (const n in solutions) {
      if (!solutions[n]) { continue }
      const ndist = solutions[n].dist
      const adj = graph[n]

      for (const a in adj) {
        if (solutions[a]) { continue }

        const d = adj[a] + ndist
        if (d < dist) {
          p = solutions[n]
          neighbor = a
          dist = d
        }
      }
    }

    // no more solutions
    if (dist === Infinity) {
      break
    }

    // extend parent's solution path
    solutions[neighbor] = p.concat(neighbor)
    // extend parent's cost
    solutions[neighbor].dist = dist
  }

  return solutions
}

export { solve }

// // create graph
// const graph = {}

// const layout = {
//   R: ['2'],
//   2: ['3', '4'],
//   3: ['4', '6', '13'],
//   4: ['5', '8'],
//   5: ['7', '11'],
//   6: ['13', '15'],
//   7: ['10'],
//   8: ['11', '13'],
//   9: ['14'],
//   10: [],
//   11: ['12'],
//   12: [],
//   13: ['14'],
//   14: [],
//   15: []
// }

// // convert uni-directional to bi-directional graph
// let  graph = {
//     a: {e:1, b:1, g:3},
//     b: {a:1, c:1},
//     c: {b:1, d:1},
//     d: {c:1, e:1},
//     e: {d:1, a:1},
//     f: {g:1, h:1},
//     g: {a:3, f:1},
//     h: {f:1}
// };

// for (const id in layout) {
//   if (!graph[id]) { graph[id] = {} }
//   layout[id].forEach(function (aid) {
//     graph[id][aid] = 1
//     if (!graph[aid]) { graph[aid] = {} }
//     graph[aid][id] = 1
//   })
// }

// // choose start node
// const start = '10'
// // get all solutions
// const solutions = solve(graph, start)

// // for s in solutions..
// ' -> ' + s + ': [' + solutions[s].join(', ') + ']   (dist:' + solutions[s].dist + ')'

// From '10' to
//  -> 2: [7, 5, 4, 2]   (dist:4)
//  -> 3: [7, 5, 4, 3]   (dist:4)
//  -> 4: [7, 5, 4]   (dist:3)
//  -> 5: [7, 5]   (dist:2)
//  -> 6: [7, 5, 4, 3, 6]   (dist:5)
//  -> 7: [7]   (dist:1)
//  -> 8: [7, 5, 4, 8]   (dist:4)
//  -> 9: [7, 5, 4, 3, 13, 14, 9]   (dist:7)
//  -> 10: []   (dist:0)
//  -> 11: [7, 5, 11]   (dist:3)
//  -> 12: [7, 5, 11, 12]   (dist:4)
//  -> 13: [7, 5, 4, 3, 13]   (dist:5)
//  -> 14: [7, 5, 4, 3, 13, 14]   (dist:6)
//  -> 15: [7, 5, 4, 3, 6, 15]   (dist:6)
//  -> R: [7, 5, 4, 2, R]   (dist:5)

--#

--% C:/work/algos/Javascript/Graphs/FloydWarshall.js
/*
  Source:
    https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm

  Complexity:
    O(|V|^3) where V is the set of vertices
*/

const FloydWarshall = (dist) => {
  // Input:- dist: 2D Array where dist[i][j] = edge weight b/w i and j
  // Output:- dist: 2D Array where dist[i][j] = shortest dist b/w i and j
  const n = dist.length
  for (let k = 0; k < n; k++) {
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (dist[i][j] > dist[i][k] + dist[k][j]) {
          // dist from i to j via k is lesser than the current distance
          dist[i][j] = dist[i][k] + dist[k][j]
        }
      }
    }
  }
  return dist
}

export { FloydWarshall }

// For the following graph (edge weights are shown in brackets)
//  4       1       dist[1][2] = dist[2][1] = 1
//   \  (2)/ \      dist[1][3] = dist[3][1] = 2
//    \   /   \(1)  dist[1][4] = dist[4][1] = Infinity
//  (1)\ /     \    dist[3][4] = dist[4][3] = 1
//      3       2   dist[2][4] = dist[4][2] = Infinity
//                  dist[2][3] = dist[3][2] = Infinity
// Output should be:
// [ [0, 1, 2, 3],
//   [1, 0, 3, 4],
//   [2, 3, 0, 1],
//   [3, 4, 1, 0] ]

// FloydWarshall(
//     [[0, 1, 2, Infinity],
//       [1, 0, Infinity, Infinity],
//       [2, Infinity, 0, 1],
//       [Infinity, Infinity, 1, 0]
//     ]
//   )

--#

--% C:/work/algos/Javascript/Graphs/KruskalMST.js
class DisjointSetTreeNode {
  // Disjoint Set Node to store the parent and rank
  constructor (key) {
    this.key = key
    this.parent = this
    this.rank = 0
  }
}

class DisjointSetTree {
  // Disjoint Set DataStructure
  constructor () {
    // map to from node name to the node object
    this.map = {}
  }

  makeSet (x) {
    // Function to create a new set with x as its member
    this.map[x] = new DisjointSetTreeNode(x)
  }

  findSet (x) {
    // Function to find the set x belongs to (with path-compression)
    if (this.map[x] !== this.map[x].parent) {
      this.map[x].parent = this.findSet(this.map[x].parent.key)
    }
    return this.map[x].parent
  }

  union (x, y) {
    // Function to merge 2 disjoint sets
    this.link(this.findSet(x), this.findSet(y))
  }

  link (x, y) {
    // Helper function for union operation
    if (x.rank > y.rank) {
      y.parent = x
    } else {
      x.parent = y
      if (x.rank === y.rank) {
        y.rank += 1
      }
    }
  }
}

class GraphWeightedUndirectedAdjacencyList {
  // Weighted Undirected Graph class
  constructor () {
    this.connections = {}
    this.nodes = 0
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = {}
    this.nodes += 1
  }

  addEdge (node1, node2, weight) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1][node2] = weight
    this.connections[node2][node1] = weight
  }

  KruskalMST () {
    // Kruskal's Algorithm to generate a Minimum Spanning Tree (MST) of a graph
    // Details: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm
    // getting the edges in ascending order of weights
    const edges = []
    const seen = new Set()
    for (const start of Object.keys(this.connections)) {
      for (const end of Object.keys(this.connections[start])) {
        if (!seen.has(`${start} ${end}`)) {
          seen.add(`${end} ${start}`)
          edges.push([start, end, this.connections[start][end]])
        }
      }
    }
    edges.sort((a, b) => a[2] - b[2])
    // creating the disjoint set
    const disjointSet = new DisjointSetTree()
    Object.keys(this.connections).forEach(node => disjointSet.makeSet(node))
    // MST generation
    const graph = new GraphWeightedUndirectedAdjacencyList()
    let numEdges = 0
    let index = 0
    while (numEdges < this.nodes - 1) {
      const [u, v, w] = edges[index]
      index += 1
      if (disjointSet.findSet(u) !== disjointSet.findSet(v)) {
        numEdges += 1
        graph.addEdge(u, v, w)
        disjointSet.union(u, v)
      }
    }
    return graph
  }
}

export { GraphWeightedUndirectedAdjacencyList }

// const graph = new GraphWeightedUndirectedAdjacencyList()
// graph.addEdge(1, 2, 1)
// graph.addEdge(2, 3, 2)
// graph.addEdge(3, 4, 1)
// graph.addEdge(3, 5, 100) // Removed in MST
// graph.addEdge(4, 5, 5)
// graph.KruskalMST()

--#

--% C:/work/algos/Javascript/Graphs/NodeNeighbors.js
// https://en.wikipedia.org/wiki/Neighbourhood_(graph_theory)

class Graph {
  // Generic graph: the algorithm works regardless of direction or weight
  constructor () {
    this.edges = []
  }

  addEdge (node1, node2) {
    // Adding edges to the graph
    this.edges.push({
      node1,
      node2
    })
  }

  nodeNeighbors (node) {
    // Returns an array with all of the node neighbors
    const neighbors = new Set()
    for (const edge of this.edges) {
      // Checks if they have an edge between them and if the neighbor is not
      // already in the neighbors array
      if (edge.node1 === node && !(neighbors.has(edge.node2))) {
        neighbors.add(edge.node2)
      } else if (edge.node2 === node && !(neighbors.has(edge.node1))) {
        neighbors.add(edge.node1)
      }
    }
    return neighbors
  }
}

export { Graph }

// const graph = new Graph()
// graph.addEdge(1, 2)
// graph.addEdge(2, 3)
// graph.addEdge(3, 5)
// graph.addEdge(1, 5)
// graph.nodeNeighbors(1)

--#

--% C:/work/algos/Javascript/Graphs/NumberOfIslands.js
/* Number of Islands
https://dev.to/rattanakchea/amazons-interview-question-count-island-21h6
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

a two dimensional grid map
each element is going to represent a piece of land
1 is land,
0 is water
output a number which is the number of islands

Example 1:
  Input:
  11110
  11010
  11000
  00000

  Output: 1

Example 2:
  Input:
  11000
  11000
  00100
  00011

  Output: 3

I: two dimensional array
O: a single integer; total number of islands

Pseudocode:
  OUTER FUNCTION
    set count to 0

    INNER FUNCTION - flood (col, row)
      if the tile is water
        return
      make tile water(flood tile)
      invoke flood on the neighbor coordinates

    iterate over the matrix (col, row)
      if the current element is a 1
        increment count
        invoke flood (coordinates for col and row)

    Return the count
*/

const islands = (matrixGrid) => {
  const matrix = matrixGrid
  let counter = 0

  const flood = (row, col) => {
    if (row < 0 || col < 0) return // Off the map above or left
    if (row >= matrix.length || col >= matrix[row].length) return // Off the map below or right

    const tile = matrix[row][col]
    if (tile !== '1') return

    matrix[row][col] = '0'

    flood(row + 1, col) // Down
    flood(row - 1, col) // Up
    flood(row, col + 1) // Right
    flood(row, col - 1) // Left
  }

  for (let row = 0; row < matrix.length; row += 1) {
    for (let col = 0; col < matrix[row].length; col += 1) {
      const current = matrix[row][col]
      if (current === '1') {
        flood(row, col)
        counter += 1
      }
    }
  }
  return counter
}

export { islands }

// islands(
//   ['1', '1', '0', '0', '0'],
//   ['1', '1', '0', '0', '0'],
//   ['0', '0', '1', '0', '0'],
//   ['0', '0', '0', '1', '1']
// )

--#

--% C:/work/algos/Javascript/Graphs/PrimMST.js
// Priority Queue Helper functions
function getParentPosition (position) {
  // Get the parent node of the current node
  return Math.floor((position - 1) / 2)
}
function getChildrenPosition (position) {
  // Get the children nodes of the current node
  return [2 * position + 1, 2 * position + 2]
}

class PriorityQueue {
  // Priority Queue class using Minimum Binary Heap
  constructor () {
    this._heap = []
    this.keys = {}
  }

  isEmpty () {
    // Checking if the heap is empty
    return this._heap.length === 0
  }

  push (key, priority) {
    // Adding element to the queue (equivalent to add)
    this._heap.push([key, priority])
    this.keys[key] = this._heap.length - 1
    this._shiftUp(this.keys[key])
  }

  pop () {
    // Removing the element with least priority (equivalent to extractMin)
    this._swap(0, this._heap.length - 1)
    const [key] = this._heap.pop()
    delete this.keys[key]
    this._shiftDown(0)
    return key
  }

  contains (key) {
    // Check if a given key is present in the queue
    return (key in this.keys)
  }

  update (key, priority) {
    // Update the priority of the given element (equivalent to decreaseKey)
    const currPos = this.keys[key]
    this._heap[currPos][1] = priority
    const parentPos = getParentPosition(currPos)
    const currPriority = this._heap[currPos][1]
    let parentPriority = Infinity
    if (parentPos >= 0) {
      parentPriority = this._heap[parentPos][1]
    }
    const [child1Pos, child2Pos] = getChildrenPosition(currPos)
    let [child1Priority, child2Priority] = [Infinity, Infinity]
    if (child1Pos < this._heap.length) {
      child1Priority = this._heap[child1Pos][1]
    }
    if (child2Pos < this._heap.length) {
      child2Priority = this._heap[child2Pos][1]
    }

    if (parentPos >= 0 && parentPriority > currPriority) {
      this._shiftUp(currPos)
    } else if (child2Pos < this._heap.length &&
      (child1Priority < currPriority || child2Priority < currPriority)) {
      this._shiftDown(currPos)
    }
  }

  _shiftUp (position) {
    // Helper function to shift up a node to proper position (equivalent to bubbleUp)
    let currPos = position
    let parentPos = getParentPosition(currPos)
    let currPriority = this._heap[currPos][1]
    let parentPriority = Infinity
    if (parentPos >= 0) {
      parentPriority = this._heap[parentPos][1]
    }

    while (parentPos >= 0 && parentPriority > currPriority) {
      this._swap(currPos, parentPos)
      currPos = parentPos
      parentPos = getParentPosition(currPos)
      currPriority = this._heap[currPos][1]
      try {
        parentPriority = this._heap[parentPos][1]
      } catch (error) {
        parentPriority = Infinity
      }
    }
    this.keys[this._heap[currPos][0]] = currPos
  }

  _shiftDown (position) {
    // Helper function to shift down a node to proper position (equivalent to bubbleDown)
    let currPos = position
    let [child1Pos, child2Pos] = getChildrenPosition(currPos)
    let [child1Priority, child2Priority] = [Infinity, Infinity]
    if (child1Pos < this._heap.length) {
      child1Priority = this._heap[child1Pos][1]
    }
    if (child2Pos < this._heap.length) {
      child2Priority = this._heap[child2Pos][1]
    }
    let currPriority
    try {
      currPriority = this._heap[currPos][1]
    } catch {
      return
    }

    while (child2Pos < this._heap.length &&
      (child1Priority < currPriority || child2Priority < currPriority)) {
      if (child1Priority < currPriority && child1Priority < child2Priority) {
        this._swap(child1Pos, currPos)
        currPos = child1Pos
      } else {
        this._swap(child2Pos, currPos)
        currPos = child2Pos
      }
      [child1Pos, child2Pos] = getChildrenPosition(currPos)
      try {
        [child1Priority, child2Priority] = [this._heap[child1Pos][1], this._heap[child2Pos][1]]
      } catch (error) {
        [child1Priority, child2Priority] = [Infinity, Infinity]
      }

      currPriority = this._heap[currPos][1]
    }
    this.keys[this._heap[currPos][0]] = currPos
    if (child1Pos < this._heap.length && child1Priority < currPriority) {
      this._swap(child1Pos, currPos)
      this.keys[this._heap[child1Pos][0]] = child1Pos
    }
  }

  _swap (position1, position2) {
    // Helper function to swap 2 nodes
    [this._heap[position1], this._heap[position2]] = [this._heap[position2], this._heap[position1]]
    this.keys[this._heap[position1][0]] = position1
    this.keys[this._heap[position2][0]] = position2
  }
}

class GraphWeightedUndirectedAdjacencyList {
  // Weighted Undirected Graph class
  constructor () {
    this.connections = {}
  }

  addNode (node) {
    // Function to add a node to the graph (connection represented by set)
    this.connections[node] = {}
  }

  addEdge (node1, node2, weight) {
    // Function to add an edge (adds the node too if they are not present in the graph)
    if (!(node1 in this.connections)) { this.addNode(node1) }
    if (!(node2 in this.connections)) { this.addNode(node2) }
    this.connections[node1][node2] = weight
    this.connections[node2][node1] = weight
  }

  PrimMST (start) {
    // Prim's Algorithm to generate a Minimum Spanning Tree (MST) of a graph
    // Details: https://en.wikipedia.org/wiki/Prim%27s_algorithm
    const distance = {}
    const parent = {}
    const priorityQueue = new PriorityQueue()
    // Initialization
    for (const node in this.connections) {
      distance[node] = (node === start.toString() ? 0 : Infinity)
      parent[node] = null
      priorityQueue.push(node, distance[node])
    }
    // Updating 'distance' object
    while (!priorityQueue.isEmpty()) {
      const node = priorityQueue.pop()
      Object.keys(this.connections[node]).forEach(neighbour => {
        if (priorityQueue.contains(neighbour) && distance[node] + this.connections[node][neighbour] < distance[neighbour]) {
          distance[neighbour] = distance[node] + this.connections[node][neighbour]
          parent[neighbour] = node
          priorityQueue.update(neighbour, distance[neighbour])
        }
      })
    }

    // MST Generation from the 'parent' object
    const graph = new GraphWeightedUndirectedAdjacencyList()
    Object.keys(parent).forEach(node => {
      if (node && parent[node]) {
        graph.addEdge(node, parent[node], this.connections[node][parent[node]])
      }
    })
    return graph
  }
}

export { GraphWeightedUndirectedAdjacencyList }

// const graph = new GraphWeightedUndirectedAdjacencyList()
// graph.addEdge(1, 2, 1)
// graph.addEdge(2, 3, 2)
// graph.addEdge(3, 4, 1)
// graph.addEdge(3, 5, 100) // Removed in MST
// graph.addEdge(4, 5, 5)
// graph.PrimMST(1)

--#

--% C:/work/algos/Javascript/Graphs/test/BellmanFord.test.js
import { BellmanFord } from '../BellmanFord.js'

test('Test Case 1', () => {
  const V = 5
  const E = 8
  const destination = 3
  const graph = [[0, 1, -1], [0, 2, 4],
    [1, 2, 3], [1, 3, 2],
    [1, 4, 2], [3, 2, 5],
    [3, 1, 1], [4, 3, -3]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(-2)
})
test('Test Case 2', () => {
  const V = 6
  const E = 9
  const destination = 4
  const graph = [[0, 1, 3], [0, 3, 6],
    [0, 5, -1], [1, 2, -3],
    [1, 4, -2], [5, 2, 5],
    [2, 3, 1], [4, 3, 5], [5, 4, 2]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(1)
})
test('Test Case 3', () => {
  const V = 4
  const E = 5
  const destination = 1
  const graph = [[0, 3, -1], [0, 2, 4],
    [3, 2, 2], [3, 1, 5],
    [2, 1, -1]]
  const dist = BellmanFord(graph, V, E, 0, destination)
  expect(dist).toBe(0)
})

--#

--% C:/work/algos/Javascript/Graphs/test/BreadthFirstSearch.test.js
import { breadthFirstSearch } from '../BreadthFirstSearch'

describe('BreadthFirstSearch', () => {
  const graph = {
    A: ['B', 'D'],
    B: ['E'],
    C: ['D'],
    D: ['A'],
    E: ['D'],
    F: ['G'],
    G: []
  }
  /*
        A <-> B
             |
        |     |
        v     v
  C --> D <-- E

  F --> G
  */

  it('should return the visited nodes', () => {
    expect(Array.from(breadthFirstSearch(graph, 'C'))).toEqual(['C', 'D', 'A', 'B', 'E'])
    expect(Array.from(breadthFirstSearch(graph, 'A'))).toEqual(['A', 'B', 'D', 'E'])
    expect(Array.from(breadthFirstSearch(graph, 'F'))).toEqual(['F', 'G'])
  })
})

--#

--% C:/work/algos/Javascript/Graphs/test/BreadthFirstShortestPath.test.js
import { breadthFirstShortestPath } from '../BreadthFirstShortestPath'

describe('BreadthFirstShortestPath', () => {
  const graph = {
    A: ['B', 'D'],
    B: ['E'],
    C: ['D'],
    D: ['A'],
    E: ['D'],
    F: ['G'],
    G: []
  }
  /*
        A <-> B
             |
        |     |
        v     v
  C --> D <-- E

  F --> G
  */

  it('should return the visited nodes', () => {
    expect(breadthFirstShortestPath(graph, 'C', 'E')).toEqual(['C', 'D', 'A', 'B', 'E'])
    expect(breadthFirstShortestPath(graph, 'E', 'B')).toEqual(['E', 'D', 'A', 'B'])
    expect(breadthFirstShortestPath(graph, 'F', 'G')).toEqual(['F', 'G'])
    expect(breadthFirstShortestPath(graph, 'A', 'G')).toEqual([])
  })
})

--#

--% C:/work/algos/Javascript/Hashes/SHA1.js
//= ===============================================================
// SHA1.js
//
// Module that replicates the SHA-1 Cryptographic Hash
// function in Javascript.
//= ===============================================================

// main variables
const CHAR_SIZE = 8

/**
 * Adds padding to binary/hex string representation
 *
 * @param {string} str - string representation (binary/hex)
 * @param {int} bits - total number of bits wanted
 * @return {string} - string representation padding with empty (0) bits
 *
 * @example
 *      pad("10011", 8); // "00010011"
 */
function pad (str, bits) {
  let res = str
  while (res.length % bits !== 0) {
    res = '0' + res
  }
  return res
}

/**
 * Separates string into chunks of the same size
 *
 * @param {string} str - string to separate into chunks
 * @param {int} size - number of characters wanted in each chunk
 * @return {array} - array of original string split into chunks
 *
 * @example
 *      chunkify("this is a test", 2)
 */
function chunkify (str, size) {
  const chunks = []
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size))
  }
  return chunks
}

/**
 * Rotates string representation of bits to the left
 *
 * @param {string} bits - string representation of bits
 * @param {int} turns - number of rotations to make
 * @return {string} - string representation of bits after rotation
 *
 * @example
 *      rotateLeft("1011", 3); // "1101"
 */
function rotateLeft (bits, turns) {
  return bits.substr(turns) + bits.substr(0, turns)
}

/**
 * Pre-processes message to feed the algorithm loop
 *
 * @param {string} message - message to pre-process
 * @return {string} - processed message
 */
function preProcess (message) {
  // convert message to binary representation padded to
  // 8 bits, and add 1
  let m = message.split('')
    .map(e => e.charCodeAt(0))
    .map(e => e.toString(2))
    .map(e => pad(e, 8))
    .join('') + '1'

  // extend message by adding empty bits (0)
  while (m.length % 512 !== 448) {
    m += '0'
  }

  // length of message in binary, padded, and extended
  // to a 64 bit representation
  let ml = (message.length * CHAR_SIZE).toString(2)
  ml = pad(ml, 8)
  ml = '0'.repeat(64 - ml.length) + ml

  return m + ml
}

/**
 * Hashes message using SHA-1 Cryptographic Hash Function
 *
 * @param {string} message - message to hash
 * @return {string} - message digest (hash value)
 */
function SHA1 (message) {
  // main variables
  let H0 = 0x67452301
  let H1 = 0xEFCDAB89
  let H2 = 0x98BADCFE
  let H3 = 0x10325476
  let H4 = 0xC3D2E1F0

  // pre-process message and split into 512 bit chunks
  const bits = preProcess(message)
  const chunks = chunkify(bits, 512)

  chunks.forEach(function (chunk, i) {
    // break each chunk into 16 32-bit words
    const words = chunkify(chunk, 32)

    // extend 16 32-bit words to 80 32-bit words
    for (let i = 16; i < 80; i++) {
      const val = [words[i - 3], words[i - 8], words[i - 14], words[i - 16]]
        .map(e => parseInt(e, 2))
        .reduce((acc, curr) => curr ^ acc, 0)
      const bin = (val >>> 0).toString(2)
      const paddedBin = pad(bin, 32)
      const word = rotateLeft(paddedBin, 1)
      words.push(word)
    }

    // initialize variables for this chunk
    let [a, b, c, d, e] = [H0, H1, H2, H3, H4]

    for (let i = 0; i < 80; i++) {
      let f, k
      if (i < 20) {
        f = (b & c) | (~b & d)
        k = 0x5A827999
      } else if (i < 40) {
        f = b ^ c ^ d
        k = 0x6ED9EBA1
      } else if (i < 60) {
        f = (b & c) | (b & d) | (c & d)
        k = 0x8F1BBCDC
      } else {
        f = b ^ c ^ d
        k = 0xCA62C1D6
      }
      // make sure f is unsigned
      f >>>= 0

      const aRot = rotateLeft(pad(a.toString(2), 32), 5)
      const aInt = parseInt(aRot, 2) >>> 0
      const wordInt = parseInt(words[i], 2) >>> 0
      const t = aInt + f + e + k + wordInt
      e = d >>> 0
      d = c >>> 0
      const bRot = rotateLeft(pad(b.toString(2), 32), 30)
      c = parseInt(bRot, 2) >>> 0
      b = a >>> 0
      a = t >>> 0
    }

    // add values for this chunk to main hash variables (unsigned)
    H0 = (H0 + a) >>> 0
    H1 = (H1 + b) >>> 0
    H2 = (H2 + c) >>> 0
    H3 = (H3 + d) >>> 0
    H4 = (H4 + e) >>> 0
  })

  // combine hash values of main hash variables and return
  const HH = [H0, H1, H2, H3, H4]
    .map(e => e.toString(16))
    .map(e => pad(e, 8))
    .join('')

  return HH
}

// export SHA1 function
export { SHA1 }

--#

--% C:/work/algos/Javascript/Hashes/SHA256.js
//= ===============================================================
// SHA256.js
//
// Module that replicates the SHA-256 Cryptographic Hash
// function in Javascript.
//= ===============================================================

// main variables
const CHAR_SIZE = 8

const K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]

/**
 * Adds padding to binary/hex string representation
 *
 * @param {string} str - string representation (binary/hex)
 * @param {int} bits - total number of bits wanted
 * @return {string} - string representation padding with empty (0) bits
 *
 * @example
 *      pad("10011", 8); // "00010011"
 */
function pad (str, bits) {
  let res = str
  while (res.length % bits !== 0) {
    res = '0' + res
  }
  return res
}

/**
 * Separates string into chunks of the same size
 *
 * @param {string} str - string to separate into chunks
 * @param {int} size - number of characters wanted in each chunk
 * @return {array} - array of original string split into chunks
 *
 * @example
 *      chunkify("this is a test", 2)
 */
function chunkify (str, size) {
  const chunks = []
  for (let i = 0; i < str.length; i += size) {
    chunks.push(str.slice(i, i + size))
  }
  return chunks
}

/**
 * Rotates string representation of bits to th left
 *
 * @param {string} bits - string representation of bits
 * @param {int} turns - number of rotations to make
 * @return {string} - string representation of bits after rotation
 *
 * @example
 *      rotateLeft("1011", 3); // "1101"
 */
function rotateRight (bits, turns) {
  return bits.substr(bits.length - turns) + bits.substr(0, bits.length - turns)
}

/**
 * Pre-processes message to feed the algorithm loop
 *
 * @param {string} message - message to pre-process
 * @return {string} - processed message
 */
function preProcess (message) {
  // convert message to binary representation padded to
  // 8 bits, and add 1
  let m = message.split('')
    .map(e => e.charCodeAt(0))
    .map(e => e.toString(2))
    .map(e => pad(e, 8))
    .join('') + '1'

  // extend message by adding empty bits (0)
  while (m.length % 512 !== 448) {
    m += '0'
  }

  // length of message in binary, padded, and extended
  // to a 64 bit representation
  let ml = (message.length * CHAR_SIZE).toString(2)
  ml = pad(ml, 8)
  ml = '0'.repeat(64 - ml.length) + ml

  return m + ml
}

/**
 * Hashes message using SHA-256 Cryptographic Hash Function
 *
 * @param {string} message - message to hash
 * @return {string} - message digest (hash value)
 */
function SHA256 (message) {
  // initial hash variables
  let H0 = 0x6a09e667
  let H1 = 0xbb67ae85
  let H2 = 0x3c6ef372
  let H3 = 0xa54ff53a
  let H4 = 0x510e527f
  let H5 = 0x9b05688c
  let H6 = 0x1f83d9ab
  let H7 = 0x5be0cd19

  // pre-process message and split into 512 bit chunks
  const bits = preProcess(message)
  const chunks = chunkify(bits, 512)

  chunks.forEach(function (chunk, i) {
    // break each chunk into 16 32-bit words
    const words = chunkify(chunk, 32)

    // extend 16 32-bit words to 80 32-bit words
    for (let i = 16; i < 64; i++) {
      const W1 = words[i - 15]
      const W2 = words[i - 2]
      const R1 = rotateRight(W1, 7)
      const R2 = rotateRight(W1, 18)
      const R3 = rotateRight(W2, 17)
      const R4 = rotateRight(W2, 19)
      const S0 = parseInt(R1, 2) ^ parseInt(R2, 2) ^ (parseInt(W1, 2) >>> 3)
      const S1 = parseInt(R3, 2) ^ parseInt(R4, 2) ^ (parseInt(W2, 2) >>> 10)
      const val = parseInt(words[i - 16], 2) + S0 + parseInt(words[i - 7], 2) + S1
      words[i] = pad((val >>> 0).toString(2), 32)
    }

    // initialize variables for this chunk
    let [a, b, c, d, e, f, g, h] = [H0, H1, H2, H3, H4, H5, H6, H7]

    for (let i = 0; i < 64; i++) {
      const S1 = [6, 11, 25]
        .map(turns => rotateRight(pad(e.toString(2), 32), turns))
        .map(bitstring => parseInt(bitstring, 2))
        .reduce((acc, curr) => acc ^ curr, 0) >>> 0
      const CH = ((e & f) ^ (~e & g)) >>> 0
      const temp1 = (h + S1 + CH + K[i] + parseInt(words[i], 2)) >>> 0
      const S0 = [2, 13, 22]
        .map(turns => rotateRight(pad(a.toString(2), 32), turns))
        .map(bitstring => parseInt(bitstring, 2))
        .reduce((acc, curr) => acc ^ curr, 0) >>> 0
      const maj = ((a & b) ^ (a & c) ^ (b & c)) >>> 0
      const temp2 = (S0 + maj) >>> 0

      h = g
      g = f
      f = e
      e = (d + temp1) >>> 0
      d = c
      c = b
      b = a
      a = (temp1 + temp2) >>> 0
    }

    // add values for this chunk to main hash variables (unsigned)
    H0 = (H0 + a) >>> 0
    H1 = (H1 + b) >>> 0
    H2 = (H2 + c) >>> 0
    H3 = (H3 + d) >>> 0
    H4 = (H4 + e) >>> 0
    H5 = (H5 + f) >>> 0
    H6 = (H6 + g) >>> 0
    H7 = (H7 + h) >>> 0
  })

  // combine hash values of main hash variables and return
  const HH = [H0, H1, H2, H3, H4, H5, H6, H7]
    .map(e => e.toString(16))
    .map(e => pad(e, 8))
    .join('')

  return HH
}

// export SHA256 function
export { SHA256 }

--#

--% C:/work/algos/Javascript/Maths/Abs.js
/**
 * @function absVal
 * @description This script will find the absolute value of a number.
 * @param {Integer} num - The input integer
 * @return {Integer} - Absolute number of num.
 * @see [Absolute_value](https://en.wikipedia.org/wiki/Absolute_value)
 * @example absVal(-10) = 10
 * @example absVal(50) = 50
 * @example absVal(0) = 0
 */

const absVal = (num) => {
  // Find absolute value of `num`.
  'use strict'
  if (num < 0) {
    return -num
  }
  // Executes if condition is not met.
  return num
}

export { absVal }

--#

--% C:/work/algos/Javascript/Maths/AliquotSum.js
/*
  A program to calculate the Aliquot Sum of a number.
  The aliquot sum of a number n, is the sum of all the proper divisors of n apart from n itself
  For example, for the number 6
  The divisors are 1, 2, 3 (we don't consider 6), so its aliquot sum is 1 + 2 + 3 = 6
  1 is the only number whose aliquot sum is 0 (since its only divisor is 1 and aliquot sum of a number couldn't have itself)
  For all prime numbers, the aliquot sum is 1, since their only divisor apart from themselves is 1
  Article on Aliquot Sum: https://en.wikipedia.org/wiki/Aliquot_sum
 */

/**
 * @param {Number} input The number whose aliquot sum you want to calculate
 */
function aliquotSum (input) {
  // input can't be negative
  if (input < 0) throw new TypeError('Input cannot be Negative')

  // input can't be a decimal
  if (Math.floor(input) !== input) throw new TypeError('Input cannot be a Decimal')

  // Dealing with 1, which isn't a prime
  if (input === 1) return 0

  let sum = 0
  for (let i = 1; i <= (input / 2); i++) {
    if (input % i === 0) sum += i
  }

  return sum
}

export { aliquotSum }

--#

--% C:/work/algos/Javascript/Maths/Area.js
/*
  Calculate the area of various shapes
*/

/**
 * @function surfaceAreaCube
 * @description Calculate the Surface Area of a Cube.
 * @param {Integer} side - Integer
 * @return {Integer} - 6 * side ** 2
 * @see [surfaceAreaCube](https://en.wikipedia.org/wiki/Area#Surface_area)
 * @example surfaceAreaCube(1) = 6
 */
const surfaceAreaCube = (side) => {
  validateNumericParam(side, 'side')
  return 6 * side ** 2
}

/**
 * @function surfaceAreaSphere
 * @description Calculate the Surface Area of a Sphere.
 * @param {Integer} radius - Integer
 * @return {Integer} - 4 * pi * r^2
 * @see [surfaceAreaSphere](https://en.wikipedia.org/wiki/Sphere)
 * @example surfaceAreaSphere(5) = 314.1592653589793
 */
const surfaceAreaSphere = (radius) => {
  validateNumericParam(radius, 'radius')
  return 4.0 * Math.PI * radius ** 2.0
}

/**
 * @function areaRectangle
 * @description Calculate the area of a rectangle.
 * @param {Integer} length - Integer
 * @param {Integer} width - Integer
 * @return {Integer} - width * length
 * @see [areaRectangle](https://en.wikipedia.org/wiki/Area#Quadrilateral_area)
 * @example areaRectangle(4) = 16
 */
const areaRectangle = (length, width) => {
  validateNumericParam(length, 'Length')
  validateNumericParam(width, 'Width')
  return width * length
}

/**
 * @function areaSquare
 * @description Calculate the area of a square.
 * @param {Integer} side - Integer
 * @return {Integer} - side ** 2.
 * @see [areaSquare](https://en.wikipedia.org/wiki/Square)
 * @example areaSquare(4) = 16
 */
const areaSquare = (side) => {
  validateNumericParam(side, 'square side')
  return side ** 2
}

/**
 * @function areaTriangle
 * @description Calculate the area of a triangle.
 * @param {Integer} base - Integer
 * @param {Integer} height - Integer
 * @return {Integer} - base * height / 2.
 * @see [areaTriangle](https://en.wikipedia.org/wiki/Area#Triangle_area)
 * @example areaTriangle(1.66, 3.44) = 2.8552
 */
const areaTriangle = (base, height) => {
  validateNumericParam(base, 'Base')
  validateNumericParam(height, 'Height')
  return (base * height) / 2.0
}

/**
 * @function areaTriangleWithAllThreeSides
 * @description Calculate the area of a triangle with the all three sides given.
 * @param {Integer} side1 - Integer
 * @param {Integer} side2 - Integer
 * @param {Integer} side3 - Integer
 * @return {Integer} - area of triangle.
 * @see [areaTriangleWithAllThreeSides](https://en.wikipedia.org/wiki/Heron%27s_formula)
 * @example areaTriangleWithAllThreeSides(5, 6, 7) = 14.7
 */
const areaTriangleWithAllThreeSides = (side1, side2, side3) => {
  validateNumericParam(side1, 'side1')
  validateNumericParam(side2, 'side2')
  validateNumericParam(side3, 'side3')
  if (
    side1 + side2 <= side3 ||
    side1 + side3 <= side2 ||
    side2 + side3 <= side1
  ) {
    throw new TypeError('Invalid Triangle sides.')
  }
  // Finding Semi perimeter of the triangle using formula
  const semi = (side1 + side2 + side3) / 2

  // Calculating the area of the triangle
  const area = Math.sqrt(
    semi * (semi - side1) * (semi - side2) * (semi - side3)
  )
  return Number(area.toFixed(2))
}

/**
 * @function areaParallelogram
 * @description Calculate the area of a parallelogram.
 * @param {Integer} base - Integer
 * @param {Integer} height - Integer
 * @return {Integer} - base * height
 * @see [areaParallelogram](https://en.wikipedia.org/wiki/Area#Dissection,_parallelograms,_and_triangles)
 * @example areaParallelogram(5, 6) = 24
 */
const areaParallelogram = (base, height) => {
  validateNumericParam(base, 'Base')
  validateNumericParam(height, 'Height')
  return base * height
}

/**
 * @function areaTrapezium
 * @description Calculate the area of a trapezium.
 * @param {Integer} base1 - Integer
 * @param {Integer} base2 - Integer
 * @param {Integer} height - Integer
 * @return {Integer} - (1 / 2) * (base1 + base2) * height
 * @see [areaTrapezium](https://en.wikipedia.org/wiki/Trapezoid)
 * @example areaTrapezium(5, 12, 10) = 85
 */
const areaTrapezium = (base1, base2, height) => {
  validateNumericParam(base1, 'Base One')
  validateNumericParam(base2, 'Base Two')
  validateNumericParam(height, 'Height')
  return (1 / 2) * (base1 + base2) * height
}

/**
 * @function areaCircle
 * @description Calculate the area of a circle.
 * @param {Integer} radius - Integer
 * @return {Integer} - Math.PI * radius ** 2
 * @see [areaCircle](https://en.wikipedia.org/wiki/Area_of_a_circle)
 * @example areaCircle(5, 12, 10) = 85
 */
const areaCircle = (radius) => {
  validateNumericParam(radius, 'Radius')
  return Math.PI * radius ** 2
}

/**
 * @function areaRhombus
 * @description Calculate the area of a rhombus.
 * @param {Integer} diagonal1 - Integer
 * @param {Integer} diagonal2 - Integer
 * @return {Integer} - (1 / 2) * diagonal1 * diagonal2
 * @see [areaRhombus](https://en.wikipedia.org/wiki/Rhombus)
 * @example areaRhombus(12, 10) = 60
 */
const areaRhombus = (diagonal1, diagonal2) => {
  validateNumericParam(diagonal1, 'diagonal one')
  validateNumericParam(diagonal2, 'diagonal two')
  return (1 / 2) * diagonal1 * diagonal2
}

const validateNumericParam = (param, paramName = 'param') => {
  if (typeof param !== 'number') {
    throw new TypeError('The ' + paramName + ' should be type Number')
  } else if (param < 0) {
    throw new Error('The ' + paramName + ' only accepts non-negative values')
  }
}

export {
  surfaceAreaCube,
  surfaceAreaSphere,
  areaRectangle,
  areaSquare,
  areaTriangle,
  areaParallelogram,
  areaTrapezium,
  areaCircle,
  areaRhombus,
  areaTriangleWithAllThreeSides
}

--#

--% C:/work/algos/Javascript/Maths/ArmstrongNumber.js
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 * An Armstrong number is equal to the sum of its own digits each raised to the power of the number of digits.
 * For example, 370 is an Armstrong number because 3*3*3 + 7*7*7 + 0*0*0 = 370.
 * An Armstrong number is often called Narcissistic number.
 *
 */

const armstrongNumber = (num) => {
  if (num < 0 || typeof num !== 'number') return false

  let newSum = 0

  const numArr = num.toString().split('')
  numArr.forEach((num) => {
    newSum += parseInt(num) ** numArr.length
  })

  return newSum === num
}

export { armstrongNumber }

--#

--% C:/work/algos/Javascript/Maths/AverageMean.js
/**
 * @function mean
 * @description This script will find the mean value of a array of numbers.
 * @param {Integer[]} nums - Array of integer
 * @return {Integer} - mean of nums.
 * @see [Mean](hhttps://en.wikipedia.org/wiki/Mean)
 * @example mean([1, 2, 4, 5]) = 3
 * @example mean([10, 40, 100, 20]) = 42.5
 */

const mean = (nums) => {
  if (!Array.isArray(nums)) {
    throw new TypeError('Invalid Input')
  }

  // This loop sums all values in the 'nums' array using forEach loop
  const sum = nums.reduce((sum, cur) => sum + cur, 0)

  // Divide sum by the length of the 'nums' array.
  return sum / nums.length
}

export { mean }

--#

--% C:/work/algos/Javascript/Maths/AverageMedian.js
/*
 * Median: https://en.wikipedia.org/wiki/Median
 *
 * function averageMedian
 * to find the median value of an array of numbers
 * the numbers in an array will be sorted in ascending order by the function sortNumbers
 * if the length of the array is even number, the median value will be the average of the two middle numbers
 * else if the length of the array is odd number, the median value will be the middle number in the array
 */

const averageMedian = (sourceArrayOfNumbers) => {
  let numbers = [...sourceArrayOfNumbers]
  let median = 0
  const numLength = numbers.length
  numbers = numbers.sort(sortNumbers)

  if (numLength % 2 === 0) {
    median = (numbers[numLength / 2 - 1] + numbers[numLength / 2]) / 2
  } else {
    median = numbers[(numLength - 1) / 2]
  }

  return median
}

const sortNumbers = (num1, num2) => {
  return num1 - num2
}

export { averageMedian }

--#

--% C:/work/algos/Javascript/Maths/BinaryConvert.js
/**
 * @function BinaryConvert
 * @description Convert the decimal to binary.
 * @param {Integer} num - The input integer
 * @return {Integer} - Binary of num.
 * @see [BinaryConvert](https://www.programiz.com/javascript/examples/decimal-binary)
 * @example BinaryConvert(12) = 1100
 * @example BinaryConvert(12 + 2) = 1110
 */

const BinaryConvert = (num) => {
  let power = 1
  let binary = 0

  while (num) {
    const rem = num % 2
    num = Math.floor(num / 2)
    binary = rem * power + binary
    power *= 10
  }

  return binary
}

export { BinaryConvert }

--#

--% C:/work/algos/Javascript/Maths/BinaryExponentiationIterative.js
// To calculate x^n i.e. exponent(x, n) in O(log n) time in iterative way
// n is an integer and n >= 0

// Explanation: https://en.wikipedia.org/wiki/Exponentiation_by_squaring

// Examples:
// 2^3 = 8
// 5^0 = 1

// Uses the fact that
// exponent(x, n)
//          = exponent(x*x, floor(n/2))   ; if n is odd
//          = x*exponent(x*x, floor(n/2)) ; if n is even
const exponent = (x, n) => {
  let answer = 1
  while (n > 0) {
    if (n % 2 !== 0) answer *= x
    n = Math.floor(n / 2)
    if (n > 0) x *= x
  }
  return answer
}

export { exponent }

--#

--% C:/work/algos/Javascript/Maths/BinaryExponentiationRecursive.js
/*
  Modified from:
    https://github.com/TheAlgorithms/Python/blob/master/maths/binary_exponentiation.py

  Explanation:
    https://en.wikipedia.org/wiki/Exponentiation_by_squaring
*/

export const binaryExponentiation = (a, n) => {
  // input: a: int, n: int
  // returns: a^n: int
  if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return binaryExponentiation(a, n - 1) * a
  } else {
    const b = binaryExponentiation(a, n / 2)
    return b * b
  }
}

--#

--% C:/work/algos/Javascript/Maths/BisectionMethod.js
/**
 *
 * @file
 * @brief Find real roots of a function in a specified interval [a, b], where f(a)*f(b) < 0
 *
 * @details Given a function f(x) and an interval [a, b], where f(a) * f(b) < 0, find an approximation of the root
 * by calculating the middle m = (a + b) / 2, checking f(m) * f(a) and f(m) * f(b) and then by choosing the
 * negative product that means Bolzano's theorem is applied,, define the new interval with these points. Repeat until
 * we get the precision we want [Wikipedia](https://en.wikipedia.org/wiki/Bisection_method)
 *
 * @author [ggkogkou](https://github.com/ggkogkou)
 *
 */

const findRoot = (a, b, func, numberOfIterations) => {
  // Check if a given  real value belongs to the function's domain
  const belongsToDomain = (x, f) => {
    const res = f(x)
    return !Number.isNaN(res)
  }
  if (!belongsToDomain(a, func) || !belongsToDomain(b, func)) throw Error("Given interval is not a valid subset of function's domain")

  // Bolzano theorem
  const hasRoot = (a, b, func) => {
    return func(a) * func(b) < 0
  }
  if (hasRoot(a, b, func) === false) { throw Error('Product f(a)*f(b) has to be negative so that Bolzano theorem is applied') }

  // Declare m
  const m = (a + b) / 2

  // Recursion terminal condition
  if (numberOfIterations === 0) { return m }

  // Find the products of f(m) and f(a), f(b)
  const fm = func(m)
  const prod1 = fm * func(a)
  const prod2 = fm * func(b)

  // Depending on the sign of the products above, decide which position will m fill (a's or b's)
  if (prod1 > 0 && prod2 < 0) return findRoot(m, b, func, --numberOfIterations)
  else if (prod1 < 0 && prod2 > 0) return findRoot(a, m, func, --numberOfIterations)
  else throw Error('Unexpected behavior')
}

export { findRoot }

--#

--% C:/work/algos/Javascript/Maths/CheckKishnamurthyNumber.js
/*
    Problem statement and Explanation : https://www.geeksforgeeks.org/check-if-a-number-is-a-krishnamurthy-number-or-not-2/

    krishnamurthy number is a number the sum of the all factorial of the all dights is equal to the number itself.
    145 => 1! + 4! + 5! = 1  + 24 + 120 = 145
*/

// factorial utility method.
const factorial = (n) => {
  let fact = 1
  while (n !== 0) {
    fact = fact * n
    n--
  }
  return fact
}

/**
 * krishnamurthy number is a number the sum of the factorial of the all dights is equal to the number itself.
 * @param {Number} number a number for checking is krishnamurthy number or not.
 * @returns return correspond boolean value, if the number is krishnamurthy number return `true` else return `false`.
 * @example 145 => 1! + 4! + 5! = 1  + 24 + 120 = 145
 */
const CheckKishnamurthyNumber = (number) => {
  // firstly, check that input is a number or not.
  if (typeof number !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  // create a variable to store the sum of all digits factorial.
  let sumOfAllDigitFactorial = 0
  // convert the number to string for convenience.
  let newNumber = number
  // Extract number digits using the remainder method.
  while (newNumber > 0) {
    const lastDigit = newNumber % 10
    // calculate each digit factorial.
    sumOfAllDigitFactorial += factorial(lastDigit)
    newNumber = Math.floor(newNumber / 10)
  }
  // if the sumOftheFactorial is equal to the given number it means the number is a Krishnamurthy number.
  return sumOfAllDigitFactorial === number
}

export { CheckKishnamurthyNumber }

--#

--% C:/work/algos/Javascript/Maths/Coordinate.js
/*
 Calculate the mathematical properties involving coordinates
 Calculate the Distance Between 2 Points on a 2 Dimensional Plane
 Example: coorDistance(2,2,14,11) will return 15
 Wikipedia reference: https://en.wikipedia.org/wiki/Geographical_distance#Flat-surface_formulae
*/
const euclideanDistance = (longitude1, latitude1, longitude2, latitude2) => {
  const width = longitude2 - longitude1
  const height = latitude2 - latitude1
  return (Math.sqrt(width * width + height * height))
}

const manhattanDistance = (longitude1, latitude1, longitude2, latitude2) => {
  const width = Math.abs(longitude2 - longitude1)
  const height = Math.abs(latitude2 - latitude1)
  return width + height
}

export { euclideanDistance, manhattanDistance }

--#

--% C:/work/algos/Javascript/Maths/CoPrimeCheck.js
/*
    Problem statement and Explanation : https://en.wikipedia.org/wiki/Coprime_integers

    In number theory, two integers a and b are coprime, relatively prime or
    mutually prime if the only positive integer that is a divisor of both
    of them is Consequently, any prime number that divides one of a
    or b does not divide the other. This is equivalent to their greatest
    common divisor (gcd) being. One says also a is prime to b or a
    is coprime with b.
*/

// Here we use a GetEuclidGCD method as a utility.
const GetEuclidGCD = (arg1, arg2) => {
  let less = arg1 > arg2 ? arg2 : arg1
  for (less; less >= 2; less--) {
    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)
  }
  return (less)
}

// CoPrimeCheck function return the boolean in respect of the given number is co-prime or not.
/**
 * CoPrimeCheck function return the boolean in respect of the given number is co-prime or not.
 * @param {Number} firstNumber first number for checking is prime or not.
 * @param {Number} secondNumber second number for checking is prime or not.
 * @returns return correspond boolean value, if both number are co-prime return `true`, else return `false`.
 */
const CoPrimeCheck = (firstNumber, secondNumber) => {
  // firstly, check that input is a number or not.
  if (typeof firstNumber !== 'number' || typeof secondNumber !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  /*
    This is the most efficient algorithm for checking co-primes
    if the GCD of both the numbers is 1 that means they are co-primes.
    */
  return GetEuclidGCD(firstNumber, secondNumber) === 1
}

export { CoPrimeCheck }

--#

--% C:/work/algos/Javascript/Maths/DecimalIsolate.js
/*
 * function isolates the decimal part of a number.
 * Take the number and subtract it from the floored number.
 * Return the result.
 */

export const decimalIsolate = (number) => {
  const answer = parseFloat((number + '').replace(/^[-\d]+./, '.'))
  return isNaN(answer) === true ? 0 : answer
}

--#

--% C:/work/algos/Javascript/Maths/DegreeToRadian.js
/*
 * Radian : https://en.wikipedia.org/wiki/Radian
 * Degree : https://en.wikipedia.org/wiki/Degree_(angle)
 *
 * Angle in Radian = ( Angle in Degree ) x ( pi / 180 )
 *
 * Example :
 * Question : Convert 90 degree to radian
 * So, Angle in Degree = 90
 *
 * Solution :
 * Angle in Radian = ( 90 ) x ( pi / 180 ) = pi / 2
 *
 * So, 90 degree is equal to pi / 2 radian
 */

/**
 * @param {number} degree
 * @return {number}
 */
export const degreeToRadian = (degree) => {
  return degree * (Math.PI / 180)
}

--#

--% C:/work/algos/Javascript/Maths/EulerMethod.js
/**
 * In mathematics and computational science, the Euler method (also called forward Euler method) is a first-order
 * numerical procedure for solving ordinary differential equations (ODEs) with a given initial value. It is the most
 * basic explicit method for numerical integration of ordinary differential equations. The method proceeds in a series
 * of steps. At each step the y-value is calculated by evaluating the differential equation at the previous step,
 * multiplying the result with the step-size and adding it to the last y-value: y_n+1 = y_n + stepSize * f(x_n, y_n).
 *
 * (description adapted from https://en.wikipedia.org/wiki/Euler_method)
 * @see https://www.geeksforgeeks.org/euler-method-solving-differential-equation/
 */
export function eulerStep (xCurrent, stepSize, yCurrent, differentialEquation) {
  // calculates the next y-value based on the current value of x, y and the stepSize
  return yCurrent + stepSize * differentialEquation(xCurrent, yCurrent)
}

export function eulerFull (xStart, xEnd, stepSize, yStart, differentialEquation) {
  // loops through all the steps until xEnd is reached, adds a point for each step and then returns all the points
  const points = [{ x: xStart, y: yStart }]
  let yCurrent = yStart
  let xCurrent = xStart

  while (xCurrent < xEnd) {
    // Euler method for next step
    yCurrent = eulerStep(xCurrent, stepSize, yCurrent, differentialEquation)
    xCurrent += stepSize
    points.push({ x: xCurrent, y: yCurrent })
  }

  return points
}

--#

--% C:/work/algos/Javascript/Maths/EulersTotient.js
/*
  Source:
    https://en.wikipedia.org/wiki/Euler%27s_totient_function

  EulersTotient(n) = n * product(1 - 1/p for all prime p dividing n)

  Complexity:
    O(sqrt(n))
*/

export const EulersTotient = (n) => {
  // input: n: int
  // output: phi(n): count of numbers b/w 1 and n that are coprime to n
  let res = n
  for (let i = 2; i * i <= n; i++) {
    if (n % i === 0) {
      while (n % i === 0) {
        n = Math.floor(n / i)
      }
      // i is a prime diving n, multiply res by 1 - 1/i
      // res = res * (1 - 1/i) = res - (res / i)
      res = res - Math.floor(res / i)
    }
  }
  if (n > 1) {
    res = res - Math.floor(res / n)
  }
  return res
}

--#

--% C:/work/algos/Javascript/Maths/EulersTotientFunction.js
/*
    author sandyboypraper

    Here is the EulerTotientFunction.
    it is also represented by phi

    so EulersTotientFunction(n) (or phi(n)) is the count of numbers in {1,2,3,....,n} that are relatively
    prime to n, i.e., the numbers whose GCD (Greatest Common Divisor) with n is 1.
*/

const gcdOfTwoNumbers = (x, y) => {
  // x is smaller than y
  // let gcd of x and y is gcdXY
  // so it divides x and y completely
  // so gcdXY should also divide y%x (y = gcdXY*a and x = gcdXY*b and y%x = y - x*k so y%x = gcdXY(a - b*k))
  // and gcd(x,y) is equal to gcd(y%x , x)
  return x === 0 ? y : gcdOfTwoNumbers(y % x, x)
}

const eulersTotientFunction = (n) => {
  let countOfRelativelyPrimeNumbers = 1
  for (let iterator = 2; iterator <= n; iterator++) {
    if (gcdOfTwoNumbers(iterator, n) === 1) countOfRelativelyPrimeNumbers++
  }
  return countOfRelativelyPrimeNumbers
}

export { eulersTotientFunction }

--#

--% C:/work/algos/Javascript/Maths/ExtendedEuclideanGCD.js
/**
 * Problem statement and explanation: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
 *
 * This algorithm plays an important role for modular arithmetic, and by extension for cyptography algorithms
 *
 * Basic explanation:
 * The Extended Euclidean algorithm is a modification of the standard Euclidean GCD algorithm.
 * It allows to calculate coefficients x and y for the equation:
 *          ax + by = gcd(a,b)
 *
 * This is called Bzout's identity and the coefficients are called Bzout coefficients
 *
 * The algorithm uses the Euclidean method of getting remainder:
 * r_i+1 = r_i-1 - qi*ri
 * and applies it to series s and t (with same quotient q at each stage)
 * When r_n reaches 0, the value r_n-1 gives the gcd, and s_n-1 and t_n-1 give the coefficients
 *
 * This implementation uses an iterative approach to calculate the values
 */

/**
 *
 * @param {Number} arg1 first argument
 * @param {Number} arg2 second argument
 * @returns Array with GCD and first and second Bzout coefficients
 */
const extendedEuclideanGCD = (arg1, arg2) => {
  if (typeof arg1 !== 'number' || typeof arg2 !== 'number') throw new TypeError('Not a Number')
  if (arg1 < 1 || arg2 < 1) throw new TypeError('Must be positive numbers')

  // Make the order of coefficients correct, as the algorithm assumes r0 > r1
  if (arg1 < arg2) {
    const res = extendedEuclideanGCD(arg2, arg1)
    const temp = res[1]
    res[1] = res[2]
    res[2] = temp
    return res
  }

  // At this point arg1 > arg2

  // Remainder values
  let r0 = arg1
  let r1 = arg2

  // Coefficient1 values
  let s0 = 1
  let s1 = 0

  // Coefficient 2 values
  let t0 = 0
  let t1 = 1

  while (r1 !== 0) {
    const q = Math.floor(r0 / r1)

    const r2 = r0 - r1 * q
    const s2 = s0 - s1 * q
    const t2 = t0 - t1 * q

    r0 = r1
    r1 = r2
    s0 = s1
    s1 = s2
    t0 = t1
    t1 = t2
  }
  return [r0, s0, t0]
}

export { extendedEuclideanGCD }

--#

--% C:/work/algos/Javascript/Maths/Factorial.js
/*
    author: PatOnTheBack
    license: GPL-3.0 or later

    Modified from:
        https://github.com/TheAlgorithms/Python/blob/master/maths/factorial_python.py

    This script will find the factorial of a number provided by the user.

    More about factorials:
        https://en.wikipedia.org/wiki/factorial
*/

'use strict'

const calcRange = (num) => {
  return [...Array(num).keys()].map(i => i + 1)
}

const calcFactorial = (num) => {
  if (num === 0) {
    return 'The factorial of 0 is 1.'
  }
  if (num < 0) {
    return 'Sorry, factorial does not exist for negative numbers.'
  }
  if (!num) {
    return 'Sorry, factorial does not exist for null or undefined numbers.'
  }
  if (num > 0) {
    const range = calcRange(num)
    const factorial = range.reduce((a, c) => a * c, 1)
    return `The factorial of ${num} is ${factorial}`
  }
}

export { calcFactorial }

--#

--% C:/work/algos/Javascript/Maths/Factors.js
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 * More on Factors:
 *      https://www.mathsisfun.com/definitions/factor.html
 *
 */

const factorsOfANumber = (number = 0) => {
  return Array.from(Array(number + 1).keys()).filter(
    (num) => number % num === 0
  )
}

export { factorsOfANumber }

--#

--% C:/work/algos/Javascript/Maths/FareyApproximation.js
/*
* Reference: https://en.wikipedia.org/wiki/Farey_sequence
* Inspiration: https://www.youtube.com/watch?v=7LKy3lrkTRA
*
* Farey Approximation algorithm is an algorithm to
* approximate a reduced fraction value for a certain
* decimal number x where 0 < x < 1.
*
* The algorithm works by keeping two fractional upper and
* lower bounds which start at 0 / 1 and 1 / 1. These values
* are then used to find the "mediate" which is a value between
* the two fractions.
*
* For any two fractions a / b and c / d,
* mediate = a + c / b + d
*
* Then it is checked if the decimal is greater than or less
* than the mediate and then the lower or the upper value is
* set to be the mediate respectively.
*
* This is repeated for n times and then the mediate is
* returned.
*
* This is explained in a greater detail in the "Inspiration"
* link.
*/

function fareyApproximation (decimal, repeat = 20) {
  let a = 0; let b = 1; let c = 1; let d = 1; let numerator; let denominator

  for (let i = 0; i < repeat; i++) {
    numerator = a + c
    denominator = b + d

    if (decimal > numerator / denominator) {
      [a, b] = [numerator, denominator]
    } else {
      [c, d] = [numerator, denominator]
    }
  }

  return { numerator, denominator }
}

export { fareyApproximation }

--#

--% C:/work/algos/Javascript/Maths/FermatPrimalityTest.js
/*
 * The Fermat primality test is a probabilistic test to determine whether a number
 * is a probable prime.
 *
 * It relies on Fermat's Little Theorem, which states that if p is prime and a
 * is not divisible by p, then
 *
 *     a^(p - 1) % p = 1
 *
 * However, there are certain numbers (so called Fermat Liars) that screw things up;
 * if a is one of these liars the equation will hold even though p is composite.
 *
 * But not everything is lost! It's been proven that at least half of all integers
 * aren't Fermat Liars (these ones called Fermat Witnesses). Thus, if we keep
 * testing the primality with random integers, we can achieve higher reliability.
 *
 * The interesting about all of this is that since half of all integers are
 * Fermat Witnesses, the precision gets really high really fast! Suppose that we
 *  make the test 50 times: the chance of getting only Fermat Liars in all runs is
 *
 *     1 / 2^50 = 8.8 * 10^-16 (a pretty small number)
 *
 * For comparison, the probability of a cosmic ray causing an error to your
 * infalible program is around 1.4 * 10^-15. An order of magnitude below!
 *
 * But because nothing is perfect, there's a major flaw to this algorithm, and
 * the cause are the so called Carmichael Numbers. These are composite numbers n
 * that hold the equality from Fermat's Little Theorem for every a < n (excluding
 * is factors). In other words, if we are trying to determine if a Carmichael Number
 * is prime or not, the chances of getting a wrong answer are pretty high! Because
 * of that, the Fermat Primality Test is not used is serious applications. :(
 *
 * You can find more about the Fermat primality test and its flaws here:
 * https://en.wikipedia.org/wiki/Fermat_primality_test
 *
 * And about Carmichael Numbers here:
 * https://primes.utm.edu/glossary/xpage/CarmichaelNumber.html
 */

/**
 * Faster exponentiation that capitalize on the fact that we are only interested
 * in the modulus of the exponentiation.
 *
 * Find out more about it here: https://en.wikipedia.org/wiki/Modular_exponentiation
 *
 * @param {number} base
 * @param {number} exponent
 * @param {number} modulus
 */
const modularExponentiation = (base, exponent, modulus) => {
  if (modulus === 1) return 0 // after all, any x % 1 = 0

  let result = 1
  base %= modulus // make sure that base < modulus

  while (exponent > 0) {
    // if exponent is odd, multiply the result by the base
    if (exponent % 2 === 1) {
      result = (result * base) % modulus
      exponent--
    } else {
      exponent = exponent / 2 // exponent is even for sure
      base = (base * base) % modulus
    }
  }

  return result
}

/**
 * Test if a given number n is prime or not.
 *
 * @param {number} n The number to check for primality
 * @param {number} numberOfIterations The number of times to apply Fermat's Little Theorem
 * @returns True if prime, false otherwise
 */
const fermatPrimeCheck = (n, numberOfIterations = 50) => {
  // first check for edge cases
  if (n <= 1 || n === 4) return false
  if (n <= 3) return true // 2 and 3 are included here

  for (let i = 0; i < numberOfIterations; i++) {
    // pick a random number a, with 2 <= a < n - 2
    const randomNumber = Math.floor(Math.random() * (n - 2) + 2)

    // if a^(n - 1) % n is different than 1, n is composite
    if (modularExponentiation(randomNumber, n - 1, n) !== 1) {
      return false
    }
  }

  // if we arrived here without finding a Fermat Witness, this is almost guaranteed
  // to be a prime number (or a Carmichael number, if you are unlucky)
  return true
}

export { modularExponentiation, fermatPrimeCheck }

--#

--% C:/work/algos/Javascript/Maths/Fibonacci.js
const list = []

const FibonacciIterative = (nth) => {
  const sequence = []

  if (nth >= 1) sequence.push(1)
  if (nth >= 2) sequence.push(1)

  for (let i = 2; i < nth; i++) {
    sequence.push(sequence[i - 1] + sequence[i - 2])
  }

  return sequence
}

const FibonacciRecursive = (number) => {
  return (() => {
    switch (list.length) {
      case 0:
        list.push(1)
        return FibonacciRecursive(number)
      case 1:
        list.push(1)
        return FibonacciRecursive(number)
      case number:
        return list
      default:
        list.push(list[list.length - 1] + list[list.length - 2])
        return FibonacciRecursive(number)
    }
  })()
}

const dict = new Map()

const FibonacciRecursiveDP = (stairs) => {
  if (stairs <= 0) return 0
  if (stairs === 1) return 1

  // Memoize stair count
  if (dict.has(stairs)) return dict.get(stairs)

  const res =
    FibonacciRecursiveDP(stairs - 1) + FibonacciRecursiveDP(stairs - 2)

  dict.set(stairs, res)

  return res
}

// Algorithms
// Calculates Fibonacci(n) such that Fibonacci(n) = Fibonacci(n - 1) + Fibonacci(n - 2)
// Fibonacci(0) = Fibonacci(1) = 1
// Uses a bottom up dynamic programming approach
// Solve each sub-problem once, using results of previous sub-problems
// which are n-1 and n-2 for Fibonacci numbers
// Although this algorithm is linear in space and time as a function
// of the input value n, it is exponential in the size of n as
// a function of the number of input bits
// @Satzyakiz

const FibonacciDpWithoutRecursion = (number) => {
  const table = []
  table.push(1)
  table.push(1)
  for (let i = 2; i < number; ++i) {
    table.push(table[i - 1] + table[i - 2])
  }
  return table
}

// Using Matrix exponentiation to find n-th fibonacci in O(log n) time

const copyMatrix = (A) => {
  return A.map(row => row.map(cell => cell))
}

const Identity = (size) => {
  const I = Array(size).fill(null).map(() => Array(size).fill())
  return I.map((row, rowIdx) => row.map((_col, colIdx) => {
    return rowIdx === colIdx ? 1 : 0
  }))
}

// A of size (l x m) and B of size (m x n)
// product C will be of size (l x n)
const matrixMultiply = (A, B) => {
  A = copyMatrix(A)
  B = copyMatrix(B)
  const l = A.length
  const m = B.length
  const n = B[0].length // Assuming non-empty matrices
  const C = Array(l).fill(null).map(() => Array(n).fill())
  for (let i = 0; i < l; i++) {
    for (let j = 0; j < n; j++) {
      C[i][j] = 0
      for (let k = 0; k < m; k++) {
        C[i][j] += A[i][k] * B[k][j]
      }
    }
  }
  return C
}

/**
 * Computes A raised to the power n i.e. pow(A, n) where A is a square matrix
 * @param {*} A the square matrix
 * @param {*} n the exponent
 */
// A is a square matrix
const matrixExpo = (A, n) => {
  A = copyMatrix(A)

  // Just like Binary exponentiation mentioned in ./BinaryExponentiationIterative.js
  let result = Identity(A.length) // Identity matrix
  while (n > 0) {
    if (n % 2 !== 0) result = matrixMultiply(result, A)
    n = Math.floor(n / 2)
    if (n > 0) A = matrixMultiply(A, A)
  }
  return result
}

const FibonacciMatrixExpo = (n) => {
  // F(0) = 0, F(1) = 1
  // F(n) = F(n-1) + F(n-2)
  // Consider below matrix multiplication:

  // | F(n) |   |1  1|   |F(n-1)|
  // |      | = |    | * |      |
  // |F(n-1)|   |1  0|   |F(n-2)|

  // Let's rewrite it as F(n, n-1) = A * F(n-1, n-2)
  // or                  F(n, n-1) = A * A * F(n-2, n-3)
  // or                  F(n, n-1) = pow(A, n-1) * F(1, 0)

  if (n === 0) return 0

  const A = [
    [1, 1],
    [1, 0]
  ]
  const poweredA = matrixExpo(A, n - 1) // A raised to the power n-1
  let F = [
    [1],
    [0]
  ]
  F = matrixMultiply(poweredA, F)
  return F[0][0]
}

export { FibonacciDpWithoutRecursion }
export { FibonacciIterative }
export { FibonacciRecursive }
export { FibonacciRecursiveDP }
export { FibonacciMatrixExpo }

--#

--% C:/work/algos/Javascript/Maths/FigurateNumber.js
/**
 Problem Statement and Explanation :
 Triangular  => https://en.wikipedia.org/wiki/Triangular_number
 Tetrahedral => https://en.wikipedia.org/wiki/Tetrahedral_number
 Pentatope   => https://en.wikipedia.org/wiki/Pentatope_number

 Example:
 Triangular  => (0, 1, 3, 6, 10, 15, 21, 28, 36, 45)
 Tetrahedral => (1, 4, 10, 20, 35, 56, 84, 120, 165,)
 Pentatope   => (1, 5, 15, 35, 70, 126, 210, 330, 495)
 */

/**
 *
 * @param {*} number
 * @returns
 */
const isTriangular = (number) => {
  for (let i = 0; i <= number; i++) {
    if ((i * (i + 1)) / 2 === number) {
      return true
    } else if ((i * (i + 1)) / 2 > number) {
      return false
    }
  }
  return false
}

/**
 *
 * @param {*} number
 * @returns
 */
const isTetrahedral = (number) => {
  for (let i = 1; i <= number; i++) {
    if ((i * (i + 1) * (i + 2)) / 6 === number) {
      return true
    } else if ((i * (i + 1) * (i + 2)) / 6 > number) {
      return false
    }
  }
  return false
}
/**
 *
 * @param {*} number
 * @returns
 */
const isPentatope = (number) => {
  for (let i = 1; i <= number; i++) {
    if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 === number) {
      return true
    } else if ((i * (i + 1) * (i + 2) * (i + 3)) / 24 > number) {
      return false
    }
  }
  return false
}

/**
 *
 * @param {*} number
 * @returns
 */
const checkAll = (number) => {
  return {
    isTriangular: isTriangular(number),
    isTetrahedral: isTetrahedral(number),
    isPentatope: isPentatope(number)
  }
}
export { isTriangular }
export { isTetrahedral }
export { isPentatope }
export { checkAll }

--#

--% C:/work/algos/Javascript/Maths/FindHcf.js
/*
    author: redfly1
    More about HCF:
        https://en.wikipedia.org/wiki/Greatest_common_divisor
 */

const findHCF = (x, y) => {
  // If the input numbers are less than 1 return an error message.
  if (x < 1 || y < 1) {
    return 'Please enter values greater than zero.'
  }

  // If the input numbers are not integers return an error message.
  if (x !== Math.round(x) || y !== Math.round(y)) {
    return 'Please enter whole numbers.'
  }

  // Now apply Euclid's algorithm to the two numbers.
  while (Math.max(x, y) % Math.min(x, y) !== 0) {
    if (x > y) {
      x %= y
    } else {
      y %= x
    }
  }

  // When the while loop finishes the minimum of x and y is the HCF.
  return Math.min(x, y)
}

export { findHCF }

--#

--% C:/work/algos/Javascript/Maths/FindLcm.js
/*
    author: PatOnTheBack
    license: GPL-3.0 or later

    Modified from:
        https://github.com/TheAlgorithms/Python/blob/master/maths/findLcm.py

    More about LCM:
        https://en.wikipedia.org/wiki/Least_common_multiple
*/

'use strict'

// Find the LCM of two numbers.
const findLcm = (num1, num2) => {
  // If the input numbers are less than 1 return an error message.
  if (num1 < 1 || num2 < 1) {
    return 'Please enter values greater than zero.'
  }

  // If the input numbers are not integers return an error message.
  if (num1 !== Math.round(num1) || num2 !== Math.round(num2)) {
    return 'Please enter whole numbers.'
  }

  let maxNum
  let lcm
  // Check to see whether num1 or num2 is larger.
  if (num1 > num2) {
    maxNum = num1
  } else {
    maxNum = num2
  }
  lcm = maxNum

  while (true) {
    if (lcm % num1 === 0 && lcm % num2 === 0) break
    lcm += maxNum
  }
  return lcm
}

export { findLcm }

--#

--% C:/work/algos/Javascript/Maths/FindMin.js
/**
 * @function FindMin
 * @description Function to find the minimum number given in an array of integers.
 * @param {Integer[]} nums - Array of Integers
 * @return {Integer} - The minimum number of the array.
 */

const findMin = (...nums) => {
  if (nums.length === 0) {
    throw new TypeError('Array is empty')
  }

  let min = nums[0]
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] < min) {
      min = nums[i]
    }
  }

  return min
}

export { findMin }

--#

--% C:/work/algos/Javascript/Maths/GetEuclidGCD.js
/*
    Problem statement and Explanation : https://en.wikipedia.org/wiki/Euclidean_algorithm

    In this method, we have followed the iterative approach to first
    find a minimum of both numbers and go to the next step.
*/

/**
 * GetEuclidGCD return the gcd of two numbers using Euclidean algorithm.
 * @param {Number} arg1 first argument for gcd
 * @param {Number} arg2 second argument for gcd
 * @returns return a `gcd` value of both number.
 */
const GetEuclidGCD = (arg1, arg2) => {
  // firstly, check that input is a number or not.
  if (typeof arg1 !== 'number' || typeof arg2 !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  // check that the input number is not a negative value.
  if (arg1 < 1 || arg2 < 1) {
    return new TypeError('Argument is a negative number.')
  }
  // Find a minimum of both numbers.
  let less = arg1 > arg2 ? arg2 : arg1
  // Iterate the number and find the gcd of the number using the above explanation.
  for (less; less >= 2; less--) {
    if ((arg1 % less === 0) && (arg2 % less === 0)) return (less)
  }
  return (less)
}

export { GetEuclidGCD }

--#

--% C:/work/algos/Javascript/Maths/GridGet.js
/*
    author: TangibleDream
    license: GPL-3.0 or later

    These methods will find x or y given the element and columns for a 2 dimensional array.

    If your array is a perfect square, you can find columns by getting the square
    root of the length of the array.

    Let's say for instance you had an array of 10 by 10 or 100, elements and you wanted to
    find the shortest distance between element 3, and element 49. In this case coding out
    a function to return the distance without finding x and y for both elements I found to
    be painful. If you first find x and y, where 3 becomes 4,1 and 49 becomes 10,5, you can
    find distance by first subtracting x from x and y from y this returns 6,4 or -6,-4.
    Next apply absolute value to assure the results are positive,
    last choose the maximum value of the set, or 6.

    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  | 3|  |  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |49|
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |  |

    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  | 3|  |  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  | 1|  |  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  | 2|  |  |  |  |
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  | 3| 4| 5|6!|
    +--+--+--+--+--+--+--+--+--+--+
    |  |  |  |  |  |  |  |  |  |  |

*/

const gridGetX = (columns, index) => {
  while (index + 1 > columns) {
    index = index - columns
  }
  return index + 1
}

const gridGetY = (columns, index) => {
  return Math.floor(index / columns) + 1
}

export { gridGetX, gridGetY }

--#

--% C:/work/algos/Javascript/Maths/IsDivisible.js
// Checks if a number is divisible by another number.

export const isDivisible = (num1, num2) => {
  if (!Number.isFinite(num1) || !Number.isFinite(num2)) {
    throw new TypeError('Expected a number')
  }
  if (num2 === 0) {
    return false
  }
  return num1 % num2 === 0
}

// isDivisible(10, 5) // returns true
// isDivisible(123498175, 5) // returns true
// isDivisible(99, 5) // returns false

--#

--% C:/work/algos/Javascript/Maths/IsEven.js
/*
 * Even Number: https://simple.wikipedia.org/wiki/Even_number
 *
 * function to check if number is even
 * return true if number is even
 * else false
 */

/**
 * @param {number} number
 * @return {boolean}
 */

/*
 * Checking if number is even using divisibility by 2
 *
 * If number is divisible by 2 i.e remainder = 0, then it is even
 * therefore, the function will return true
 *
 * If number is not divisible by 2 i.e remainder != 0, then it is not even i.e odd
 * therefore, the function will return false
 */

export const isEven = (number) => {
  return number % 2 === 0
}

/*
 * Checking if number is even using bitwise operator
 *
 * Bitwise AND (&) compares the bits of the 32
 * bit binary representations of the number and
 * returns a number after comparing each bit:
 *
 * 0 & 0 -> 0
 * 0 & 1 -> 0
 * 1 & 0 -> 0
 * 1 & 1 -> 1
 *
 * For odd numbers, the last binary bit will be 1
 * and for even numbers, the last binary bit will
 * be 0.
 *
 * As the number is compared with one, all the
 * other bits except the last will become 0. The
 * last bit will be 0 for even numbers and 1 for
 * odd numbers, which is checked with the use
 * of the equality operator.
 *
 * References:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND
 */

export const isEvenBitwise = (number) => {
  return (number & 1) === 0
}

--#

--% C:/work/algos/Javascript/Maths/IsOdd.js
/*
 * function to check if number is odd
 * return true if number is odd
 * else false
 */

export const isOdd = (value) => {
  return !!((value & 1))
}

--#

--% C:/work/algos/Javascript/Maths/LeapYear.js
/**
 * isLeapYear :: Number -> Boolean
 *
 * Check if a year is a leap year or not. A leap year is a year which has 366 days.
 * For the extra +1 day the February month contains 29 days instead of 28 days.
 *
 * The logic behind the leap year is-
 * 1. If the year is divisible by 400 then it is a leap year.
 * 2. If it is not divisible by 400 but divisible by 100 then it is not a leap year.
 * 3. If the year is not divisible by 400 but not divisible by 100 and divisible by 4 then a leap year.
 * 4. Other cases except the describing ones are not a leap year.
 *
 * @param {number} year
 * @returns {boolean} true if this is a leap year, false otherwise.
 */
export const isLeapYear = (year) => {
  if (year % 400 === 0) return true
  if (year % 100 === 0) return false
  if (year % 4 === 0) return true

  return false
}

--#

--% C:/work/algos/Javascript/Maths/LinearSieve.js
const LinearSieve = (n) => {
  /*
   * Calculates prime numbers till a number n
   * Time Complexity: O(n)
   * Explanation: https://cp-algorithms.com/algebra/prime-sieve-linear.html
   * :param n: Number up to which to calculate primes
   * :return: A list containing only primes
   */
  const isnPrime = new Array(n + 1)
  isnPrime[0] = isnPrime[1] = true
  const primes = []
  for (let i = 2; i <= n; i++) {
    if (!isnPrime[i]) primes.push(i)
    for (const p of primes) {
      const k = i * p
      if (k > n) break
      isnPrime[k] = true
      if (i % p === 0) break
    }
  }
  return primes
}

export { LinearSieve }

--#

--% C:/work/algos/Javascript/Maths/LucasSeries.js
/*
  Program to get the Nth Lucas Number
  Article on Lucas Number: https://en.wikipedia.org/wiki/Lucas_number
  Examples:
    > loopLucas(1)
    1
    > loopLucas(20)
    15127
    > loopLucas(100)
    792070839848372100000
*/

/**
 * @param {Number} index The position of the number you want to get from the Lucas Series
 */
function lucas (index) {
  // index can't be negative
  if (index < 0) throw new TypeError('Index cannot be Negative')

  // index can't be a decimal
  if (Math.floor(index) !== index) throw new TypeError('Index cannot be a Decimal')

  let a = 2
  let b = 1
  for (let i = 0; i < index; i++) {
    const temp = a + b
    a = b
    b = temp
  }
  return a
}

export { lucas }

--#

--% C:/work/algos/Javascript/Maths/Mandelbrot.js
/**
 * Method to generate the image of the Mandelbrot set.
 *
 * Two types of coordinates are used: image-coordinates that refer to the pixels and figure-coordinates that refer to
 * the complex numbers inside and outside the Mandelbrot set. The figure-coordinates in the arguments of this method
 * determine which section of the Mandelbrot set is viewed. The main area of the Mandelbrot set is roughly between
 * "-1.5 < x < 0.5" and "-1 < y < 1" in the figure-coordinates.
 *
 * The Mandelbrot set is the set of complex numbers "c" for which the series "z_(n+1) = z_n * z_n + c" does not diverge,
 * i.e. remains bounded. Thus, a complex number "c" is a member of the Mandelbrot set if, when starting with "z_0 = 0"
 * and applying the iteration repeatedly, the absolute value of "z_n" remains bounded for all "n > 0". Complex numbers
 * can be written as "a + b*i": "a" is the real component, usually drawn on the x-axis, and "b*i" is the imaginary
 * component, usually drawn on the y-axis. Most visualizations of the Mandelbrot set use a color-coding to indicate
 * after how many steps in the series the numbers outside the set cross the divergence threshold. Images of the
 * Mandelbrot set exhibit an elaborate and infinitely complicated boundary that reveals progressively ever-finer
 * recursive detail at increasing magnifications, making the boundary of the Mandelbrot set a fractal curve.
 *
 * (description adapted from https://en.wikipedia.org/wiki/Mandelbrot_set)
 * @see https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set
 *
 * @param {number} imageWidth The width of the rendered image.
 * @param {number} imageHeight The height of the rendered image.
 * @param {number} figureCenterX The x-coordinate of the center of the figure.
 * @param {number} figureCenterY The y-coordinate of the center of the figure.
 * @param {number} figureWidth The width of the figure.
 * @param {number} maxStep Maximum number of steps to check for divergent behavior.
 * @param {boolean} useDistanceColorCoding Render in color or black and white.
 * @return {object} The RGB-data of the rendered Mandelbrot set.
 */
export function getRGBData (
  imageWidth = 800,
  imageHeight = 600,
  figureCenterX = -0.6,
  figureCenterY = 0,
  figureWidth = 3.2,
  maxStep = 50,
  useDistanceColorCoding = true) {
  if (imageWidth <= 0) {
    throw new Error('imageWidth should be greater than zero')
  }

  if (imageHeight <= 0) {
    throw new Error('imageHeight should be greater than zero')
  }

  if (maxStep <= 0) {
    throw new Error('maxStep should be greater than zero')
  }

  const rgbData = []
  const figureHeight = figureWidth / imageWidth * imageHeight

  // loop through the image-coordinates
  for (let imageX = 0; imageX < imageWidth; imageX++) {
    rgbData[imageX] = []
    for (let imageY = 0; imageY < imageHeight; imageY++) {
      // determine the figure-coordinates based on the image-coordinates
      const figureX = figureCenterX + (imageX / imageWidth - 0.5) * figureWidth
      const figureY = figureCenterY + (imageY / imageHeight - 0.5) * figureHeight

      const distance = getDistance(figureX, figureY, maxStep)

      // color the corresponding pixel based on the selected coloring-function
      rgbData[imageX][imageY] =
        useDistanceColorCoding
          ? colorCodedColorMap(distance)
          : blackAndWhiteColorMap(distance)
    }
  }

  return rgbData
}

/**
 * Black and white color-coding that ignores the relative distance.
 *
 * The Mandelbrot set is black, everything else is white.
 *
 * @param {number} distance Distance until divergence threshold
 * @return {object} The RGB-value corresponding to the distance.
 */
function blackAndWhiteColorMap (distance) {
  return distance >= 1 ? [0, 0, 0] : [255, 255, 255]
}

/**
 * Color-coding taking the relative distance into account.
 *
 * The Mandelbrot set is black.
 *
 * @param {number} distance Distance until divergence threshold
 * @return {object} The RGB-value corresponding to the distance.
 */
function colorCodedColorMap (distance) {
  if (distance >= 1) {
    return [0, 0, 0]
  } else {
    // simplified transformation of HSV to RGB
    // distance determines hue
    const hue = 360 * distance
    const saturation = 1
    const val = 255
    const hi = (Math.floor(hue / 60)) % 6
    const f = hue / 60 - Math.floor(hue / 60)

    const v = val
    const p = 0
    const q = Math.floor(val * (1 - f * saturation))
    const t = Math.floor(val * (1 - (1 - f) * saturation))

    switch (hi) {
      case 0:
        return [v, t, p]
      case 1:
        return [q, v, p]
      case 2:
        return [p, v, t]
      case 3:
        return [p, q, v]
      case 4:
        return [t, p, v]
      default:
        return [v, p, q]
    }
  }
}

/**
 * Return the relative distance (ratio of steps taken to maxStep) after which the complex number
 * constituted by this x-y-pair diverges.
 *
 * Members of the Mandelbrot set do not diverge so their distance is 1.
 *
 * @param {number} figureX The x-coordinate within the figure.
 * @param {number} figureY The y-coordinate within the figure.
 * @param {number} maxStep Maximum number of steps to check for divergent behavior.
 * @return {number} The relative distance as the ratio of steps taken to maxStep.
 */
function getDistance (figureX, figureY, maxStep) {
  let a = figureX
  let b = figureY
  let currentStep = 0
  for (let step = 0; step < maxStep; step++) {
    currentStep = step
    const aNew = a * a - b * b + figureX
    b = 2 * a * b + figureY
    a = aNew

    // divergence happens for all complex number with an absolute value
    // greater than 4 (= divergence threshold)
    if (a * a + b * b > 4) {
      break
    }
  }
  return currentStep / (maxStep - 1)
}

--#

--% C:/work/algos/Javascript/Maths/MatrixExponentiationRecursive.js
/*
  Source:
    https://en.wikipedia.org/wiki/Exponentiation_by_squaring

  Complexity:
    O(d^3 log n)
    where: d is the dimension of the square matrix
           n is the power the matrix is raised to
*/

const Identity = (n) => {
  // Input: n: int
  // Output: res: Identity matrix of size n x n
  // Complexity: O(n^2)
  const res = []
  for (let i = 0; i < n; i++) {
    res[i] = []
    for (let j = 0; j < n; j++) {
      res[i][j] = i === j ? 1 : 0
    }
  }
  return res
}

const MatMult = (matrixA, matrixB) => {
  // Input: matrixA: 2D Array of Numbers of size n x n
  //        matrixB: 2D Array of Numbers of size n x n
  // Output: matrixA x matrixB: 2D Array of Numbers of size n x n
  // Complexity: O(n^3)
  const n = matrixA.length
  const matrixC = []
  for (let i = 0; i < n; i++) {
    matrixC[i] = []
    for (let j = 0; j < n; j++) {
      matrixC[i][j] = 0
    }
  }
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++) {
        matrixC[i][j] += matrixA[i][k] * matrixB[k][j]
      }
    }
  }
  return matrixC
}

export const MatrixExponentiationRecursive = (mat, m) => {
  // Input: mat: 2D Array of Numbers of size n x n
  // Output: mat^n: 2D Array of Numbers of size n x n
  // Complexity: O(n^3 log m)
  if (m === 0) {
    // return identity matrix of size n x n
    return Identity(mat.length)
  } else if (m % 2 === 1) {
    // tmp = mat ^ m-1
    const tmp = MatrixExponentiationRecursive(mat, m - 1)
    /// return tmp * mat = (mat ^ m-1) * mat = mat ^ m
    return MatMult(tmp, mat)
  } else {
    // tmp = mat ^ m/2
    const tmp = MatrixExponentiationRecursive(mat, m >> 1)
    // return tmp * tmp = (mat ^ m/2) ^ 2 = mat ^ m
    return MatMult(tmp, tmp)
  }
}

// const mat = [[1, 0, 2], [2, 1, 0], [0, 2, 1]]

// // mat ^ 0 = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
// MatrixExponentiationRecursive(mat, 0)

// // mat ^ 1 = [ [ 1, 0, 2 ], [ 2, 1, 0 ], [ 0, 2, 1 ] ]
// MatrixExponentiationRecursive(mat, 1)

// // mat ^ 2 = [ [ 1, 4, 4 ], [ 4, 1, 4 ], [ 4, 4, 1 ] ]
// MatrixExponentiationRecursive(mat, 2)

// // mat ^ 5 = [ [ 1, 4, 4 ], [ 4, 1, 4 ], [ 4, 4, 1 ] ]
// MatrixExponentiationRecursive(mat, 5)

--#

--% C:/work/algos/Javascript/Maths/MatrixMultiplication.js
// Wikipedia URL for General Matrix Multiplication Concepts: https://en.wikipedia.org/wiki/Matrix_multiplication

// This algorithm has multiple functions that ultimately check if the inputs are actually matrices and if two Matrices (that can be different sizes) can be multiplied together.
// matrices that are of the same size [2x2]x[2x2], and the second is the multiplication of two matrices that are not the same size [2x3]x[3x2].

// MatrixCheck tests to see if all of the rows of the matrix inputted have similar size columns
const matrixCheck = (matrix) => {
  let columnNumb
  for (let index = 0; index < matrix.length; index++) {
    if (index === 0) {
      columnNumb = matrix[index].length
    } else if (matrix[index].length !== columnNumb) {
      // The columns in this array are not equal
    } else {
      return columnNumb
    }
  }
}

// tests to see if the matrices have a like side, i.e. the row length on the first matrix matches the column length on the second matrix, or vice versa.
const twoMatricesCheck = (first, second) => {
  const [firstRowLength, secondRowLength, firstColLength, secondColLength] = [first.length, second.length, matrixCheck(first), matrixCheck(second)]
  if (firstRowLength !== secondColLength || secondRowLength !== firstColLength) {
    // These matrices do not have a common side
    return false
  } else {
    return true
  }
}

// returns an empty array that has the same number of rows as the left matrix being multiplied.
// Uses Array.prototype.map() to loop over the first (or left) matrix and returns an empty array on each iteration.
const initiateEmptyArray = (first, second) => {
  if (twoMatricesCheck(first, second)) {
    const emptyArray = first.map(() => {
      return ['']
    })
    return emptyArray
  } else {
    return false
  }
}

// Finally, `matrixMult` uses `Array.prototype.push()`, multiple layers of nested `for` loops, the addition assignment `+=` operator and multiplication operator `*` to perform the dot product between two matrices of differing sizes.
// Dot product, takes the row of the first matrix and multiplies it by the column of the second matrix, the `twoMatricesCheck` tested to see if they were the same size already.
// The dot product for each iteration is then saved to its respective index into `multMatrix`.
export const matrixMult = (firstArray, secondArray) => {
  const multMatrix = initiateEmptyArray(firstArray, secondArray)
  for (let rm = 0; rm < firstArray.length; rm++) {
    const rowMult = []
    for (let col = 0; col < firstArray[0].length; col++) {
      rowMult.push(firstArray[rm][col])
    }
    for (let cm = 0; cm < firstArray.length; cm++) {
      const colMult = []
      for (let row = 0; row < secondArray.length; row++) {
        colMult.push(secondArray[row][cm])
      }
      let newNumb = 0
      for (let index = 0; index < rowMult.length; index++) {
        newNumb += rowMult[index] * colMult[index]
      }
      multMatrix[rm][cm] = newNumb
    }
  }
  return multMatrix
}

// const firstMatrix = [
//   [1, 2],
//   [3, 4]
// ]

// const secondMatrix = [
//   [5, 6],
//   [7, 8]
// ]

// matrixMult(firstMatrix, secondMatrix) // [ [ 19, 22 ], [ 43, 50 ] ]

// const thirdMatrix = [
//   [-1, 4, 1],
//   [7, -6, 2]
// ]
// const fourthMatrix = [
//   [2, -2],
//   [5, 3],
//   [3, 2]
// ]

// matrixMult(thirdMatrix, fourthMatrix) // [ [ 21, 16 ], [ -10, -28 ] ]

--#

--% C:/work/algos/Javascript/Maths/MeanSquareError.js
// Wikipedia: https://en.wikipedia.org/wiki/Mean_squared_error

const meanSquaredError = (predicted, expected) => {
  if (!Array.isArray(predicted) || !Array.isArray(expected)) {
    throw new TypeError('Argument must be an Array')
  }

  if (predicted.length !== expected.length) {
    throw new TypeError('The two lists must be of equal length')
  }

  let err = 0

  for (let i = 0; i < expected.length; i++) {
    err += (expected[i] - predicted[i]) ** 2
  }

  return err / expected.length
}

export { meanSquaredError }

--#

--% C:/work/algos/Javascript/Maths/MidpointIntegration.js
/**
*
* @title Midpoint rule for definite integral evaluation
* @author [ggkogkou](https://github.com/ggkogkou)
* @brief Calculate definite integrals with midpoint method
*
* @details The idea is to split the interval in a number N of intervals and use as interpolation points the xi
* for which it applies that xi = x0 + i*h, where h is a step defined as h = (b-a)/N where a and b are the
* first and last points of the interval of the integration [a, b].
*
* We create a table of the xi and their corresponding f(xi) values and we evaluate the integral by the formula:
* I = h * {f(x0+h/2) + f(x1+h/2) + ... + f(xN-1+h/2)}
*
* N must be > 0 and a<b. By increasing N, we also increase precision
*
* [More info link](https://tutorial.math.lamar.edu/classes/calcii/approximatingdefintegrals.aspx)
*
*/

function integralEvaluation (N, a, b, func) {
  // Check if all restrictions are satisfied for the given N, a, b
  if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }
  if (N <= 0) { throw Error('N has to be >= 2') } // check if N > 0
  if (a > b) { throw Error('a must be less or equal than b') } // Check if a < b
  if (a === b) return 0 // If a === b integral is zero

  // Calculate the step h
  const h = (b - a) / N

  // Find interpolation points
  let xi = a // initialize xi = x0
  const pointsArray = []

  // Find the sum {f(x0+h/2) + f(x1+h/2) + ... + f(xN-1+h/2)}
  let temp
  for (let i = 0; i < N; i++) {
    temp = func(xi + h / 2)
    pointsArray.push(temp)
    xi += h
  }

  // Calculate the integral
  let result = h
  temp = 0
  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]

  result *= temp

  if (Number.isNaN(result)) { throw Error('Result is NaN. The input interval does not belong to the functions domain') }

  return result
}

export { integralEvaluation }

--#

--% C:/work/algos/Javascript/Maths/ModularBinaryExponentiationRecursive.js
/*
  Modified from:
    https://github.com/TheAlgorithms/Python/blob/master/maths/binary_exp_mod.py

  Explanation:
    https://en.wikipedia.org/wiki/Exponentiation_by_squaring
*/

const modularBinaryExponentiation = (a, n, m) => {
  // input: a: int, n: int, m: int
  // returns: (a^n) % m: int
  if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return (modularBinaryExponentiation(a, n - 1, m) * a) % m
  } else {
    const b = modularBinaryExponentiation(a, n / 2, m)
    return (b * b) % m
  }
}

export { modularBinaryExponentiation }

--#

--% C:/work/algos/Javascript/Maths/NumberOfDigits.js
/**
 *
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 * Returns the number of digits of a given integer
 *
 */

const numberOfDigit = (n) => Math.abs(n).toString().length

export { numberOfDigit }

--#

--% C:/work/algos/Javascript/Maths/Palindrome.js
/**
 * A palindrome is any string that can be reversed and still be the same.
 * An example of one is 'radar', since it is spelled the same even after
 * being reversed. One method to check if a
 *
 * Here's how this works recursively:
 *
 * Palindrome('radar')
 * true && Palindrome('ada')
 * true && true && Palindrome('d')
 * true && true && true && true
 *
 * @flow
 * @complexity: O(n)
 */

const PalindromeRecursive = (string) => {
  // Base case
  if (string.length < 2) return true

  // Check outermost keys
  if (string[0] !== string[string.length - 1]) {
    return false
  }

  return PalindromeRecursive(string.slice(1, string.length - 1))
}

const PalindromeIterative = (string) => {
  const _string = string
    .toLowerCase()
    .replace(/ /g, '')
    .replace(/,/g, '')
    .replace(/'.'/g, '')
    .replace(/:/g, '')
    .split('')

  // A word of only 1 character is already a palindrome, so we skip to check it
  while (_string.length > 1) {
    if (_string.shift() !== _string.pop()) {
      return false
    }
  }

  return true
}

export { PalindromeIterative, PalindromeRecursive }

--#

--% C:/work/algos/Javascript/Maths/PascalTriangle.js
const addRow = (triangle) => {
  const previous = triangle[triangle.length - 1]
  const newRow = [1]
  for (let i = 0; i < previous.length - 1; i++) {
    const current = previous[i]
    const next = previous[i + 1]
    newRow.push(current + next)
  }
  newRow.push(1)
  return triangle.push(newRow)
}

const generate = (numRows) => {
  const triangle = [[1], [1, 1]]

  if (numRows === 0) {
    return []
  } else if (numRows === 1) {
    return [[1]]
  } else if (numRows === 2) {
    return [[1], [1, 1]]
  } else {
    for (let i = 2; i < numRows; i++) {
      addRow(triangle)
    }
  }
  return triangle
}

export { generate }

--#

--% C:/work/algos/Javascript/Maths/PerfectCube.js
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 */

const perfectCube = (num) => Math.round(num ** (1 / 3)) ** 3 === num

export { perfectCube }

--#

--% C:/work/algos/Javascript/Maths/PerfectNumber.js
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 * == Perfect Number ==
 * In number theory, a perfect number is a positive integer that is equal to the sum of
 * its positive divisors(factors), excluding the number itself.
 * For example: 6 ==> divisors[1, 2, 3, 6]
 *      Excluding 6, the sum(divisors) is 1 + 2 + 3 = 6
 *      So, 6 is a Perfect Number
 * Other examples of Perfect Numbers: 28, 486, ...
 *
 * More on Perfect Number:
 *      https://en.wikipedia.org/wiki/Perfect_number
 *
 */

const factorsExcludingNumber = (n) => {
  return [...Array(n).keys()].filter((num) => n % num === 0)
}

const perfectNumber = (n) => {
  const factorSum = factorsExcludingNumber(n).reduce((num, initialValue) => {
    return num + initialValue
  }, 0)

  return factorSum === n
}

export { perfectNumber }

--#

--% C:/work/algos/Javascript/Maths/PerfectSquare.js
/**
 * Author: dephraiim
 * License: GPL-3.0 or later
 *
 */

const perfectSquare = (num) => Math.sqrt(num) ** 2 === num

export { perfectSquare }

--#

--% C:/work/algos/Javascript/Maths/PermutationAndCombination.js
/**
 * @details Calculates the number of permutations and combinations.
 * @external_link (Permutation And Combinations)[https://www.geeksforgeeks.org/permutation-and-combination/]
 */

/**
 * @brief Calculates the factorial of the given number.
 * @param num: integer
 * @details Factorial of n = n * (n - 1) * (n - 2) * ... * 1
 * @returns integer: Factorial of the number.
            NaN: if negative number is provided.
 */
const factorial = (n) => {
  if (n >= 0) {
    if (n === 0) {
      return 1
    } else {
      return n * factorial(n - 1)
    }
  } else {
    return NaN
  }
}

/**
 * @brief Calculates the number of Permutations from the given data.
 * @param
 * n: integer -> number of items.
 * r: integer -> number of times n is taken.
 * @returns integer: The number of permutations.
            NaN: if negative number is provided.
 */
const permutation = (n, r) => {
  return factorial(n) / factorial(n - r)
}

/**
 * @brief Calculates the number of Combinations from the given data.
 * @param
 * n -> number of items.
 * r -> number of times n is taken.
 * @returns integer: The number of combinations.
            NaN: if negative number is provided.
 */
const combination = (n, r) => {
  return factorial(n) / (factorial(r) * factorial(n - r))
}

// Exports the functions to be used in other files.
export { factorial, permutation, combination }

--#

--% C:/work/algos/Javascript/Maths/PiApproximationMonteCarlo.js
// Wikipedia: https://en.wikipedia.org/wiki/Monte_Carlo_method
// Video Explanation: https://www.youtube.com/watch?v=ELetCV_wX_c

const piEstimation = (iterations = 100000) => {
  let circleCounter = 0

  for (let i = 0; i < iterations; i++) {
    // generating random points and checking if it lies within a circle of radius 1
    const x = Math.random()
    const y = Math.random()
    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))

    if (radius < 1) circleCounter += 1
  }

  // fomula for pi = (ratio of number inside circle and total iteration) x 4
  const pi = (circleCounter / iterations) * 4
  return pi
}

export { piEstimation }

--#

--% C:/work/algos/Javascript/Maths/Polynomial.js
/**
 * Polynomials are algebraic expressions consisting of two or more algebraic terms.
 * Terms of a polynomial are:
 * 1. Coefficients e.g. 5, 4 in 5x^0, 4x^3 respectively
 * 2. Variables e.g. y in 3y^2
 * 3. Exponents e.g. 5 in y^5
 *
 * Class Polynomial constructs the polynomial using Array as an argument.
 * The members of array are coefficients and their indexes as exponents.
 */
class Polynomial {
  constructor (array) {
    this.coefficientArray = array // array of coefficients
    this.polynomial = '' // in terms of x e.g. (2x) + (1)
    this.construct()
  }

  /**
   * Function to construct the polynomial in terms of x using the coefficientArray
   */
  construct () {
    this.polynomial = this.coefficientArray
      .map((coefficient, exponent) => {
        if (coefficient === 0) {
          return '0'
        }
        if (exponent === 0) {
          return `(${coefficient})`
        } else if (exponent === 1) {
          return `(${coefficient}x)`
        } else {
          return `(${coefficient}x^${exponent})`
        }
      })
      .filter((x) =>
        x !== '0'
      )
      .reverse()
      .join(' + ')
  }

  /**
   * Function to display polynomial in terms of x
   * @returns {String} of polynomial representation in terms of x
   */
  display () {
    return this.polynomial
  }

  /**
   * Function to calculate the value of the polynomial by substituting variable x
   * @param {Number} value
   */
  evaluate (value) {
    return this.coefficientArray.reduce((result, coefficient, exponent) => {
      return result + coefficient * Math.pow(value, exponent)
    }, 0)
  }
}

export { Polynomial }

--#

--% C:/work/algos/Javascript/Maths/Pow.js
// Returns the value of x to the power of y

const pow = (x, y) => {
  let result = 1
  for (let i = 1; i <= y; i++) {
    result *= x
  }
  return result
}

export { pow }

--#

--% C:/work/algos/Javascript/Maths/PowLogarithmic.js
import { isEven } from './IsEven'

/**
 * This algorithm is divide the n by 2 every time and pass this to recursive call to find the result of smaller result.
 * why? Because
 *      x^n => [if n is even] x^(n / 2) *  x^(n / 2)     (example : 7^4 => 7^2 * 7^2)
 *             [if n is odd]  x^(n / 2) *  x^(n / 2) * x (example : 7^5 => 7^2 * 7^2 * 7)
 * and repeat the above step until we reach to the base case.
 *
 * @function PowLogarithmic
 * @description Given two integers x and n, return x^n in logarithmic complexity.
 * @param {Integer} x - The input integer
 * @param {Integer} n - The input integer
 * @return {Integer} - Returns x^n.
 * @see [Pow-Logarithmic](https://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/)
 */
const powLogarithmic = (x, n) => {
  if (n === 0) return 1
  const result = powLogarithmic(x, Math.floor(n / 2))
  if (isEven(n)) {
    return result * result
  }
  return result * result * x
}

export { powLogarithmic }

--#

--% C:/work/algos/Javascript/Maths/PrimeCheck.js
/*
  Modified from:
    https://github.com/TheAlgorithms/Python/blob/master/maths/prime_check.py

  Complexity:
    O(sqrt(n))
*/

const PrimeCheck = (n) => {
  // input: n: int
  // output: boolean
  if (n === 1) return false
  if (n === 0) return false
  if (n === 2) return true
  if (n % 2 === 0) return false

  for (let i = 3; i * i <= n; i += 2) {
    if (n % i === 0) {
      return false
    }
  }
  return true
}

export { PrimeCheck }

--#

--% C:/work/algos/Javascript/Maths/PrimeFactors.js
/*
  Modified from:
    https://github.com/TheAlgorithms/Python/blob/master/maths/prime_factors.py
*/

export const PrimeFactors = (n) => {
  // input: n: int
  // output: primeFactors: Array of all prime factors of n
  const primeFactors = []
  for (let i = 2; i * i <= n; i++) {
    while (n % i === 0) {
      primeFactors.push(i)
      n = Math.floor(n / i)
    }
  }
  if (n > 1) {
    primeFactors.push(n)
  }
  return primeFactors
}

--#

--% C:/work/algos/Javascript/Maths/RadianToDegree.js
/*
 * Radian : https://en.wikipedia.org/wiki/Radian
 * Degree : https://en.wikipedia.org/wiki/Degree_(angle)
 *
 * Angle in Degree = ( Angle in Radian ) x ( 180 / pi )
 *
 * Example :
 * Question : Convert pi / 2 degree to radian
 * So, Angle in Radian = pi / 2
 *
 * Solution :
 * Angle in Degree = ( pi / 2 ) x ( 180 / pi ) = 90
 *
 * So, pi / 2 radian is equal to 90 degree
 */

/**
 * @param {number} radian
 * @return {number}
 */
export const radianToDegree = (radian) => {
  return radian * (180 / Math.PI)
}

--#

--% C:/work/algos/Javascript/Maths/ReverseNumber.js
/*
    Problem statement and Explanation : https://medium.com/@ManBearPigCode/how-to-reverse-a-number-mathematically-97c556626ec6
*/

/**
 * ReverseNumber return the reversed value of the given number.
 * @param {Number} n any digit number.
 * @returns `Number` n reverse in reverse.
 */
const ReverseNumber = (number) => {
  // firstly, check that input is a number or not.
  if (typeof number !== 'number') {
    return new TypeError('Argument is not a number.')
  }
  // A variable for storing the reversed number.
  let reverseNumber = 0
  // Iterate the process until getting the number is 0.
  while (number > 0) {
    // get the last digit of the number
    const lastDigit = number % 10
    // add to the last digit to in reverseNumber
    reverseNumber = reverseNumber * 10 + lastDigit
    // reduce the actual number.
    number = Math.floor(number / 10)
  }
  return reverseNumber
}

export { ReverseNumber }

--#

--% C:/work/algos/Javascript/Maths/ReversePolishNotation.js
// Wikipedia: https://en.wikipedia.org/wiki/Reverse_Polish_notation

const calcRPN = (expression) => {
  const operators = {
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
    '*': (a, b) => a * b,
    '/': (a, b) => b / a
  }

  const tokens = expression.split(' ')

  const stack = []

  tokens.forEach((token) => {
    const operator = operators[token]

    if (typeof operator === 'function') {
      const a = stack.pop()
      const b = stack.pop()

      const result = operator(a, b)

      stack.push(result)
    } else {
      stack.push(parseFloat(token))
    }
  })

  return stack.pop()
}

export { calcRPN }

--#

--% C:/work/algos/Javascript/Maths/SieveOfEratosthenes.js
const sieveOfEratosthenes = (n) => {
  /*
   * Calculates prime numbers till a number n
   * :param n: Number up to which to calculate primes
   * :return: A boolean list containing only primes
   */
  const primes = new Array(n + 1)
  primes.fill(true) // set all as true initially
  primes[0] = primes[1] = false // Handling case for 0 and 1
  const sqrtn = Math.ceil(Math.sqrt(n))
  for (let i = 2; i <= sqrtn; i++) {
    if (primes[i]) {
      for (let j = i * i; j <= n; j += i) {
        /*
        Optimization.
        Let j start from i * i, not 2 * i, because smaller multiples of i have been marked false.

        For example, let i = 4.
        We do not have to check from 8(4 * 2) to 12(4 * 3)
        because they have been already marked false when i=2 and i=3.
        */
        primes[j] = false
      }
    }
  }
  return primes
}

export { sieveOfEratosthenes }

--#

--% C:/work/algos/Javascript/Maths/SimpsonIntegration.js
/*
*
* @file
* @title Composite Simpson's rule for definite integral evaluation
* @author: [ggkogkou](https://github.com/ggkogkou)
* @brief Calculate definite integrals using composite Simpson's numerical method
*
* @details The idea is to split the interval in an EVEN number N of intervals and use as interpolation points the xi
* for which it applies that xi = x0 + i*h, where h is a step defined as h = (b-a)/N where a and b are the
* first and last points of the interval of the integration [a, b].
*
* We create a table of the xi and their corresponding f(xi) values and we evaluate the integral by the formula:
* I = h/3 * {f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}
*
* That means that the first and last indexed i f(xi) are multiplied by 1,
* the odd indexed f(xi) by 4 and the even by 2.
*
* N must be even number and a<b. By increasing N, we also increase precision
*
* More info: [Wikipedia link](https://en.wikipedia.org/wiki/Simpson%27s_rule#Composite_Simpson's_rule)
*
*/

function integralEvaluation (N, a, b, func) {
  // Check if N is an even integer
  let isNEven = true
  if (N % 2 !== 0) isNEven = false

  if (!Number.isInteger(N) || Number.isNaN(a) || Number.isNaN(b)) { throw new TypeError('Expected integer N and finite a, b') }
  if (!isNEven) { throw Error('N is not an even number') }
  if (N <= 0) { throw Error('N has to be >= 2') }

  // Check if a < b
  if (a > b) { throw Error('a must be less or equal than b') }
  if (a === b) return 0

  // Calculate the step h
  const h = (b - a) / N

  // Find interpolation points
  let xi = a // initialize xi = x0
  const pointsArray = []

  // Find the sum {f(x0) + 4*f(x1) + 2*f(x2) + ... + 2*f(xN-2) + 4*f(xN-1) + f(xN)}
  let temp
  for (let i = 0; i < N + 1; i++) {
    if (i === 0 || i === N) temp = func(xi)
    else if (i % 2 === 0) temp = 2 * func(xi)
    else temp = 4 * func(xi)

    pointsArray.push(temp)
    xi += h
  }

  // Calculate the integral
  let result = h / 3
  temp = 0
  for (let i = 0; i < pointsArray.length; i++) temp += pointsArray[i]

  result *= temp

  if (Number.isNaN(result)) { throw Error("Result is NaN. The input interval doesn't belong to the functions domain") }

  return result
}

export { integralEvaluation }

--#

--% C:/work/algos/Javascript/Maths/Softmax.js
// Wikipedia: https://en.wikipedia.org/wiki/Softmax_function

const Softmax = (inputs) => {
  const eulerExpOfAllInputs = inputs.map(input => Math.exp(input))
  const sumOfEulerExpOfAllInputs = eulerExpOfAllInputs.reduce((a, b) => a + b)

  return inputs.map((input) => {
    const eulerExpInputs = Math.exp(input)
    return eulerExpInputs / sumOfEulerExpOfAllInputs
  })
}

export { Softmax }

--#

--% C:/work/algos/Javascript/Maths/SquareRoot.js
/*
* Author: Rak Laptudirm
*
* https://en.wikipedia.org/wiki/Newton%27s_method
*
* Finding the square root of a number using Newton's method.
*/

function sqrt (num, precision = 4) {
  if (!Number.isFinite(num)) { throw new TypeError(`Expected a number, received ${typeof num}`) }
  if (!Number.isFinite(precision)) { throw new TypeError(`Expected a number, received ${typeof precision}`) }
  let sqrt = 1
  for (let i = 0; i < precision; i++) {
    sqrt -= (sqrt * sqrt - num) / (2 * sqrt)
  }
  return sqrt
}

export { sqrt }

--#

--% C:/work/algos/Javascript/Maths/SumOfDigits.js
/*
  Gets the sum of the digits of the numbers inputted
  sumOfDigits(10) will return 1 + 0 = 1
  sumOfDigits(255) will return 2 + 5 + 5 = 12
  Wikipedia: https://en.wikipedia.org/wiki/Digit_sum
*/

/*
  The given input is converted to a string, split into an array of characters.
  This array is reduced to a number using the method <Array>.reduce
  NOTE: The final parseInt is just there in cases where 1 digit numbers are given, since without that it would result in a String output.
*/
function sumOfDigitsUsingString (number) {
  if (number < 0) number = -number

  return Number.parseInt(number.toString().split('').reduce((a, b) => Number(a) + Number(b)))
}

/*
  The input is divided by 10 in each iteration, till the input is equal to 0
  The sum of all the digits is returned (The res variable acts as a collector, taking the remainders on each iteration)
*/
function sumOfDigitsUsingLoop (number) {
  if (number < 0) number = -number
  let res = 0

  while (number > 0) {
    res += number % 10
    number = Math.floor(number / 10)
  }

  return res
}

/*
  We use the fact that the sum of the digits of a one digit number is itself, and check whether the number is less than 10. If so, then we return the number. Else, we take the number divided by 10 and floored, and recursively call the function, while adding it with the number mod 10
*/
function sumOfDigitsUsingRecursion (number) {
  if (number < 0) number = -number

  if (number < 10) return number

  return (number % 10) + sumOfDigitsUsingRecursion(Math.floor(number / 10))
}

export { sumOfDigitsUsingRecursion, sumOfDigitsUsingLoop, sumOfDigitsUsingString }

--#

--% C:/work/algos/Javascript/Maths/SumOfGeometricProgression.js
/*
  Returns the sum of a geometric progression
  Article on Geometric Progression: https://en.wikipedia.org/wiki/Geometric_series
  Examples:
  > sumOfGeometricProgression(2, 0.5, 6)
  3.9375
  > sumOfGeometricProgression(0.5, 10, 3)
  55.5
  > sumOfGeometricProgression(0.5, 10, Infinity)
  Error: The geometric progression is diverging, and its sum cannot be calculated
*/

/**
 *
 * @param {Number} firstTerm The first term of the geometric progression
 * @param {Number} commonRatio The common ratio of the geometric progression
 * @param {Number} numOfTerms The number of terms in the progression
 */
function sumOfGeometricProgression (firstTerm, commonRatio, numOfTerms) {
  if (!Number.isFinite(numOfTerms)) {
    /*
      If the number of Terms is Infinity, the common ratio needs to be less than 1 to be a convergent geometric progression
      Article on Convergent Series: https://en.wikipedia.org/wiki/Convergent_series
    */
    if (Math.abs(commonRatio) < 1) return firstTerm / (1 - commonRatio)
    throw new Error('The geometric progression is diverging, and its sum cannot be calculated')
  }

  if (commonRatio === 1) return firstTerm * numOfTerms

  return (firstTerm * (Math.pow(commonRatio, numOfTerms) - 1)) / (commonRatio - 1)
}

export { sumOfGeometricProgression }

--#

--% C:/work/algos/Javascript/Maths/Volume.js
/*
Calculate the volume of the shapes

Volume for Cuboid
Volume for Cube
Volume for Cone
Volume for Pyramid
Volume for Cylinder
Volume for Triangular Prism
Volume for Pentagonal Prism
Volume for Sphere
Volume for Hemisphere
*/

/*
  Calculate the volume for a Cuboid
  Reference: https://www.cuemath.com/measurement/volume-of-cuboid/
  return width * length * height
*/
const volCuboid = (width, length, height) => {
  isNumber(width, 'Width')
  isNumber(length, 'Length')
  isNumber(height, 'Height')
  return (width * length * height)
}

/*
  Calculate the volume for a Cube
  Reference: https://www.cuemath.com/measurement/volume-of-cube/
  return length * length * length
*/
const volCube = (length) => {
  isNumber(length, 'Length')
  return (length ** 3)
}

/*
  Calculate the volume for a Cone
  Reference: https://www.cuemath.com/measurement/volume-of-cone/
  return PI * radius^2 * height/3
*/
const volCone = (radius, height) => {
  isNumber(radius, 'Radius')
  isNumber(height, 'Height')
  return (Math.PI * radius ** 2 * height / 3.0)
}

/*
  Calculate the volume for a Pyramid
  Reference: https://www.cuemath.com/measurement/volume-of-pyramid/
  return (baseLength * baseWidth * height) / 3
*/
const volPyramid = (baseLength, baseWidth, height) => {
  isNumber(baseLength, 'BaseLength')
  isNumber(baseWidth, 'BaseWidth')
  isNumber(height, 'Height')
  return (baseLength * baseWidth * height) / 3.0
}

/*
  Calculate the volume for a Cylinder
  Reference: https://www.cuemath.com/measurement/volume-of-cylinder/
  return PI * radius^2 * height
*/
const volCylinder = (radius, height) => {
  isNumber(radius, 'Radius')
  isNumber(height, 'Height')
  return (Math.PI * radius ** 2 * height)
}

/*
  Calculate the volume for a Triangular Prism
  Reference: http://lrd.kangan.edu.au/numbers/content/03_volume/04_page.htm
  return 1 / 2 * baseLengthTriangle * heightTriangle * height
*/
const volTriangularPrism = (baseLengthTriangle, heightTriangle, height) => {
  isNumber(baseLengthTriangle, 'BaseLengthTriangle')
  isNumber(heightTriangle, 'HeightTriangle')
  isNumber(height, 'Height')
  return (1 / 2 * baseLengthTriangle * heightTriangle * height)
}

/*
  Calculate the volume for a Pentagonal Prism
  Reference: https://www.cuemath.com/measurement/volume-of-pentagonal-prism/
  return 5/2 * pentagonalLength * pentagonalBaseLength * height
*/
const volPentagonalPrism = (pentagonalLength, pentagonalBaseLength, height) => {
  isNumber(pentagonalLength, 'PentagonalLength')
  isNumber(pentagonalBaseLength, 'PentagonalBaseLength')
  isNumber(height, 'Height')
  return (5 / 2 * pentagonalLength * pentagonalBaseLength * height)
}

/*
  Calculate the volume for a Sphere
  Reference: https://www.cuemath.com/measurement/volume-of-sphere/
  return 4/3 * PI * radius^3
*/
const volSphere = (radius) => {
  isNumber(radius, 'Radius')
  return (4 / 3 * Math.PI * radius ** 3)
}

/*
  Calculate the volume for a Hemisphere
  Reference: https://www.cuemath.com/measurement/volume-of-hemisphere/
  return (2 * PI * radius^3)/3
*/
const volHemisphere = (radius) => {
  isNumber(radius, 'Radius')
  return (2.0 * Math.PI * radius ** 3) / 3.0
}

const isNumber = (number, noName = 'number') => {
  if (typeof number !== 'number') {
    throw new TypeError('The ' + noName + ' should be Number type')
  } else if (number < 0 || (!Number.isFinite(number))) {
    throw new Error('The ' + noName + ' only accepts positive values')
  }
}

export { volCuboid, volCube, volCone, volPyramid, volCylinder, volTriangularPrism, volPentagonalPrism, volSphere, volHemisphere }

--#

--% C:/work/algos/Javascript/Maths/WhileLoopFactorial.js
/*
    author: Theepag
 */
export const factorialize = (num) => {
  // Step 1. variable result to store num
  let result = num
  // If num = 0 OR 1, the factorial will return 1
  if (num === 0 || num === 1) { return 1 }
  // Step 2. WHILE loop
  while (num > 1) {
    num-- // decrement 1 at each iteration
    result = result * num // or result = result * num;
  }
  // Step 3. Return the factorial
  return result
}

--#

--% C:/work/algos/Javascript/Maths/test/Abs.test.js
import { absVal } from '../Abs'

describe('absVal', () => {
  it('should return an absolute value of a negative number', () => {
    const absOfNegativeNumber = absVal(-34)
    expect(absOfNegativeNumber).toBe(34)
  })

  it('should return an absolute value of a positive number', () => {
    const absOfPositiveNumber = absVal(50)
    expect(absOfPositiveNumber).toBe(50)
  })

  it('should return an absolute value of a zero number', () => {
    const absOfPositiveNumber = absVal(0)
    expect(absOfPositiveNumber).toBe(0)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/AliquotSum.test.js
import { aliquotSum } from '../AliquotSum'

describe('Aliquot Sum of a Number', () => {
  it('Aliquot Sum of 6', () => {
    expect(aliquotSum(6)).toBe(6)
  })

  it('Aliquot Sum of 1', () => {
    expect(aliquotSum(1)).toBe(0)
  })

  it('Aliquot Sum of 28', () => {
    expect(aliquotSum(28)).toBe(28)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Area.test.js
import * as area from '../Area'

describe('Testing surfaceAreaCube calculations', () => {
  it('with natural number', () => {
    const surfaceAreaOfOne = area.surfaceAreaCube(1.2)
    const surfaceAreaOfThree = area.surfaceAreaCube(3)
    expect(surfaceAreaOfOne).toBe(8.64)
    expect(surfaceAreaOfThree).toBe(54)
  })
  it('with negative argument, expect throw', () => {
    expect(() => area.surfaceAreaCube(-1)).toThrow()
  })
  it('with non-numeric argument, expect throw', () => {
    expect(() => area.surfaceAreaCube('199')).toThrow()
  })
})

describe('Testing surfaceAreaSphere calculations', () => {
  it('with correct value', () => {
    const calculateArea = area.surfaceAreaSphere(5)
    const expected = 314.1592653589793
    expect(calculateArea).toBe(expected)
  })
  it('with negative value, expect throw', () => {
    expect(() => area.surfaceAreaSphere(-1)).toThrow()
  })
})

describe('Testing areaRectangle calculations', () => {
  it('with correct args', () => {
    const areaRectangle = area.areaRectangle(2.5, 2)
    expect(areaRectangle).toBe(5.0)
  })
  it('with incorrect args, expect throw', () => {
    expect(() => area.areaRectangle(-1, 20)).toThrow()
    expect(() => area.areaRectangle('1', 0)).toThrow()
    expect(() => area.areaRectangle(23, -1)).toThrow()
    expect(() => area.areaRectangle(23, 'zero')).toThrow()
  })
})

describe('Testing areaSquare calculations', () => {
  it('with correct args', () => {
    const areaSquare = area.areaSquare(2.5)
    expect(areaSquare).toBe(6.25)
  })
  it('with incorrect side length, expect throw', () => {
    expect(() => area.areaSquare(-1)).toThrow()
    expect(() => area.areaSquare('zero')).toThrow()
  })
})

describe('Testing areaTriangle calculations', () => {
  it('with correct args', () => {
    const areaTriangle = area.areaTriangle(1.66, 3.44)
    expect(areaTriangle).toBe(2.8552)
  })
  it('with incorrect base and height, expect throw', () => {
    expect(() => area.areaTriangle(-1, 1)).toThrow()
    expect(() => area.areaTriangle(9, 'zero')).toThrow()
  })
})

describe('Testing areaTriangleWithAllThreeSides calculations', () => {
  it('with correct args', () => {
    const areaTriangle = area.areaTriangleWithAllThreeSides(5, 6, 7)
    expect(areaTriangle).toBe(14.7)
  })
  it('with incorrect sides, expect throw', () => {
    expect(() => area.areaTriangleWithAllThreeSides(-1, 1, 10)).toThrow()
    expect(() => area.areaTriangleWithAllThreeSides(9, 'zero', 2)).toThrow()
    expect(() => area.areaTriangleWithAllThreeSides(1, 10, 12)).toThrow()
  })
})

describe('Testing areaParallelogram calculations', () => {
  it('with correct args', () => {
    const areaParallelogram = area.areaParallelogram(1.66, 3.44)
    expect(areaParallelogram).toBe(5.7104)
  })
  it('with incorrect base and height, expect throw', () => {
    expect(() => area.areaParallelogram(-1, 1)).toThrow()
    expect(() => area.areaParallelogram(9, 'zero')).toThrow()
  })
})

describe('Testing areaTrapezium calculations', () => {
  it('with correct args', () => {
    const areaTrapezium = area.areaTrapezium(1.66, 2.41, 4.1)
    expect(areaTrapezium).toBe(8.3435)
  })
  it('with incorrect bases and height, expect throw', () => {
    expect(() => area.areaTrapezium(-1, 1, 0)).toThrow()
    expect(() => area.areaTrapezium(9, 'zero', 2)).toThrow()
    expect(() => area.areaTrapezium(9, 1, 'seven')).toThrow()
  })
})

describe('Testing areaCircle calculations', () => {
  it('with correct args', () => {
    const areaCircle = area.areaCircle(3.456)
    expect(areaCircle).toBe(37.52298159254666)
  })
  it('with incorrect diagonal, expect throw', () => {
    expect(() => area.areaCircle(-1)).toThrow()
    expect(() => area.areaCircle('zero')).toThrow()
  })
})

describe('Testing areaRhombus calculations', () => {
  it('with correct args', () => {
    const areaRhombus = area.areaRhombus(2.5, 2.0)
    expect(areaRhombus).toBe(2.5)
  })
  it('with incorrect diagonals, expect throw', () => {
    expect(() => area.areaRhombus(7, -1)).toThrow()
    expect(() => area.areaRhombus('zero', 2)).toThrow()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/ArmstrongNumber.test.js
import { armstrongNumber } from '../ArmstrongNumber'

describe('ArmstrongNumber', () => {
  it('should return true for an armstrong number', () => {
    expect(armstrongNumber(371)).toBeTruthy()
  })

  it('should return false for a non-armstrong number', () => {
    expect(armstrongNumber(300)).toBeFalsy()
  })
  it('should return false for negative values', () => {
    expect(armstrongNumber(-2)).toBeFalsy()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/AverageMean.test.js
import { mean } from '../AverageMean'

describe('Tests for average mean', () => {
  it('should be a function', () => {
    expect(typeof mean).toEqual('function')
  })

  it('should throw error for invalid input', () => {
    expect(() => mean(123)).toThrow()
  })

  it('should return the mean of an array of numbers', () => {
    const meanFunction = mean([1, 2, 4, 5])
    expect(meanFunction).toBe(3)
  })

  it('should return the mean of an array of numbers', () => {
    const meanFunction = mean([10, 40, 100, 20])
    expect(meanFunction).toBe(42.5)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/AverageMedian.test.js
import { averageMedian } from '../AverageMedian'

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([1, 2, 6, 4, 5])
  expect(medianValue).toBe(4)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([8, 9, 1, 2, 5, 10, 11])
  expect(medianValue).toBe(8)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([15, 18, 3, 9, 13, 5])
  expect(medianValue).toBe(11)
})

test('should return the median of an array of numbers:', () => {
  const medianValue = averageMedian([1, 2, 3, 4, 6, 8])
  expect(medianValue).toBe(3.5)
})

--#

--% C:/work/algos/Javascript/Maths/test/BInaryConvert.test.js
import { BinaryConvert } from '../BinaryConvert'

describe('BinaryConvert', () => {
  it('should return the correct value', () => {
    expect(BinaryConvert(4)).toBe(100)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(12)).toBe(1100)
  })
  it('should return the correct value of the sum from two number', () => {
    expect(BinaryConvert(12 + 2)).toBe(1110)
  })
  it('should return the correct value of the subtract from two number', () => {
    expect(BinaryConvert(245 - 56)).toBe(10111101)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(254)).toBe(11111110)
  })
  it('should return the correct value', () => {
    expect(BinaryConvert(63483)).toBe(1111011111111011)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/BinaryExponentiationIterative.test.js
import { exponent } from '../BinaryExponentiationIterative'

describe('exponent', () => {
  it('should return 1 when power is 0', () => {
    expect(exponent(5, 0)).toBe(1)
  })

  it('should return 0 when base is 0', () => {
    expect(exponent(0, 7)).toBe(0)
  })

  it('should return the value of a base raised to a power', () => {
    expect(exponent(3, 5)).toBe(243)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/BinaryExponentiationRecursive.test.js
import { binaryExponentiation } from '../BinaryExponentiationRecursive'

describe('BinaryExponentiationRecursive', () => {
  it('should calculate 2 to the power of 10 correctly', () => {
    expect(binaryExponentiation(2, 10)).toBe(1024)
  })

  it('should calculate 3 to the power of 9 correctly', () => {
    expect(binaryExponentiation(3, 9)).toBe(19683)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/BisectionMethod.test.js
import { findRoot } from '../BisectionMethod'

test('Equation f(x) = x^2 - 3*x + 2 = 0, has root x = 1 in [a, b] = [0, 1.5]', () => {
  const root = findRoot(0, 1.5, (x) => { return Math.pow(x, 2) - 3 * x + 2 }, 8)
  expect(root).toBe(0.9990234375)
})

test('Equation f(x) = ln(x) + sqrt(x) + *x^2 = 0, has root x = 0.36247037 in [a, b] = [0, 10]', () => {
  const root = findRoot(0, 10, (x) => { return Math.log(x) + Math.sqrt(x) + Math.PI * Math.pow(x, 2) }, 32)
  expect(Number(Number(root).toPrecision(8))).toBe(0.36247037)
})

test('Equation f(x) = sqrt(x) + e^(2*x) - 8*x = 0, has root x = 0.93945851 in [a, b] = [0.5, 100]', () => {
  const root = findRoot(0.5, 100, (x) => { return Math.exp(2 * x) + Math.sqrt(x) - 8 * x }, 32)
  expect(Number(Number(root).toPrecision(8))).toBe(0.93945851)
})

--#

--% C:/work/algos/Javascript/Maths/test/Coordinate.test.js
import * as coordinate from '../Coordinate'

describe('Testing euclideanDistance calculations', () => {
  it('Should give a numeric output (distance between 2 points) with 4 numeric arguments', () => {
    const euclideanDistance = coordinate.euclideanDistance(2, 2, -10, -7)
    expect(euclideanDistance).toBe(15)
  })
  it('Should not give any output given non-numeric argument', () => {
    const euclideanDistance = coordinate.euclideanDistance('ABC', '123', '', '###')
    expect(euclideanDistance).toBeNaN()
  })
  it('Should not give any output given any number of numeric arguments less than 4', () => {
    const euclideanDistance3arg = coordinate.euclideanDistance(2, 2, -10)
    const euclideanDistance2arg = coordinate.euclideanDistance(2, 2)
    const euclideanDistance1arg = coordinate.euclideanDistance(2)
    const euclideanDistance0arg = coordinate.euclideanDistance()
    expect(euclideanDistance3arg).toBeNaN()
    expect(euclideanDistance2arg).toBeNaN()
    expect(euclideanDistance1arg).toBeNaN()
    expect(euclideanDistance0arg).toBeNaN()
  })
})

describe('Testing manhattanDistance calculations', () => {
  it('Should give a numeric output (distance between 2 points) with 4 numeric arguments', () => {
    const manhattanDistance = coordinate.manhattanDistance(2, 2, -10, -7)
    expect(manhattanDistance).toBe(21)
  })
  it('Should not give any output given non-numeric argument', () => {
    const manhattanDistance = coordinate.manhattanDistance('ABC', '123', '', '###')
    expect(manhattanDistance).toBeNaN()
  })
  it('Should not give any output given any number of numeric arguments less than 4', () => {
    const manhattanDistance3arg = coordinate.manhattanDistance(2, 2, -10)
    const manhattanDistance2arg = coordinate.manhattanDistance(2, 2)
    const manhattanDistance1arg = coordinate.manhattanDistance(2)
    const manhattanDistance0arg = coordinate.manhattanDistance()
    expect(manhattanDistance3arg).toBeNaN()
    expect(manhattanDistance2arg).toBeNaN()
    expect(manhattanDistance1arg).toBeNaN()
    expect(manhattanDistance0arg).toBeNaN()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/DegreeToRadian.test.js
import { degreeToRadian } from '../DegreeToRadian'

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(0)
  expect(radianEqual).toBe(0)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(45)
  expect(radianEqual).toBe(Math.PI / 4)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(90)
  expect(radianEqual).toBe(Math.PI / 2)
})

test('should convert degree to radian:', () => {
  const radianEqual = degreeToRadian(180)
  expect(radianEqual).toBe(Math.PI)
})

--#

--% C:/work/algos/Javascript/Maths/test/EulerMethod.manual-test.js
import { eulerFull } from '../EulerMethod'

function plotLine (label, points, width, height) {
  // utility function to plot the results

  // container needed to control the size of the canvas
  const container = document.createElement('div')
  container.style.width = width + 'px'
  container.style.height = height + 'px'
  document.body.append(container)

  // the canvas for plotting
  const canvas = document.createElement('canvas')
  container.append(canvas)

  // Chart-class from chartjs
  const chart = new Chart(canvas, { // eslint-disable-line
    type: 'scatter',
    data: {
      datasets: [{
        label: label,
        data: points,
        showLine: true,
        fill: false,
        tension: 0,
        borderColor: 'black'
      }]
    },
    options: {
      maintainAspectRatio: false,
      responsive: true
    }
  })
}

function exampleEquation1 (x, y) {
  return x
}

// example from https://en.wikipedia.org/wiki/Euler_method
function exampleEquation2 (x, y) {
  return y
}

// example from https://www.geeksforgeeks.org/euler-method-solving-differential-equation/
function exampleEquation3 (x, y) {
  return x + y + x * y
}

// plot the results if the script is executed in a browser with a window-object
if (typeof window !== 'undefined') {
  const points1 = eulerFull(0, 4, 0.1, 0, exampleEquation1)
  const points2 = eulerFull(0, 4, 0.1, 1, exampleEquation2)
  const points3 = eulerFull(0, 0.1, 0.025, 1, exampleEquation3)

  const script = document.createElement('script')

  // using chartjs
  script.src = 'https://www.chartjs.org/dist/2.9.4/Chart.min.js'
  script.onload = function () {
    plotLine('example 1: dy/dx = x', points1, 600, 400)
    plotLine('example 2: dy/dx = y', points2, 600, 400)
    plotLine('example 3: dy/dx = x + y + x * y', points3, 600, 400)
  }
  document.body.append(script)
}

--#

--% C:/work/algos/Javascript/Maths/test/EulerMethod.test.js
import { eulerFull, eulerStep } from '../EulerMethod'

describe('eulerStep', () => {
  it('should calculate the next y value correctly', () => {
    expect(eulerStep(0, 0.1, 0, function (x, y) { return x })).toBe(0)
    expect(eulerStep(2, 1, 1, function (x, y) { return x * x })).toBe(5)
  })
})

describe('eulerFull', () => {
  it('should return all the points found', () => {
    expect(eulerFull(0, 3, 1, 0, function (x, y) { return x }))
      .toEqual([{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 1 }, { x: 3, y: 3 }])

    expect(eulerFull(3, 4, 0.5, 1, function (x, y) { return x * x }))
      .toEqual([{ x: 3, y: 1 }, { x: 3.5, y: 5.5 }, { x: 4, y: 11.625 }])
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/EulersTotient.test.js
import { EulersTotient } from '../EulersTotient'

describe('EulersTotient', () => {
  it('should return 6 as 1, 2, 4, 5, 7, and 8 are coprime to 9', () => {
    expect(EulersTotient(9)).toBe(6)
  })

  it('should return 4 as 1, 3, 7, and 9 are coprime to 10', () => {
    expect(EulersTotient(10)).toBe(4)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/EulersTotientFunction.test.js
import { eulersTotientFunction } from '../EulersTotientFunction'

describe('eulersTotientFunction', () => {
  it('is a function', () => {
    expect(typeof eulersTotientFunction).toEqual('function')
  })
  it('should return the phi of a given number', () => {
    const phiOfNumber = eulersTotientFunction(10)
    expect(phiOfNumber).toBe(4)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/ExtendedEuclideanGCD.test.js
import { extendedEuclideanGCD } from '../ExtendedEuclideanGCD'

describe('extendedEuclideanGCD', () => {
  it('should return valid values in order for positive arguments', () => {
    expect(extendedEuclideanGCD(240, 46)).toMatchObject([2, -9, 47])
    expect(extendedEuclideanGCD(46, 240)).toMatchObject([2, 47, -9])
  })
  it('should give error on non-positive arguments', () => {
    expect(() => extendedEuclideanGCD(0, 240)).toThrowError(new TypeError('Must be positive numbers'))
    expect(() => extendedEuclideanGCD(46, -240)).toThrowError(new TypeError('Must be positive numbers'))
  })
  it('should give error on non-numeric arguments', () => {
    expect(() => extendedEuclideanGCD('240', 46)).toThrowError(new TypeError('Not a Number'))
    expect(() => extendedEuclideanGCD([240, 46])).toThrowError(new TypeError('Not a Number'))
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Factorial.test.js
import { calcFactorial } from '../Factorial'

describe('calcFactorial', () => {
  it('should return a statement for value "0"', () => {
    expect(calcFactorial(0)).toBe('The factorial of 0 is 1.')
  })

  it('should return a statement for "null" and "undefined"', () => {
    const nullFactorial = calcFactorial(null)
    const undefinedFactorial = calcFactorial(undefined)

    expect(nullFactorial).toBe(
      'Sorry, factorial does not exist for null or undefined numbers.'
    )
    expect(undefinedFactorial).toBe(
      'Sorry, factorial does not exist for null or undefined numbers.'
    )
  })

  it('should not support negative numbers', () => {
    const negativeFactorial = calcFactorial(-5)
    expect(negativeFactorial).toBe(
      'Sorry, factorial does not exist for negative numbers.'
    )
  })

  it('should return the factorial of a positive number', () => {
    const positiveFactorial = calcFactorial(3)
    expect(positiveFactorial).toBe('The factorial of 3 is 6')
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Factors.test.js
import { factorsOfANumber } from '../Factors'

describe('Factors', () => {
  factorsOfANumber(50).forEach((num) => {
    it(`${num} is a factor of 50`, () => {
      const isFactor = 50 % num === 0
      expect(isFactor).toBeTruthy()
    })
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/FareyApproximation.test.js
import { fareyApproximation } from '../FareyApproximation'

describe('fareyApproximation', () => {
  it('Return Farey Approximation of 0.7538385', () => {
    const approx = fareyApproximation(0.7538385)
    expect(approx).toStrictEqual({ numerator: 52, denominator: 69 })
  })

  it('Return Farey Approximation of 0.23584936', () => {
    const approx = fareyApproximation(0.23584936)
    expect(approx).toStrictEqual({ numerator: 196, denominator: 831 })
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/FermatPrimalityTest.test.js
import { fermatPrimeCheck, modularExponentiation } from '../FermatPrimalityTest'

describe('modularExponentiation', () => {
  it('should give the correct output for all exponentiations', () => {
    expect(modularExponentiation(38, 220, 221)).toBe(1)
    expect(modularExponentiation(24, 220, 221)).toBe(81)
  })
})

describe('fermatPrimeCheck', () => {
  it('should give the correct output for prime and composite numbers', () => {
    expect(fermatPrimeCheck(2, 35)).toBe(true)
    expect(fermatPrimeCheck(10, 30)).toBe(false)
    expect(fermatPrimeCheck(94286167)).toBe(true)
    expect(fermatPrimeCheck(83165867)).toBe(true)
    expect(fermatPrimeCheck(13268774)).toBe(false)
    expect(fermatPrimeCheck(13233852)).toBe(false)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Fibonacci.test.js
import {
  FibonacciDpWithoutRecursion,
  FibonacciRecursiveDP,
  FibonacciIterative,
  FibonacciRecursive,
  FibonacciMatrixExpo
} from '../Fibonacci'

describe('Fibonacci', () => {
  it('should return an array of numbers for FibonacciIterative', () => {
    expect(FibonacciIterative(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return an array of numbers for FibonacciRecursive', () => {
    expect(FibonacciRecursive(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return number for FibonacciRecursiveDP', () => {
    expect(FibonacciRecursiveDP(5)).toBe(5)
  })

  it('should return an array of numbers for FibonacciDpWithoutRecursion', () => {
    expect(FibonacciDpWithoutRecursion(5)).toEqual(
      expect.arrayContaining([1, 1, 2, 3, 5])
    )
  })

  it('should return number for FibonacciMatrixExpo', () => {
    expect(FibonacciMatrixExpo(0)).toBe(0)
    expect(FibonacciMatrixExpo(1)).toBe(1)
    expect(FibonacciMatrixExpo(2)).toBe(1)
    expect(FibonacciMatrixExpo(3)).toBe(2)
    expect(FibonacciMatrixExpo(4)).toBe(3)
    expect(FibonacciMatrixExpo(5)).toBe(5)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/FigurateNumber.test.js
import {
  isTriangular,
  isTetrahedral,
  isPentatope,
  checkAll
} from '../FigurateNumber'

describe('FigurateNumber', () => {
  it('Triangular : should return true', () => {
    expect(isTriangular(1)).toEqual(true)
  })
  it('Triangular : should return true', () => {
    expect(isTriangular(3)).toEqual(true)
  })

  it('Triangular : should return false', () => {
    expect(isTriangular(5)).toEqual(false)
  })

  it('Triangular : should return true', () => {
    expect(isTriangular(171)).toEqual(true)
  })
  /** End */

  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(1)).toEqual(true)
  })
  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(4)).toEqual(true)
  })

  it('Tetrahedral : should return false', () => {
    expect(isTetrahedral(3)).toEqual(false)
  })

  it('Tetrahedral : should return true', () => {
    expect(isTetrahedral(165)).toEqual(true)
  })

  /** End */
  it('Pentatope : should return true', () => {
    expect(isPentatope(1)).toEqual(true)
  })
  it('Pentatope : should return true', () => {
    expect(isPentatope(5)).toEqual(true)
  })

  it('Pentatope : should return false', () => {
    expect(isPentatope(3)).toEqual(false)
  })

  it('Pentatope : should return true', () => {
    expect(isPentatope(1001)).toEqual(true)
  })
  /** End */

  it('Check All : should return all true', () => {
    expect(checkAll(1)).toEqual({
      isTriangular: true,
      isTetrahedral: true,
      isPentatope: true
    })
  })

  it('Check All : should return all true,true,false', () => {
    expect(checkAll(15)).toEqual({
      isTriangular: true,
      isTetrahedral: false,
      isPentatope: true
    })
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/FindHcf.test.js
import { findHCF } from '../FindHcf'

describe('findHCF', () => {
  it('should throw a statement for values less than 1', () => {
    expect(findHCF(0, 0)).toBe('Please enter values greater than zero.')
  })

  it('should throw a statement for one value less than 1', () => {
    expect(findHCF(0, 1)).toBe('Please enter values greater than zero.')
    expect(findHCF(1, 0)).toBe('Please enter values greater than zero.')
  })

  it('should return an error for values non-integer values', () => {
    expect(findHCF(2.24, 4.35)).toBe('Please enter whole numbers.')
  })

  it('should return the HCF of two given integers', () => {
    expect(findHCF(27, 36)).toBe(9)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/FindLcm.test.js
import { findLcm } from '../FindLcm'

describe('findLcm', () => {
  it('should throw a statement for values less than 1', () => {
    expect(findLcm(0, 0)).toBe('Please enter values greater than zero.')
  })

  it('should throw a statement for one value less than 1', () => {
    expect(findLcm(1, 0)).toBe('Please enter values greater than zero.')
    expect(findLcm(0, 1)).toBe('Please enter values greater than zero.')
  })

  it('should return an error for values non-integer values', () => {
    expect(findLcm(4.564, 7.39)).toBe('Please enter whole numbers.')
  })

  it('should return the LCM of two given integers', () => {
    expect(findLcm(27, 36)).toBe(108)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/FindMin.test.js
import { findMin } from '../FindMin'

describe('FindMin', () => {
  test('Should return the minimum number in the array', () => {
    const min = findMin(2, 5, 1, 12, 43, 1, 9)
    expect(min).toBe(1)
  })

  test('Should return the minimum number in the array', () => {
    const min = findMin(21, 513, 6)
    expect(min).toBe(6)
  })

  test('Should throw error', () => {
    const min = () => findMin()
    expect(min).toThrow('Array is empty')
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/GridGet.test.js
import { gridGetX, gridGetY } from '../GridGet'

describe('GridGet', () => {
  it('should have a value of x for the 27th element if the square array has 400 elements', () => {
    expect(gridGetX(Math.sqrt(400), 27)).toEqual(8)
  })
  it('should have a value of x for the 11th element if the square array has 7 columns and 3 rows', () => {
    expect(gridGetX(7, 11)).toEqual(5)
  })
  it('should have a value of y for the 27th element if the square array has 400 elements', () => {
    expect(gridGetY(Math.sqrt(400), 27)).toEqual(2)
  })
  it('should have a value of y for the 11th element if the square array has 7 columns and 3 rows ', () => {
    expect(gridGetX(7, 11)).toEqual(5)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/IsDivisible.test.js
import { isDivisible } from '../IsDivisible'

describe('isDivisible', () => {
  const testCases = [
    [0, 1, true],
    [0, 2, true],
    [1, 1, true],
    [1, 2, false],
    [2, 1, true],
    [4, 4, true],
    [16, 4, true],
    [36978235, 5, true],
    [36978235, 4, false],
    [4.5, 1.5, true],
    [4.5, 1.2, false],
    [5, 0, false],
    [5, -0, false]
  ]

  test.each(testCases)('if parameters are (%i, %i) it returns %p', (dividend, divisor, expected) => {
    expect(isDivisible(dividend, divisor)).toBe(expected)
  })

  const errorCases = [
    [NaN, NaN],
    [NaN, 1],
    [1, NaN],
    ['1', 1],
    [1, '1'],
    [1, true],
    [false, 2]
  ]

  test.each(errorCases)('throws an error if parameters are (%p, %p)', (dividend, divisor) => {
    expect(() => {
      isDivisible(dividend, divisor)
    }).toThrow()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/IsEven.test.js
import { isEven, isEvenBitwise } from '../IsEven'

test('should return if the number is even or not', () => {
  const isEvenNumber = isEven(4)
  expect(isEvenNumber).toBe(true)
})

test('should return if the number is even or not', () => {
  const isEvenNumber = isEven(7)
  expect(isEvenNumber).toBe(false)
})

test('should return if the number is even or not', () => {
  const isEvenNumber = isEvenBitwise(6)
  expect(isEvenNumber).toBe(true)
})

test('should return if the number is even or not', () => {
  const isEvenNumber = isEvenBitwise(3)
  expect(isEvenNumber).toBe(false)
})

--#

--% C:/work/algos/Javascript/Maths/test/LeapYear.test.js
import { isLeapYear } from '../LeapYear'

describe('Leap Year', () => {
  it('Should return true on the year 2000', () => {
    expect(isLeapYear(2000)).toBe(true)
  })
  it('Should return false on the year 2001', () => {
    expect(isLeapYear(2001)).toBe(false)
  })
  it('Should return false on the year 2002', () => {
    expect(isLeapYear(2002)).toBe(false)
  })
  it('Should return false on the year 2003', () => {
    expect(isLeapYear(2003)).toBe(false)
  })
  it('Should return false on the year 2004', () => {
    expect(isLeapYear(2004)).toBe(true)
  })
  it('Should return false on the year 1900', () => {
    expect(isLeapYear(1900)).toBe(false)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/LinearSieve.test.js
import { LinearSieve } from '../LinearSieve'
import { PrimeCheck } from '../PrimeCheck'

describe('LinearSieve', () => {
  it('should return primes below 100', () => {
    expect(LinearSieve(100)).toEqual([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
  })

  it('should return primes only', () => {
    const n = 100000
    const primes = LinearSieve(n)
    for (const p of primes) {
      expect(PrimeCheck(p)).toBeTruthy()
    }
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/LucasSeries.test.js
import { lucas } from '../LucasSeries'

describe('Nth Lucas Number', () => {
  it('should return the 20th Lucas Number', () => {
    expect(lucas(20)).toBe(15127)
  })

  it('should return the 20th Lucas Number', () => {
    expect(lucas(0)).toBe(2)
  })

  it('should return the 20th Lucas Number', () => {
    expect(lucas(100)).toBe(792070839848372100000)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Mandelbrot.manual-test.js
import { getRGBData } from '../Mandelbrot'

// plot the results if the script is executed in a browser with a window-object
if (typeof window !== 'undefined') {
  const rgbData = getRGBData()
  const width = rgbData.length
  const height = rgbData[0].length
  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  const ctx = canvas.getContext('2d')
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const rgb = rgbData[x][y]
      ctx.fillStyle = 'rgb(' + rgb[0] + ',' + rgb[1] + ',' + rgb[2] + ')'
      ctx.fillRect(x, y, 1, 1)
    }
  }
  document.body.append(canvas)
}

--#

--% C:/work/algos/Javascript/Maths/test/Mandelbrot.test.js
import { getRGBData } from '../Mandelbrot'

describe('Mandelbrot', () => {
  it('should produce black pixels inside the set', () => {
    const blackAndWhite = getRGBData(800, 600, -0.6, 0, 3.2, 50, false)
    expect(blackAndWhite[400][300]).toEqual([0, 0, 0]) // black

    const colorCoded = getRGBData(800, 600, -0.6, 0, 3.2, 50, true)
    expect(colorCoded[400][300]).toEqual([0, 0, 0]) // black
  })

  it('should produce white pixels outside of the set', () => {
    const blackAndWhite = getRGBData(800, 600, -0.6, 0, 3.2, 50, false)
    expect(blackAndWhite[0][0]).toEqual([255, 255, 255]) // black
  })

  it('should produce colored pixels distant to the set', () => {
    const colorCoded = getRGBData(800, 600, -0.6, 0, 3.2, 50, true)
    expect(colorCoded[0][0]).toEqual([255, 0, 0]) // red
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/MeanSquareError.test.js
import { meanSquaredError } from '../MeanSquareError'

describe('meanSquareError', () => {
  it('should throw an error on non-array arguments', () => {
    expect(() => meanSquaredError(1, 4)).toThrow('Argument must be an Array')
  })

  it('should throw an error on non equal length ', () => {
    const firstArr = [1, 2, 3, 4, 5]
    const secondArr = [1, 2, 3]
    expect(() => meanSquaredError(firstArr, secondArr)).toThrow(
      'The two lists must be of equal length'
    )
  })

  it('should return the mean square error of two equal length arrays', () => {
    const firstArr = [1, 2, 3, 4, 5]
    const secondArr = [1, 3, 5, 6, 7]
    expect(meanSquaredError(firstArr, secondArr)).toBe(2.6)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/MidpointIntegration.test.js
import { integralEvaluation } from '../MidpointIntegration'

test('Should return the integral of f(x) = sqrt(x) in [1, 3] to be equal 2.797434', () => {
  const result = integralEvaluation(10000, 1, 3, (x) => { return Math.sqrt(x) })
  expect(Number(result.toPrecision(6))).toBe(2.79743)
})

test('Should return the integral of f(x) = sqrt(x) + x^2 in [1, 3] to be equal 11.46410161', () => {
  const result = integralEvaluation(10000, 1, 3, (x) => { return Math.sqrt(x) + Math.pow(x, 2) })
  expect(Number(result.toPrecision(10))).toBe(11.46410161)
})

test('Should return the integral of f(x) = log(x) + Pi*x^3 in [5, 12] to be equal 15809.9141543', () => {
  const result = integralEvaluation(20000, 5, 12, (x) => { return Math.log(x) + Math.PI * Math.pow(x, 3) })
  expect(Number(result.toPrecision(10))).toBe(15809.91415)
})

--#

--% C:/work/algos/Javascript/Maths/test/ModularBinaryExponentiationRecursive.test.js
import { modularBinaryExponentiation } from '../ModularBinaryExponentiationRecursive'

describe('modularBinaryExponentiation', () => {
  it('should return the binary exponentiation', () => {
    expect(modularBinaryExponentiation(2, 10, 17)).toBe(4)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/NumberOfDigits.test.js
import { numberOfDigit } from '../NumberOfDigits'

describe('NumberOfDigits', () => {
  it('should return the correct number of digits for an integer', () => {
    expect(numberOfDigit(1234000)).toBe(7)
  })

  it('should return the correct number of digits for a negative number', () => {
    expect(numberOfDigit(-2346243)).toBe(7)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Palindrome.test.js
import { PalindromeRecursive, PalindromeIterative } from '../Palindrome'

describe('Palindrome', () => {
  it('should return true for a palindrome for PalindromeRecursive', () => {
    expect(PalindromeRecursive('mom')).toBeTruthy()
  })
  it('should return true  for a palindrome for PalindromeIterative', () => {
    expect(PalindromeIterative('mom')).toBeTruthy()
  })
  it('should return false for a non-palindrome for PalindromeRecursive', () => {
    expect(PalindromeRecursive('Algorithms')).toBeFalsy()
  })
  it('should return true  for a non-palindrome for PalindromeIterative', () => {
    expect(PalindromeIterative('JavaScript')).toBeFalsy()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PascalTriangle.test.js
import { generate } from '../PascalTriangle'

describe('Pascals Triangle', () => {
  it('should have the the same length as the number', () => {
    const pascalsTriangle = generate(5)
    expect(pascalsTriangle.length).toEqual(5)
  })
  it('should have same length as its index in the array', () => {
    const pascalsTriangle = generate(5)
    pascalsTriangle.forEach((arr, index) => {
      expect(arr.length).toEqual(index + 1)
    })
  })
  it('should return an array of arrays', () => {
    const pascalsTriangle = generate(3)
    expect(pascalsTriangle).toEqual(
      expect.arrayContaining([[1], [1, 1], [1, 2, 1]])
    )
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PerfectCube.test.js
import { perfectCube } from '../PerfectCube'

describe('PerfectCube', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectCube(125)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectCube(100)).toBeFalsy()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PerfectNumber.test.js
import { perfectNumber } from '../PerfectNumber'

describe('PerfectNumber', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectNumber(28)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectNumber(10)).toBeFalsy()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PerfectSquare.test.js
import { perfectSquare } from '../PerfectSquare'

describe('PerfectSquare', () => {
  it('should return true for a perfect cube', () => {
    expect(perfectSquare(16)).toBeTruthy()
  })
  it('should return false for a non perfect cube', () => {
    expect(perfectSquare(10)).toBeFalsy()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PermutationAndCombination.test.js
import { factorial, permutation, combination } from '../PermutationAndCombination'

describe('Factorial', () => {
  it('factorial(5)', () => {
    expect(factorial(5)).toBe(120)
  })
})

describe('Permutation', () => {
  it('permutation(5, 2)', () => {
    expect(permutation(5, 2)).toBe(20)
  })
})

describe('Combination', () => {
  it('combination(5, 2)', () => {
    expect(combination(5, 2)).toBe(10)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PiApproximationMonteCarlo.test.js
import { piEstimation } from '../PiApproximationMonteCarlo'

describe('PiApproximationMonteCarlo', () => {
  it('should be between the range of 2 to 4', () => {
    const pi = piEstimation()
    const piRange = pi >= 2 && pi <= 4
    expect(piRange).toBeTruthy()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Polynomial.test.js
import { Polynomial } from '../Polynomial'

describe('Polynomial', () => {
  it('should not return a expression for zero', () => {
    const polynomial = new Polynomial([0])
    expect(polynomial.display()).toBe('')
  })
  it('should not return an expression for zero values', () => {
    const polynomial = new Polynomial([0, 0, 0, 0, 0])
    expect(polynomial.display()).toBe('')
  })
  it('should return an expression for single a non zero value', () => {
    const polynomial = new Polynomial([9])
    expect(polynomial.display()).toBe('(9)')
  })
  it('should return an expression for two values', () => {
    const polynomial = new Polynomial([3, 2])
    expect(polynomial.display()).toBe('(2x) + (3)')
  })
  it('should return an expression for values including zero', () => {
    const polynomial = new Polynomial([0, 2])
    expect(polynomial.display()).toBe('(2x)')
  })
  it('should return an expression and evaluate it', () => {
    const polynomial = new Polynomial([1, 2, 3, 4])
    expect(polynomial.display()).toBe('(4x^3) + (3x^2) + (2x) + (1)')
    expect(polynomial.evaluate(2)).toEqual(49)
  })
  it('should evaluate 0 for zero values', () => {
    const polynomial = new Polynomial([0, 0, 0, 0])
    expect(polynomial.evaluate(5)).toEqual(0)
  })
  it('should evaluate for negative values', () => {
    const polynomial = new Polynomial([-1, -3, -4, -7])
    expect(polynomial.evaluate(-5)).toBe(789)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Pow.test.js
import { pow } from '../Pow'

describe('Pow', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(pow(2, 0)).toBe(1)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(pow(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(pow(24, 4)).toBe(331776)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PowLogarithmic.test.js
import { powLogarithmic } from '../PowLogarithmic'

describe('PowLogarithmic', () => {
  it('should return 1 for numbers with exponent 0', () => {
    expect(powLogarithmic(2, 0)).toBe(1)
  })

  it('should return 0 for numbers with base 0', () => {
    expect(powLogarithmic(0, 23)).toBe(0)
  })

  it('should return the base to the exponent power', () => {
    expect(powLogarithmic(24, 4)).toBe(331776)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PrimeCheck.test.js
import { PrimeCheck } from '../PrimeCheck'

describe('PrimeCheck', () => {
  it('should return true for Prime Numbers', () => {
    expect(PrimeCheck(1000003)).toBeTruthy()
  })
  it('should return false for Non Prime Numbers', () => {
    expect(PrimeCheck(1000001)).toBeFalsy()
  })
  it('should return false for 1 and 0', () => {
    expect(PrimeCheck(1)).toBeFalsy()
    expect(PrimeCheck(0)).toBeFalsy()
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/PrimeFactors.test.js
import { PrimeFactors } from '../PrimeFactors'

describe('EulersTotient', () => {
  it('should return the prime factors for 100', () => {
    expect(PrimeFactors(100)).toEqual([2, 2, 5, 5])
  })

  it('should return the prime factors for 2560', () => {
    expect(PrimeFactors(2560)).toEqual([2, 2, 2, 2, 2, 2, 2, 2, 2, 5])
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/RadianToDegree.test.js
import { radianToDegree } from '../RadianToDegree'

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(0)
  expect(degreeEqual).toBe(0)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI / 4)
  expect(degreeEqual).toBe(45)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI / 2)
  expect(degreeEqual).toBe(90)
})

test('should convert radian to degree:', () => {
  const degreeEqual = radianToDegree(Math.PI)
  expect(degreeEqual).toBe(180)
})

--#

--% C:/work/algos/Javascript/Maths/test/ReversePolishNotation.test.js
import { calcRPN } from '../ReversePolishNotation'

describe('ReversePolishNotation', () => {
  it('should evaluate correctly for two values', () => {
    expect(calcRPN('2 3 +')).toEqual(5)
  })
  it("should evaluate' for multiple values", () => {
    expect(calcRPN('2 2 2 * +')).toEqual(6)
    expect(calcRPN('6 9 7 + 2 / + 3 *')).toEqual(42)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/SieveOfEratosthenes.test.js
import { sieveOfEratosthenes } from '../SieveOfEratosthenes'
import { PrimeCheck } from '../PrimeCheck'

describe('should return an array of prime booleans', () => {
  it('should have each element in the array as a prime boolean', () => {
    const n = 30
    const primes = sieveOfEratosthenes(n)
    primes.forEach((primeBool, index) => {
      if (primeBool) {
        expect(PrimeCheck(index)).toBeTruthy()
      }
    })
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/SimpsonIntegration.test.js
import { integralEvaluation } from '../SimpsonIntegration'

test('Should return the integral of f(x) = sqrt(x) in [1, 3] to be equal 2.797434', () => {
  const result = integralEvaluation(16, 1, 3, (x) => { return Math.sqrt(x) })
  expect(Number(result.toPrecision(7))).toBe(2.797434)
})

test('Should return the integral of f(x) = sqrt(x) + x^2 in [1, 3] to be equal 11.46410161', () => {
  const result = integralEvaluation(64, 1, 3, (x) => { return Math.sqrt(x) + Math.pow(x, 2) })
  expect(Number(result.toPrecision(10))).toBe(11.46410161)
})

test('Should return the integral of f(x) = log(x) + Pi*x^3 in [5, 12] to be equal 15809.9141543', () => {
  const result = integralEvaluation(128, 5, 12, (x) => { return Math.log(x) + Math.PI * Math.pow(x, 3) })
  expect(Number(result.toPrecision(12))).toBe(15809.9141543)
})

--#

--% C:/work/algos/Javascript/Maths/test/Softmax.test.js
import { Softmax } from '../Softmax'

describe('Softmax', () => {
  it('should return equal distribution of 1 for equal input values', () => {
    expect(Softmax([1, 1])).toEqual([0.5, 0.5])
    expect(Softmax([1, 1, 1, 1])).toEqual([0.25, 0.25, 0.25, 0.25])
  })

  it('should return values which sum to the value of 1', () => {
    expect(Softmax([1, 2, 3, 4]).reduce((a, b) => a + b, 0)).toEqual(1)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/SumOfDigits.test.js
import { sumOfDigitsUsingLoop, sumOfDigitsUsingRecursion, sumOfDigitsUsingString } from '../SumOfDigits'

test('Testing on sumOfDigitsUsingLoop', () => {
  const sum = sumOfDigitsUsingLoop(123)
  expect(sum).toBe(6)
})

test('Testing on sumOfDigitsUsingRecursion', () => {
  const sum = sumOfDigitsUsingRecursion(123)
  expect(sum).toBe(6)
})

test('Testing on sumOfDigitsUsingString', () => {
  const sum = sumOfDigitsUsingString(123)
  expect(sum).toBe(6)
})

--#

--% C:/work/algos/Javascript/Maths/test/SumOfGeometricProgression.test.js
import { sumOfGeometricProgression } from '../SumOfGeometricProgression'

describe('Sum Of Geometric Progression', () => {
  it('should return the sum of a finite GP', () => {
    expect(sumOfGeometricProgression(100, 1.5, 4)).toBe(812.5)
  })

  it('should return the sum of an infinite GP', () => {
    expect(sumOfGeometricProgression(2, 0.5, Infinity)).toBe(4)
  })
})

--#

--% C:/work/algos/Javascript/Maths/test/Volume.test.js
import * as volume from '../Volume'

test('Testing on volCuboid', () => {
  const volCuboid = volume.volCuboid(2.0, 5.0, 3)
  expect(volCuboid).toBe(30.0)
})

test('Testing on volCube', () => {
  const volCube = volume.volCube(2.0)
  expect(volCube).toBe(8.0)
})

test('Testing on volCone', () => {
  const volCone = volume.volCone(3.0, 8.0)
  expect(volCone).toBe(75.39822368615503)
})

test('Testing on volPyramid', () => {
  const volPyramid = volume.volPyramid(2.0, 3.0, 8.0)
  expect(volPyramid).toBe(16.0)
})

test('Testing on volCylinder', () => {
  const volCylinder = volume.volCylinder(3.0, 8.0)
  expect(volCylinder).toBe(226.1946710584651)
})

test('Testing on volTriangularPrism', () => {
  const volTriangularPrism = volume.volTriangularPrism(3.0, 6.0, 8.0)
  expect(volTriangularPrism).toBe(72.0)
})

test('Testing on volPentagonalPrism', () => {
  const volPentagonalPrism = volume.volPentagonalPrism(1.0, 4.0, 8.0)
  expect(volPentagonalPrism).toBe(80.0)
})

test('Testing on volSphere', () => {
  const volSphere = volume.volSphere(4.0)
  expect(volSphere).toBe(268.082573106329)
})

test('Testing on volHemisphere', () => {
  const volHemisphere = volume.volHemisphere(4.0)
  expect(volHemisphere).toBe(134.0412865531645)
})

--#

--% C:/work/algos/Javascript/Navigation/Haversine.js
/**
 * @function HaversineDistance
 * @description Calculate the distance between two coordinates using the haversine formula
 * @param {Integer} latitude1 - The input integer
 * @param {Integer} latitude2 - The input integer
 * @param {Integer} longitude1 - The input integer
 * @param {Integer} longitude2 - The input integer
 * @return {Integer} Haversine Distance.
 * @see [Haversine_Distance](https://pt.wikipedia.org/wiki/F%C3%B3rmula_de_Haversine)
 */
const haversineDistance = (latitude1 = 0, longitude1 = 0, latitude2 = 0, longitude2 = 0) => {
  validateLatOrLong(latitude1)
  validateLatOrLong(latitude2)
  validateLatOrLong(longitude1)
  validateLatOrLong(longitude2)
  const earthRadius = 6371e3 // 6,371km
  const pi = Math.PI
  const cos1 = latitude1 * pi / 180.0
  const cos2 = latitude2 * pi / 180.0
  const deltaLatitude = (latitude2 - latitude1) * pi / 180.0
  const deltaLongitude = (longitude2 - longitude1) * pi / 180.0

  const alpha = Math.sin(deltaLatitude / 2) * Math.sin(deltaLatitude / 2) + Math.cos(cos1) * Math.cos(cos2) * Math.sin(deltaLongitude / 2) * Math.sin(deltaLongitude / 2)
  const constant = 2 * Math.atan2(Math.sqrt(alpha), Math.sqrt(1 - alpha))
  return earthRadius * constant
}

const validateLatOrLong = value => {
  if (typeof value !== 'number') {
    throw new TypeError('The value of latitude or longitude should be a number')
  }
}

export { haversineDistance }

--#

--% C:/work/algos/Javascript/Navigation/test/Haversine.test.js
import { haversineDistance } from '../Haversine'

describe('Testing the haversine distance calculator', () => {
  it('Calculate distance', () => {
    const distance = haversineDistance(64.1265, -21.8174, 40.7128, -74.0060)
    expect(distance).toBe(4208198.758424171)
  })
  it('Test validation, expect throw', () => {
    expect(() => haversineDistance(64.1265, -21.8174, 40.7128, '74.0060')).toThrow()
  })
})

--#

--% C:/work/algos/Javascript/Project-Euler/Problem001.js
// https://projecteuler.net/problem=1
/*    Multiples of 3 and 5
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
Find the sum of all the multiples of 3 or 5 below the provided parameter value number.
*/

const multiplesThreeAndFive = (num) => {
  let total = 0
  // total for calculating the sum
  for (let i = 0; i < num; i++) {
    if (i % 3 === 0 || i % 5 === 0) {
      total += i
    }
  }
  return total
}

export { multiplesThreeAndFive }

--#

--% C:/work/algos/Javascript/Project-Euler/Problem002.js
// https://projecteuler.net/problem=2
const SQ5 = 5 ** 0.5 // Square root of 5
const PHI = (1 + SQ5) / 2 // definition of PHI

// theoretically it should take O(1) constant amount of time as long
// arithmetic calculations are considered to be in constant amount of time
export const EvenFibonacci = (limit) => {
  const highestIndex = Math.floor(Math.log(limit * SQ5) / Math.log(PHI))
  const n = Math.floor(highestIndex / 3)
  return ((PHI ** (3 * n + 3) - 1) / (PHI ** 3 - 1) -
    ((1 - PHI) ** (3 * n + 3) - 1) / ((1 - PHI) ** 3 - 1)) / SQ5
}

--#

--% C:/work/algos/Javascript/Project-Euler/Problem003.js
// https://projecteuler.net/problem=3

export const largestPrime = (num = 600851475143) => {
  let newnumm = num
  let largestFact = 0
  let counter = 2
  while (counter * counter <= newnumm) {
    if (newnumm % counter === 0) {
      newnumm = newnumm / counter
    } else {
      counter++
    }
  }
  if (newnumm > largestFact) {
    largestFact = newnumm
  }
  return largestFact
}

--#

--% C:/work/algos/Javascript/Project-Euler/Problem004.js
// https://projecteuler.net/problem=4
/* A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91  99.
   Find the largest palindrome made from the product of two 3-digit numbers.
*/
export const largestPalindromic = (digits) => {
  let i
  let n
  let m
  let d
  let limit
  let number = 0

  for (i = 1; i < digits; i++) {
    number = 10 * number + 9
  }
  const inf = number // highest (digits - 1) number, in this example highest 2 digit number
  const sup = 10 * number + 9 // highest (digits) number, in this example highest 3 digit number

  const isPalindromic = (n) => {
    let p = 0
    const q = n
    let r
    while (n > 0) {
      r = n % 10
      p = 10 * p + r
      n = Math.floor(n / 10)
    }
    return p === q // returning whether the number is palindromic or not
  }

  for (n = sup * sup, m = inf * inf; n > m; n--) {
    if (isPalindromic(n)) {
      limit = Math.ceil(Math.sqrt(n))
      d = sup
      while (d >= limit) {
        if (n % d === 0 && n / d > inf) {
          return n
        }
        d -= 1
      }
    }
  }
  return NaN // returning not a number, if any such case arise
}

--#

--% C:/work/algos/Javascript/Project-Euler/Problem005.js
/*
Smallest multiple

2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
*/

export const findSmallestMultiple = () => {
  const divisors = [20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2]
  let num = 21
  let result

  while (!result) {
    const isDivisibleByAll = divisors.every((divisor) => num % divisor === 0)
    if (isDivisibleByAll) result = num
    else num++
  }

  return result
}

--#

--% C:/work/algos/Javascript/Project-Euler/Problem006.js
// https://projecteuler.net/problem=6

export const squareDifference = (num = 100) => {
  let sumOfSquares = 0
  let sums = 0
  for (let i = 1; i <= num; i++) {
    sumOfSquares += i ** 2 // add squares to the sum of squares
    sums += i // add number to sum to square later
  }
  return (sums ** 2) - sumOfSquares // difference of square of the total sum and sum of squares
}

--#

--% C:/work/algos/Javascript/Project-Euler/Problem008.js
// Problem: https://projecteuler.net/problem=8

const largestAdjacentNumber = (grid, consecutive) => {
  grid = grid.split('\n').join('')
  const splitedGrid = grid.split('\n')
  let largestProd = 0

  for (const row in splitedGrid) {
    const currentRow = splitedGrid[row].split('').map(x => Number(x))

    for (let i = 0; i < currentRow.length - consecutive; i++) {
      const combine = currentRow.slice(i, i + consecutive)

      if (!combine.includes(0)) {
        const product = combine.reduce(function (a, b) {
          return a * b
        })

        if (largestProd < product) largestProd = product
      }
    }
  }
  return largestProd
}

export { largestAdjacentNumber }

--#

--% C:/work/algos/Javascript/Project-Euler/Problem009.js
/*
Special Pythagorean triplet

A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

a^2 + b^2 = c^2
For example, 32 + 42 = 9 + 16 = 25 = 52.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
*/

const isPythagoreanTriplet = (a, b, c) => Math.pow(a, 2) + Math.pow(b, 2) === Math.pow(c, 2)

export const findSpecialPythagoreanTriplet = () => {
  for (let a = 0; a < 1000; a++) {
    for (let b = a + 1; b < 1000; b++) {
      for (let c = b + 1; c < 1000; c++) {
        if (isPythagoreanTriplet(a, b, c) && a + b + c === 1000) {
          return a * b * c
        }
      }
    }
  }
}

--#

--% C:/work/algos/Javascript/Project-Euler/Problem010.js
// https://projecteuler.net/problem=10

const isPrime = (number) => {
  if (number === 2) return true
  if (number % 2 === 0) return false

  for (let j = 3; j * j <= number; j += 2) {
    if (number % j === 0) {
      return false
    }
  }
  return true
}

const calculateSumOfPrimeNumbers = (maxNumber) => {
  let sum = 0
  for (let i = maxNumber - 1; i >= 2; i--) {
    if (isPrime(parseInt(i)) === true) {
      sum += i
    }
  }
  return sum
}
export { calculateSumOfPrimeNumbers }

--#

--% C:/work/algos/Javascript/Project-Euler/Problem012.js
/**
 * Problem 12 - Highly divisible triangular number
 *
 * https://projecteuler.net/problem=11
 *
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
 *
 * The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * Let us list the factors of the first seven triangle numbers:
 *
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over five divisors.
 *
 * What is the value of the first triangle number to have over five hundred divisors?
*/

/**
 * Gets number of divisors of a given number
 * @params num The number whose divisors to find
 */
const getNumOfDivisors = (num) => {
  // initialize numberOfDivisors
  let numberOfDivisors = 0

  // if one divisor less than sqrt(num) exists
  // then another divisor greater than sqrt(n) exists and its value is num/i
  const sqrtNum = Math.sqrt(num)
  for (let i = 0; i <= sqrtNum; i++) {
    // check if i divides num
    if (num % i === 0) {
      if (i === sqrtNum) {
        // if both divisors are equal, i.e., num is perfect square, then only 1 divisor
        numberOfDivisors++
      } else {
        // 2 divisors, one of them is less than sqrt(n), other greater than sqrt(n)
        numberOfDivisors += 2
      }
    }
  }
  return numberOfDivisors
}

/**
 * Loops till first triangular number with 500 divisors is found
 */
const firstTriangularWith500Divisors = () => {
  let triangularNum
  // loop forever until numOfDivisors becomes greater than or equal to 500
  for (let n = 1; ; n++) {
    // nth triangular number is (1/2)*n*(n+1) by Arithmetic Progression
    triangularNum = (1 / 2) * n * (n + 1)
    if (getNumOfDivisors(triangularNum) >= 500) return triangularNum
  }
}

export { firstTriangularWith500Divisors }

--#

--% C:/work/algos/Javascript/Project-Euler/Problem014.js
/*
Longest Collatz sequence

The following iterative sequence is defined for the set of positive integers:

n  n/2 (n is even)
n  3n + 1 (n is odd)

Using the rule above and starting with 13, we generate the following sequence:

13  40  20  10  5  16  8  4  2  1
It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.

Which starting number, under one million, produces the longest chain?

NOTE: Once the chain starts the terms are allowed to go above one million.
*/

const getCollatzSequenceLength = (num, seqLength) => {
  if (num === 1) {
    return seqLength
  } else {
    let newElement
    if (num % 2 === 0) {
      newElement = num / 2
    } else {
      newElement = (3 * num) + 1
    }
    seqLength++
    return getCollatzSequenceLength(newElement, seqLength)
  }
}

export const findLongestCollatzSequence = (limit = 1000000) => {
  let startingPointForLargestSequence = 1
  let largestSequenceLength = 1
  for (let i = 2; i < limit; i++) {
    const currentSequenceLength = getCollatzSequenceLength(i, 1)
    if (currentSequenceLength > largestSequenceLength) {
      startingPointForLargestSequence = i
      largestSequenceLength = currentSequenceLength
    }
  }
  return startingPointForLargestSequence
}

--#

--% C:/work/algos/Javascript/Project-Euler/Problem015.js
// https://projecteuler.net/problem=15
/* Starting in the top left corner of a 22 grid, and only being able to move to
the right and down, there are exactly 6 routes to the bottom right corner.
How many such routes are there through a 2020 grid?
*/

// A lattice path is composed of horizontal and vertical lines that pass through lattice points.

export const latticePath = (gridSize) => {
  let paths
  for (let i = 1, paths = 1; i <= gridSize; i++) {
    paths = paths * (gridSize + i) / i
  }
  // The total number of paths can be found using the binomial coefficient (b+a)/a.
  return paths
}

// > latticePath(20))
// 137846528820

--#

--% C:/work/algos/Javascript/Project-Euler/Problem016.js
/**
 * Problem 16 - Power digit sum
 *
 * @see {@link https://projecteuler.net/problem=16}
 *
 * 2 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
 *
 * What is the sum of the digits of the number 2 ?
 */

/**
 * Returns the power digit sum of n^pow.
 *
 * @param {number} [n=2]
 * @param {number} [pow=1000]
 * @returns {number}
 */
const powerDigitSum = function (n = 2, pow = 1000) {
  // The idea is to consider each digit (d*10^exp) separately, right-to-left.
  // digits = [units, tens, ...]

  const digits = [n]
  let p = 1

  while (++p <= pow) {
    let carry = 0
    for (let exp = 0; exp < digits.length; exp++) {
      const prod = digits[exp] * n + carry
      carry = Math.floor(prod / 10)
      digits[exp] = prod % 10
    }
    while (carry > 0) {
      digits.push(carry % 10)
      carry = Math.floor(carry / 10)
    }
  }

  // (digits are reversed but we only want the sum so it doesn't matter)

  return digits.reduce((prev, current) => prev + current, 0)
}

export { powerDigitSum }

--#

--% C:/work/algos/Javascript/Project-Euler/Problem018.js
/**
 * @file Provides solution for Project Euler Problem 18 - Maximum path sum I
 * @author Eric Lavault {@link https://github.com/lvlte}
 * @license MIT
 */

/**
 * Problem 18 - Maximum path sum I
 *
 * @see {@link https://projecteuler.net/problem=18}
 *
 * By starting at the top of the triangle below and moving to adjacent numbers
 * on the row below, the maximum total from top to bottom is 23 :
 *
 *                            3
 *                           7 4
 *                          2 4 6
 *                         8 5 9 3
 *
 * That is, 3 + 7 + 4 + 9 = 23.
 *
 * Find the maximum total from top to bottom of the triangle below :
 *
 *                            75
 *                           95 64
 *                         17 47 82
 *                        18 35 87 10
 *                      20 04 82 47 65
 *                     19 01 23 75 03 34
 *                   88 02 77 73 07 63 67
 *                  99 65 04 28 06 16 70 92
 *                41 41 26 56 83 40 80 70 33
 *               41 48 72 33 47 32 37 16 94 29
 *             53 71 44 65 25 43 91 52 97 51 14
 *            70 11 33 28 77 73 17 78 39 68 17 57
 *          91 71 52 38 17 14 91 43 58 50 27 29 48
 *         63 66 04 68 89 53 67 30 73 16 69 87 40 31
 *       04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
 *
 * NOTE: As there are only 16384 routes, it is possible to solve this problem
 * by trying every route. However, Problem 67, is the same challenge with a
 * triangle containing one-hundred rows; it cannot be solved by brute force,
 * and requires a clever method! ;o)
 */

const triangle = `
75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
`

export const maxPathSum = function (grid = triangle) {
  /**
   * If we reduce the problem to its simplest form, considering :
   *
   *         7      -> The max sum depends on the two adjacent numbers below 7,
   *        2 4        not 7 itself.
   *
   *    obviously 4 > 2 therefore the max sum is 7 + 4 = 11
   *
   *                       6
   * Likewise, with :     4 6     6 > 4 therefore the max sum is 6 + 6 = 12
   *
   * Now, let's say we are given :
   *
   *         3
   *        7 6
   *       2 4 6
   *
   *    and we decompose it into sub-problems such that each one fits the simple
   *    case above, we got :
   *
   *         .           .           3
   *        7 .         . 6         ? ?
   *       2 4 .       . 4 6       . . .
   *
   *    Again, considering any number, the best path depends on the two adjacent
   *    numbers below it, not the number itself. That's why we have to compute
   *    the max sum from bottom to top, replacing each number with the sum of
   *    that number plus the greatest of the two adjacent numbers computed from
   *    the previous row.
   *
   *          .          .              3              15
   *        11 .        . 12    ->    11 12    ->    x   x
   *       x  x .      . x  x        x  x  x        x  x  x
   *
   * We are simplifying a complicated problem by breaking it down into simpler
   * sub-problems in a recursive manner, this is called Dynamic Programming.
   */

  grid = grid.split(/\r\n|\n/).filter(l => l).map(r => r.split(' ').map(n => +n))

  for (let i = grid.length - 2; i >= 0; i--) {
    for (let j = 0; j < grid[i].length; j++) {
      grid[i][j] += Math.max(grid[i + 1][j], grid[i + 1][j + 1])
    }
  }

  return grid[0][0]
}

--#

--% C:/work/algos/Javascript/Project-Euler/Problem020.js
/**
 * Problem 20 - Factorial digit sum
 *
 * @see {@link https://projecteuler.net/problem=20}
 *
 * n! means n  (n  1)  ...  3  2  1
 *
 * For example, 10! = 10  9  ...  3  2  1 = 3628800,
 * and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27
 *
 * Find the sum of the digits in the number 100!
 */

const factorialDigitSum = (n = 100) => {
  // Consider each digit*10^exp separately, right-to-left ([units, tens, ...]).
  const digits = [1]

  for (let x = 2; x <= n; x++) {
    let carry = 0
    for (let exp = 0; exp < digits.length; exp++) {
      const prod = digits[exp] * x + carry
      carry = Math.floor(prod / 10)
      digits[exp] = prod % 10
    }
    while (carry > 0) {
      digits.push(carry % 10)
      carry = Math.floor(carry / 10)
    }
  }

  // (digits are reversed but we only want the sum so it doesn't matter)

  return digits.reduce((prev, current) => prev + current, 0)
}

export { factorialDigitSum }

--#

--% C:/work/algos/Javascript/Project-Euler/Problem023.js
/**
 * Problem 23 - Non-Abundant Sums
 *
 * @see {@link https://projecteuler.net/problem=23}
 *
 * A perfect number is a number for which the sum of its proper divisors is exactly equal to the number. For example, the sum of the proper divisors of 28 would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
 *
 * A number n is called deficient if the sum of its proper divisors is less than n and it is called abundant if this sum exceeds n.
 *
 * As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24. By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers. However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.
 *
 * Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
 *
 */

/**
 * collect the abundant numbers, generate and store their sums with each other, and check for numbers not in the llst of sums, adds them and returns their sum.
 * @param {number} [n = 28123]
 * @returns {number}
 */

function sumOfNonAbundantNumbers (n = 28123) {
  const abundantNumbers = [] // array to store the abundant numbers
  const sumOfAbundantNumbers = {} // instead of an array, checking an object takes way less time. sets may be used as well.
  let sum = 0

  for (let i = 1; i <= n; i++) {
    if (isAbundant(i)) {
      abundantNumbers.push(i) // collect the abundant numbers
      abundantNumbers.forEach(num => { // collect their sums
        const sum = num + i
        sumOfAbundantNumbers[sum] = true
      })
    }
  }

  for (let i = 1; i <= n; i++) {
    if (!sumOfAbundantNumbers[i]) { // if the number is not found in the list of sums, then it is added
      sum += i
    }
  }

  return sum
}

/**
 * generates the divisors of the number and checks if it is abundant
 * @param {number} number
 * @returns {bool}
 */

function isAbundant (number) {
  let sum = 0
  for (let i = 1; i <= number / 2; i++) {
    if (number % i === 0) { // generate divisors
      sum += i // calculate their sums
    }
  }
  return sum > number
}

export { sumOfNonAbundantNumbers }

--#

--% C:/work/algos/Javascript/Project-Euler/Problem025.js
/**
* Problem 25 - 1000-digit Fibonacci number
*
* @see {@link https://projecteuler.net/problem=25}
*
* The Fibonacci sequence is defined by the recurrence relation:
*
* Fn = Fn1 + Fn2, where F1 = 1 and F2 = 1.
*
* Hence the first 12 terms will be:
*
* F1 = 1
* F2 = 1
* F3 = 2
* F4 = 3
* F5 = 5
* F6 = 8
* F7 = 13
* F8 = 21
* F9 = 34
* F10 = 55
* F11 = 89
* F12 = 144
* The 12th term, F12, is the first term to contain three digits.

* What is the index of the first term in the Fibonacci sequence to contain 1000 digits?
*/

// brute force method

function fibonacciIndex (t = 1000) {
  const digits = 10n ** BigInt(t - 1)
  let fib0 = BigInt(0)
  let fib1 = BigInt(1)
  let index = 1
  while (fib1 < digits) { // using this to compare number of digits instead of .toString() significantly improved run time
    const tempfib = fib1
    fib1 = fib1 + fib0
    fib0 = tempfib
    index += 1
  }
  return (index)
}

export { fibonacciIndex }

--#

--% C:/work/algos/Javascript/Project-Euler/test/Problem008.test.js
import { largestAdjacentNumber } from '../Problem008'

const grid1 = `73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
38991007832084782777189757278819047278899274961949
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
82834772897718748193457134085784719857638187485919
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
83247832478757285710958372981577583275832789327921
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
84327878357761783787589375857378271083787811983779
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
82347875831098357801578571807585817518287829189189`

const grid2 = `73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450`

const grid3 = `89125732138957892357892768971807934878999818278898
48327483578957875827583295789187588875238579887789
74358275778171870973857835738758275210873583758279
81347834738473878758758373857893758787772897580719
81232847857895758758987587501087575387538183787098
17047878395783578750837100983787587582797837508298
42894789325732857893759187987487489748377578791989
82147328972387832578327581919827382758932789798289
83243289473847328974832947832748932472387895738978
84738294738973289578753287582375238957573297892398
29383748329748397483274832748327477575018978975289
48327483758375846372864736476478364783647463278787
73281473847832974328758975890189373857875875895898
74328978748329789357389578329758329758937893758979
81738957389579287598217589127589375893275987359889
71890743894732897510875895783297591085738975837897
10783974839479879857895789758975981735870175835789
01494787857897583758975849758475107589754897589789
09939858758919788017587897587387585775289757982898
74718478978758758975897589789789798789178957789789`

const grid4 = `99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999
99999999999999999999999999999999999999999999999999`

describe('checkLargestAdjacentNumberProduct', () => {
  it('Random Example', () => {
    const RESULT = largestAdjacentNumber(grid1, 13)
    expect(RESULT).toBe(23514624000)
  })
  it('Problem statement Example', () => {
    const RESULT = largestAdjacentNumber(grid2, 13)
    expect(RESULT).toBe(23514624000)
  })
  it('Random Example 2', () => {
    const RESULT = largestAdjacentNumber(grid3, 13)
    expect(RESULT).toBe(580717154304)
  })
  it('Example with all 9', () => {
    const RESULT = largestAdjacentNumber(grid4, 13)
    expect(RESULT).toBe(2541865828329)
  })
})

--#

--% C:/work/algos/Javascript/Project-Euler/test/Problem010.test.js
import { calculateSumOfPrimeNumbers } from '../Problem010'

describe('checkAnagram', () => {
  it('Return the sum of prime numbers up to but less than 14', () => {
    const SUT = calculateSumOfPrimeNumbers(14)
    expect(SUT).toBe(41)
  })
  it('Return the sum of prime numbers up to but less than 10', () => {
    const SUT = calculateSumOfPrimeNumbers(10)
    expect(SUT).toBe(17)
  })
  it('Return the sum of prime numbers up to but less than 100', () => {
    const SUT = calculateSumOfPrimeNumbers(100)
    expect(SUT).toBe(1060)
  })
})

--#

--% C:/work/algos/Javascript/Project-Euler/test/Problem012.test.js
import { firstTriangularWith500Divisors } from '../Problem012'

describe('checkFirstTriangularWith500Divisors()', () => {
  it('Problem Statement Answer', () => {
    const firstTriangular = firstTriangularWith500Divisors()
    expect(firstTriangular).toBe(76576500)
  })
})

--#

--% C:/work/algos/Javascript/Project-Euler/test/Problem016.test.js
import { powerDigitSum } from '../Problem016'

describe('Check Problem 16 - Power digit sum', () => {
  it('Power digit sum of 2^15', () => {
    expect(powerDigitSum(2, 15)).toBe(26)
  })

  it('Power digit sum of 2^1000', () => {
    expect(powerDigitSum()).toBe(1366)
    expect(powerDigitSum(2, 1000)).toBe(1366)
  })

  it('Power digit sum of 3^5000', () => {
    expect(powerDigitSum(3, 5000)).toBe(11097)
  })
})

--#

--% C:/work/algos/Javascript/Project-Euler/test/Problem018.test.js
import { maxPathSum } from '../Problem018'

const example = `
3
7 4
2 4 6
8 5 9 3
`

describe('Check Problem 18 - Maximum path sum I', () => {
  it('Check example', () => {
    expect(maxPathSum(example)).toBe(23)
  })

  it('Check solution', () => {
    expect(maxPathSum()).toBe(1074)
  })
})

--#

--% C:/work/algos/Javascript/Project-Euler/test/Problem020.test.js
import { factorialDigitSum } from '../Problem020'

describe('Check Problem 20 - Factorial digit sum', () => {
  it('Factorial digit sum of 10!', () => {
    expect(factorialDigitSum(10)).toBe(27)
  })

  it('Factorial digit sum of 100!', () => {
    expect(factorialDigitSum()).toBe(648)
    expect(factorialDigitSum(100)).toBe(648)
  })

  it('Factorial digit sum of 1000!', () => {
    expect(factorialDigitSum(1000)).toBe(10539)
  })
})

--#

--% C:/work/algos/Javascript/Project-Euler/test/Problem023.test.js
import { sumOfNonAbundantNumbers } from '../Problem023'

describe('Check Problem 23 - Non-Abundant Sums', () => {
  it('Sum of all positive integers <= 10000 which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(10000)).toBe(3731004)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(15000)).toBe(4039939)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(20000)).toBe(4159710)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(28123)).toBe(4179871)
  })

  it('Sum of all positive integers <= n which cannot be written as the sum of two abundant numbers', () => {
    expect(sumOfNonAbundantNumbers(30000)).toBe(4179871)
  })
})

--#

--% C:/work/algos/Javascript/Project-Euler/test/Problem025.test.js
import { fibonacciIndex } from '../Problem025'

describe('Check Problem 25 - 1000 digit Fibonnaci number', () => {
  it('First term of the Fibonnaci sequence containing 3 digits', () => {
    expect(fibonacciIndex(3)).toBe(12)
  })

  it('First term of the Fibonnaci sequence containing 10 digits', () => {
    expect(fibonacciIndex(10)).toBe(45)
  })

  it('First term of the Fibonnaci sequence containing 50 digits', () => {
    expect(fibonacciIndex(50)).toBe(237)
  })

  it('First term of the Fibonnaci sequence containing 100 digits', () => {
    expect(fibonacciIndex(100)).toBe(476)
  })

  it('First term of the Fibonnaci sequence containing 1000 digits', () => {
    expect(fibonacciIndex(1000)).toBe(4782)
  })

  it('First term of the Fibonnaci sequence containing 10000 digits', () => {
    expect(fibonacciIndex(10000)).toBe(47847)
  })
})

--#

--% C:/work/algos/Javascript/Recursive/BinaryEquivalent.js
/*
 * Problem Statement: Given a positive number `num`, find it's binary equivalent using recursion
 *
 * What is Binary Equivalent?
 * - In binary number system, a number is represented in terms of 0s and 1s,
 *   for example:
 *    - Binary Of 2 = 10
 *    - Binary of 3 = 11
 *    - Binary of 4 = 100
 *
 * Reference on how to find Binary Equivalent
 * - https://byjus.com/maths/decimal-to-binary/
 *
 */

export const binaryEquivalent = (num) => {
  if (num === 0 || num === 1) {
    return String(num)
  }
  return binaryEquivalent(Math.floor(num / 2)) + String(num % 2)
}

--#

--% C:/work/algos/Javascript/Recursive/BinarySearch.js

/**
 * @function BinarySearch
 * @description Search the integer inside the sorted integers array using Binary Search Algorithm.
 * @param {Integer[]} arr - sorted array of integers
 * @param {Integer} low - The input integer
 * @param {Integer} high - The input integer
 * @param {Integer} searchValue - The input integer
 * @return {Integer} - return index of searchValue if found else return -1.
 * @see [BinarySearch](https://en.wikipedia.org/wiki/Binary_search_algorithm)
 */

const binarySearch = (arr, searchValue, low = 0, high = arr.length - 1) => {
  // base case
  if (high < low || arr.length === 0) return -1

  const mid = low + Math.floor((high - low) / 2)

  // If the element is present at the middle
  if (arr[mid] === searchValue) {
    return mid
  }

  // If element is smaller than mid, then
  // it can only be present in left subarray
  if (arr[mid] > searchValue) {
    return binarySearch(arr, searchValue, low, mid - 1)
  }

  // Else the element can only be present in right subarray
  return binarySearch(arr, searchValue, mid + 1, high)
}

export { binarySearch }

--#

--% C:/work/algos/Javascript/Recursive/EucledianGCD.js
function euclideanGCDRecursive (first, second) {
  /*
    Calculates GCD of two numbers using Euclidean Recursive Algorithm
    :param first: First number
    :param second: Second number
    :return: GCD of the numbers
    */
  if (second === 0) {
    return first
  } else {
    return euclideanGCDRecursive(second, (first % second))
  }
}

function euclideanGCDIterative (first, second) {
  /*
    Calculates GCD of two numbers using Euclidean Iterative Algorithm
    :param first: First number
    :param second: Second number
    :return: GCD of the numbers
    */
  while (second !== 0) {
    const temp = second
    second = first % second
    first = temp
  }
  return first
}

export { euclideanGCDIterative, euclideanGCDRecursive }

--#

--% C:/work/algos/Javascript/Recursive/Factorial.js
/**
 * @function Factorial
 * @description function to find factorial using recursion.
 * @param {Integer} n - The input integer
 * @return {Integer} - Factorial of n.
 * @see [Factorial](https://en.wikipedia.org/wiki/Factorial)
 * @example 5! = 1*2*3*4*5 = 120
 * @example 2! = 1*2 = 2
 */

const factorial = (n) => {
  if (n === 0) {
    return 1
  }
  return n * factorial(n - 1)
}

export { factorial }

--#

--% C:/work/algos/Javascript/Recursive/FibonacciNumberRecursive.js

/**
 * @function Fibonacci
 * @description Function to return the N-th Fibonacci number.
 * @param {Integer} n - The input integer
 * @return {Integer} - Return the N-th Fibonacci number
 * @see [Fibonacci](https://en.wikipedia.org/wiki/Fibonacci_number)
 */

const fibonacci = (n) => {
  if (n < 2) {
    return n
  }
  return fibonacci(n - 2) + fibonacci(n - 1)
}

export { fibonacci }

--#

--% C:/work/algos/Javascript/Recursive/FloodFill.js
/**
 * Flood fill.
 *
 * Flood fill, also called seed fill, is an algorithm that determines and alters the area connected to a given node in a
 * multi-dimensional array with some matching attribute. It is used in the "bucket" fill tool of paint programs to fill
 * connected, similarly-colored areas with a different color.
 *
 * (description adapted from https://en.wikipedia.org/wiki/Flood_fill)
 * @see https://www.techiedelight.com/flood-fill-algorithm/
 */

const neighbors = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]

/**
 * Implements the flood fill algorithm through a breadth-first approach using a queue.
 *
 * @param rgbData The image to which the algorithm is applied.
 * @param location The start location on the image.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 */
export function breadthFirstSearch (rgbData, location, targetColor, replacementColor) {
  if (location[0] < 0 ||
    location[0] >= rgbData.length ||
    location[1] < 0 ||
    location[1] >= rgbData[0].length) {
    throw new Error('location should point to a pixel within the rgbData')
  }

  const queue = []
  queue.push(location)

  while (queue.length > 0) {
    breadthFirstFill(rgbData, location, targetColor, replacementColor, queue)
  }
}

/**
 * Implements the flood fill algorithm through a depth-first approach using recursion.
 *
 * @param rgbData The image to which the algorithm is applied.
 * @param location The start location on the image.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 */
export function depthFirstSearch (rgbData, location, targetColor, replacementColor) {
  if (location[0] < 0 ||
    location[0] >= rgbData.length ||
    location[1] < 0 ||
    location[1] >= rgbData[0].length) {
    throw new Error('location should point to a pixel within the rgbData')
  }

  depthFirstFill(rgbData, location, targetColor, replacementColor)
}

/**
 * Utility-function to implement the breadth-first loop.
 *
 * @param rgbData The image to which the algorithm is applied.
 * @param location The start location on the image.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 * @param queue The locations that still need to be visited.
 */
function breadthFirstFill (rgbData, location, targetColor, replacementColor, queue) {
  const currentLocation = queue[0]
  queue.shift()

  if (rgbData[currentLocation[0]][currentLocation[1]] === targetColor) {
    rgbData[currentLocation[0]][currentLocation[1]] = replacementColor

    for (let i = 0; i < neighbors.length; i++) {
      const x = currentLocation[0] + neighbors[i][0]
      const y = currentLocation[1] + neighbors[i][1]
      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {
        queue.push([x, y])
      }
    }
  }
}

/**
 * Utility-function to implement the depth-first loop.
 *
 * @param rgbData The image to which the algorithm is applied.
 * @param location The start location on the image.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 */
function depthFirstFill (rgbData, location, targetColor, replacementColor) {
  if (rgbData[location[0]][location[1]] === targetColor) {
    rgbData[location[0]][location[1]] = replacementColor

    for (let i = 0; i < neighbors.length; i++) {
      const x = location[0] + neighbors[i][0]
      const y = location[1] + neighbors[i][1]
      if (x >= 0 && x < rgbData.length && y >= 0 && y < rgbData[0].length) {
        depthFirstFill(rgbData, [x, y], targetColor, replacementColor)
      }
    }
  }
}

--#

--% C:/work/algos/Javascript/Recursive/KochSnowflake.js
/**
 * The Koch snowflake is a fractal curve and one of the earliest fractals to have been described.
 *
 * The Koch snowflake can be built up iteratively, in a sequence of stages. The first stage is an equilateral triangle,
 * and each successive stage is formed by adding outward bends to each side of the previous stage, making smaller
 * equilateral triangles. This can be achieved through the following steps for each line:
 * 1. divide the line segment into three segments of equal length.
 * 2. draw an equilateral triangle that has the middle segment from step 1 as its base and points outward.
 * 3. remove the line segment that is the base of the triangle from step 2.
 *
 * (description adapted from https://en.wikipedia.org/wiki/Koch_snowflake)
 * (for a more detailed explanation and an implementation in the Processing language, see
 * https://natureofcode.com/book/chapter-8-fractals/ #84-the-koch-curve-and-the-arraylist-technique).
 */

/** Class to handle the vector calculations. */
export class Vector2 {
  constructor (x, y) {
    this.x = x
    this.y = y
  }

  /**
   * Vector addition
   *
   * @param vector The vector to be added.
   * @returns The sum-vector.
   */
  add (vector) {
    const x = this.x + vector.x
    const y = this.y + vector.y
    return new Vector2(x, y)
  }

  /**
   * Vector subtraction
   *
   * @param vector The vector to be subtracted.
   * @returns The difference-vector.
   */
  subtract (vector) {
    const x = this.x - vector.x
    const y = this.y - vector.y
    return new Vector2(x, y)
  }

  /**
   * Vector scalar multiplication
   *
   * @param scalar The factor by which to multiply the vector.
   * @returns The scaled vector.
   */
  multiply (scalar) {
    const x = this.x * scalar
    const y = this.y * scalar
    return new Vector2(x, y)
  }

  /**
   * Vector rotation (see https://en.wikipedia.org/wiki/Rotation_matrix)
   *
   * @param angleInDegrees The angle by which to rotate the vector.
   * @returns The rotated vector.
   */
  rotate (angleInDegrees) {
    const radians = angleInDegrees * Math.PI / 180
    const ca = Math.cos(radians)
    const sa = Math.sin(radians)
    const x = ca * this.x - sa * this.y
    const y = sa * this.x + ca * this.y
    return new Vector2(x, y)
  }
}

/**
 * Go through the number of iterations determined by the argument "steps".
 *
 * Be careful with high values (above 5) since the time to calculate increases exponentially.
 *
 * @param initialVectors The vectors composing the shape to which the algorithm is applied.
 * @param steps The number of iterations.
 * @returns The transformed vectors after the iteration-steps.
 */
export function iterate (initialVectors, steps) {
  let vectors = initialVectors
  for (let i = 0; i < steps; i++) {
    vectors = iterationStep(vectors)
  }

  return vectors
}

/**
 * Loops through each pair of adjacent vectors.
 *
 * Each line between two adjacent vectors is divided into 4 segments by adding 3 additional vectors in-between the
 * original two vectors. The vector in the middle is constructed through a 60 degree rotation so it is bent outwards.
 *
 * @param vectors The vectors composing the shape to which the algorithm is applied.
 * @returns The transformed vectors after the iteration-step.
 */
function iterationStep (vectors) {
  const newVectors = []
  for (let i = 0; i < vectors.length - 1; i++) {
    const startVector = vectors[i]
    const endVector = vectors[i + 1]
    newVectors.push(startVector)
    const differenceVector = endVector.subtract(startVector).multiply(1 / 3)
    newVectors.push(startVector.add(differenceVector))
    newVectors.push(startVector.add(differenceVector).add(differenceVector.rotate(60)))
    newVectors.push(startVector.add(differenceVector.multiply(2)))
  }

  newVectors.push(vectors[vectors.length - 1])
  return newVectors
}

--#

--% C:/work/algos/Javascript/Recursive/KochSnowflake.manual-test.js
import { Vector2, iterate } from './KochSnowflake'

/**
 * Method to render the Koch snowflake to a canvas.
 *
 * @param canvasWidth The width of the canvas.
 * @param steps The number of iterations.
 * @returns The canvas of the rendered Koch snowflake.
 */
function getKochSnowflake (canvasWidth = 600, steps = 5) {
  if (canvasWidth <= 0) {
    throw new Error('canvasWidth should be greater than zero')
  }

  const offsetX = canvasWidth / 10.0
  const offsetY = canvasWidth / 3.7
  const vector1 = new Vector2(offsetX, offsetY)
  const vector2 = new Vector2(canvasWidth / 2, Math.sin(Math.PI / 3) * canvasWidth * 0.8 + offsetY)
  const vector3 = new Vector2(canvasWidth - offsetX, offsetY)
  const initialVectors = []
  initialVectors.push(vector1)
  initialVectors.push(vector2)
  initialVectors.push(vector3)
  initialVectors.push(vector1)
  const vectors = iterate(initialVectors, steps)
  return drawToCanvas(vectors, canvasWidth, canvasWidth)
}

/**
 * Utility-method to render the Koch snowflake to a canvas.
 *
 * @param vectors The vectors defining the edges to be rendered.
 * @param canvasWidth The width of the canvas.
 * @param canvasHeight The height of the canvas.
 * @returns The canvas of the rendered edges.
 */
function drawToCanvas (vectors, canvasWidth, canvasHeight) {
  const canvas = document.createElement('canvas')
  canvas.width = canvasWidth
  canvas.height = canvasHeight

  // Draw the edges
  const ctx = canvas.getContext('2d')
  ctx.beginPath()
  ctx.moveTo(vectors[0].x, vectors[0].y)
  for (let i = 1; i < vectors.length; i++) {
    ctx.lineTo(vectors[i].x, vectors[i].y)
  }
  ctx.stroke()

  return canvas
}

// plot the results if the script is executed in a browser with a window-object
if (typeof window !== 'undefined') {
  const canvas = getKochSnowflake()
  document.body.append(canvas)
}

--#

--% C:/work/algos/Javascript/Recursive/Palindrome.js
/**
 * @function Palindrome
 * @description Check whether the given string is Palindrome or not.
 * @param {String} str - The input string
 * @return {Boolean}.
 * @see [Palindrome](https://en.wikipedia.org/wiki/Palindrome)
 */

const palindrome = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input')
  }

  if (str.length <= 1) {
    return true
  }

  if (str[0] !== str[str.length - 1]) {
    return false
  } else {
    return palindrome(str.slice(1, str.length - 1))
  }
}

export { palindrome }

--#

--% C:/work/algos/Javascript/Recursive/SubsequenceRecursive.js
/*
 * Problem Statement: Find all distinct, non-empty subsequence of given string in lexicographical order using recursive approach.
 *
 * What is subsequence?
 * A Subsequence is sequence obtained by deleting some or no elements without changing the order of elements
 * Example: Given a string = "abcd"
 * 1. "abc" is a subsequence
 * 2. "abd" is a subsequence
 * 3. But "ba" is not a subsequence (because order is changed)
 *
 * What is lexicographical order?
 * In simple terms, lexicographical order is dictionary order.
 * Example: Given a string = "abcd"
 * 1. "abc" will come before "abcd".
 * 2. "abd" will come before "ac".
 *
 * References for meaning of subsequence & lexicographical:
 * https://en.wikipedia.org/wiki/Subsequence
 * https://en.wikipedia.org/wiki/Lexicographic_order
 */

export const subsequence = (str, seq, low, output = []) => {
  if (low <= str.length && str.length !== 0) {
    output.push(seq)
  }
  for (let i = low; i < str.length; i++) {
    subsequence(str, seq + str[i], i + 1, output)
  }
  return output
}

--#

--% C:/work/algos/Javascript/Recursive/TowerOfHanoi.js
// wiki - https://en.wikipedia.org/wiki/Tower_of_Hanoi
// Recursive Javascript function to solve tower of hanoi

export function TowerOfHanoi (n, from, to, aux, output = []) {
  if (n === 1) {
    output.push(`Move disk 1 from rod ${from} to rod ${to}`)
    return output
  }
  TowerOfHanoi(n - 1, from, aux, to, output)
  output.push(`Move disk ${n} from rod ${from} to rod ${to}`)
  TowerOfHanoi(n - 1, aux, to, from, output)
  return output
}

// Driver code (A, C, B are the name of rods)

// const n = 4
// TowerOfHanoi(n, 'A', 'C', 'B')

--#

--% C:/work/algos/Javascript/Recursive/test/BinarySearch.test.js
import { binarySearch } from '../BinarySearch'

describe('BinarySearch', () => {
  const arr = [2, 3, 4, 10, 25, 40, 45, 60, 100, 501, 700, 755, 800, 999]
  const low = 0
  const high = arr.length - 1

  it('should return index 3 for searchValue 10', () => {
    const searchValue = 10
    expect(binarySearch(arr, searchValue, low, high)).toBe(3)
  })

  it('should return index 0 for searchValue 2', () => {
    const searchValue = 2
    expect(binarySearch(arr, searchValue, low, high)).toBe(0)
  })

  it('should return index 13 for searchValue 999', () => {
    const searchValue = 999
    expect(binarySearch(arr, searchValue, low, high)).toBe(13)
  })

  it('should return -1 for searchValue 1', () => {
    const searchValue = 1
    expect(binarySearch(arr, searchValue, low, high)).toBe(-1)
  })

  it('should return -1 for searchValue 1000', () => {
    const searchValue = 1000
    expect(binarySearch(arr, searchValue, low, high)).toBe(-1)
  })
})

--#

--% C:/work/algos/Javascript/Recursive/test/Factorial.test.js
import { factorial } from '../Factorial'

describe('Factorial', () => {
  it('should return factorial 1 for value "0"', () => {
    expect(factorial(0)).toBe(1)
  })

  it('should return factorial 120 for value "5"', () => {
    expect(factorial(5)).toBe(120)
  })
})

--#

--% C:/work/algos/Javascript/Recursive/test/FibonacciNumberRecursive.test.js
import { fibonacci } from '../FibonacciNumberRecursive'

describe('FibonacciNumberRecursive', () => {
  it('should return 0', () => {
    expect(fibonacci(0)).toBe(0)
  })

  it('should return 1', () => {
    expect(fibonacci(1)).toBe(1)
  })

  it('should return 5', () => {
    expect(fibonacci(5)).toBe(5)
  })

  it('should return 9', () => {
    expect(fibonacci(9)).toBe(34)
  })
})

--#

--% C:/work/algos/Javascript/Recursive/test/FloodFill.test.js
import { breadthFirstSearch, depthFirstSearch } from '../FloodFill'

// some constants
const black = [0, 0, 0]
const green = [0, 255, 0]
const violet = [255, 0, 255]
const white = [255, 255, 255]
const orange = [255, 128, 0]

describe('FloodFill', () => {
  it('should calculate the correct colors using breadth-first approach', () => {
    expect(testBreadthFirst([1, 1], green, orange, [1, 1])).toEqual(orange)
    expect(testBreadthFirst([1, 1], green, orange, [0, 1])).toEqual(violet)
    expect(testBreadthFirst([1, 1], green, orange, [6, 4])).toEqual(white)
  })

  it('should calculate the correct colors using depth-first approach', () => {
    expect(testDepthFirst([1, 1], green, orange, [1, 1])).toEqual(orange)
    expect(testDepthFirst([1, 1], green, orange, [0, 1])).toEqual(violet)
    expect(testDepthFirst([1, 1], green, orange, [6, 4])).toEqual(white)
  })
})

/**
 * Utility-function to test the function "breadthFirstSearch".
 *
 * @param fillLocation The start location on the image where the flood fill is applied.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 * @param testLocation The location of the color to be checked.
 * @return The color at testLocation.
 */
function testBreadthFirst (fillLocation, targetColor, replacementColor, testLocation) {
  const rgbData = generateTestRgbData()
  breadthFirstSearch(rgbData, fillLocation, targetColor, replacementColor)
  return rgbData[testLocation[0]][testLocation[1]]
}

/**
 * Utility-function to test the function "depthFirstSearch".
 *
 * @param fillLocation The start location on the image where the flood fill is applied.
 * @param targetColor The old color to be replaced.
 * @param replacementColor The new color to replace the old one.
 * @param testLocation The location of the color to be checked.
 * @return The color at testLocation.
 */
function testDepthFirst (fillLocation, targetColor, replacementColor, testLocation) {// eslint-disable-line
  const rgbData = generateTestRgbData()
  depthFirstSearch(rgbData, fillLocation, targetColor, replacementColor)
  return rgbData[testLocation[0]][testLocation[1]]
}

/**
 * Generates the rgbData-matrix for the tests.
 *
 * @return example rgbData-matrix.
 */
function generateTestRgbData () {
  const layout = [
    [violet, violet, green, green, black, green, green],
    [violet, green, green, black, green, green, green],
    [green, green, green, black, green, green, green],
    [black, black, green, black, white, white, green],
    [violet, violet, black, violet, violet, white, white],
    [green, green, green, violet, violet, violet, violet],
    [violet, violet, violet, violet, violet, violet, violet]
  ]

  // transpose layout-matrix so the x-index comes before the y-index
  const transposed = []
  for (let x = 0; x < layout[0].length; x++) {
    transposed[x] = []
    for (let y = 0; y < layout.length; y++) {
      transposed[x][y] = layout[y][x]
    }
  }

  return transposed
}

--#

--% C:/work/algos/Javascript/Recursive/test/KochSnowflake.test.js
import { iterate, Vector2 } from '../KochSnowflake'

describe('KochSnowflake', () => {
  it('should produce the correctly-transformed vectors', () => {
    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[0])
      .toEqual({ x: 0, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[1])
      .toEqual({ x: 1 / 3, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[2])
      .toEqual({ x: 1 / 2, y: Math.sin(Math.PI / 3) / 3 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[3])
      .toEqual({ x: 2 / 3, y: 0 })

    expect(iterate([new Vector2(0, 0), new Vector2(1, 0)], 1)[4])
      .toEqual({ x: 1, y: 0 })
  })
})

--#

--% C:/work/algos/Javascript/Recursive/test/palindrome.test.js
import { palindrome } from '../Palindrome'

describe('Palindrome', () => {
  it('expects to return true for palindrome string', () => {
    const isPalindrome = palindrome('madam')
    expect(isPalindrome).toBe(true)
  })

  it('expects to return true for Empty String', () => {
    const isPalindrome = palindrome('')
    expect(isPalindrome).toBe(true)
  })

  it('expects to return false for non-palindrome string', () => {
    const isPalindrome = palindrome('foobar')
    expect(isPalindrome).toBe(false)
  })

  it('Throw Error for Invalid Input', () => {
    expect(() => palindrome(123)).toThrow('Invalid Input')
    expect(() => palindrome(null)).toThrow('Invalid Input')
    expect(() => palindrome(undefined)).toThrow('Invalid Input')
  })
})

--#

--% C:/work/algos/Javascript/Search/BinarySearch.js
/* Binary Search: https://en.wikipedia.org/wiki/Binary_search_algorithm
 *
 * Search a sorted array by repeatedly dividing the search interval
 * in half. Begin with an interval covering the whole array. If the value of the
 * search key is less than the item in the middle of the interval, narrow the interval
 * to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the
 * value is found or the interval is empty.
 */

function binarySearchRecursive (arr, x, low = 0, high = arr.length - 1) {
  const mid = Math.floor(low + (high - low) / 2)

  if (high >= low) {
    if (arr[mid] === x) {
      // item found => return its index
      return mid
    }

    if (x < arr[mid]) {
      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid
      return binarySearchRecursive(arr, x, low, mid - 1)
    } else {
      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high
      return binarySearchRecursive(arr, x, mid + 1, high)
    }
  } else {
    // if low > high => we have searched the whole array without finding the item
    return -1
  }
}
function binarySearchIterative (arr, x, low = 0, high = arr.length - 1) {
  while (high >= low) {
    const mid = Math.floor(low + (high - low) / 2)

    if (arr[mid] === x) {
      // item found => return its index
      return mid
    }

    if (x < arr[mid]) {
      // arr[mid] is an upper bound for x, so if x is in arr => low <= x < mid
      high = mid - 1
    } else {
      // arr[mid] is a lower bound for x, so if x is in arr => mid < x <= high
      low = mid + 1
    }
  }
  // if low > high => we have searched the whole array without finding the item
  return -1
}

export { binarySearchIterative, binarySearchRecursive }

/* ---------------------------------- Test ---------------------------------- */

// const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
// const stringArr = [
//   'Alpha',
//   'Bravo',
//   'Charlie',
//   'Delta',
//   'Echo',
//   'Foxtrot',
//   'Golf',
//   'Hotel',
//   'India',
//   'Juliet',
//   'Kilo',
//   'Lima',
//   'Mike',
//   'November',
//   'Oscar',
//   'Papa',
//   'Quebec',
//   'Romeo',
//   'Sierra',
//   'Tango',
//   'Uniform',
//   'Victor',
//   'Whiskey',
//   'X-Ray',
//   'Yankee',
//   'Zulu'
// ]

// binarySearchRecursive(arr, 3)
// binarySearchIterative(arr, 7)
// binarySearchRecursive(arr, 13)
// binarySearchIterative(stringArr, 'Charlie')
// binarySearchRecursive(stringArr, 'Zulu')
// binarySearchIterative(stringArr, 'Sierra')

--#

--% C:/work/algos/Javascript/Search/ExponentialSearch.js
/**
 * Exponential Search
 *
 * The algorithm consists of two stages. The first stage determines a
 * range in which the search key would reside if it were in the list.
 * In the second stage, a binary search is performed on this range.
 *
 *
 *
 */

function binarySearch (arr, value, floor, ceiling) {
  // Middle index
  const mid = Math.floor((floor + ceiling) / 2)

  // If value is at the mid position return this position
  if (arr[mid] === value) {
    return mid
  }

  if (floor > ceiling) return -1

  // If the middle element is great than the value
  // search the left part of the array
  if (arr[mid] > value) {
    return binarySearch(arr, value, floor, mid - 1)
    // If the middle element is lower than the value
    // search the right part of the array
  } else {
    return binarySearch(arr, value, mid + 1, ceiling)
  }
}

function exponentialSearch (arr, length, value) {
  // If value is the first element of the array return this position
  if (arr[0] === value) {
    return 0
  }

  // Find range for binary search
  let i = 1
  while (i < length && arr[i] <= value) {
    i = i * 2
  }

  // Call binary search for the range found above
  return binarySearch(arr, value, i / 2, Math.min(i, length))
}

export { binarySearch, exponentialSearch }

// const arr = [2, 3, 4, 10, 40, 65, 78, 100]
// const value = 78
// const result = exponentialSearch(arr, arr.length, value)

--#

--% C:/work/algos/Javascript/Search/FibonacciSearch.js
/****************************************************************************
 * Fibonacci Search JavaScript Implementation
 * Author   Alhassan Atama Isiaka
 * Version v1.0.0
 * Copyright 2020
 * https://github.com/komputarist
 *
 * This implementation is based on Generalizing the Fibonacci search we
 * define the Fibonacci search of degree K. Like the Fibonacci search,
 * which it reduces to for K = 2, the Fibonacci search of degree K
 * involves only addition and subtraction.
 *  Capocelli R.M. (1991) A Generalization of the Fibonacci Search. In:
 * Bergum G.E., Philippou A.N., Horadam A.F. (eds) Applications of Fibonacci
 * Numbers. Springer, Dordrecht. https://doi.org/10.1007/978-94-011-3586-3_9
 *
 * This snippet is free. Feel free to improve on it
 *
 * We define a function fibonacciSearch() that takes an array of numbers,
 * the item (number) to be searched for and the length of the items in the array
 ****************************************************************************/

export const fibonacciSearch = (arr, x, n) => {
  let fib2 = 0 // (K-2)'th Fibonacci Number
  let fib1 = 1 // (K-1)'th Fibonacci Number.
  let fibK = fib2 + fib1 // Kth Fibonacci

  /* We want to store the smallest fibonacci number smaller such that
    number is greater than or equal to n, we use fibK for this */
  while (fibK < n) {
    fib2 = fib1
    fib1 = fibK
    fibK = fib2 + fib1
  }
  //  This marks the eliminated range from front
  let offset = -1

  /* while there are elements to be checked. We compare arr[fib2] with x.
    When fibM becomes 1, fib2 becomes 0 */

  while (fibK > 1) {
    // Check if fibK is a valid location
    const i = Math.min(offset + fib2, n - 1)

    /*  If x is greater than the value at
      index fib2, Partition the subarray array
      from offset to i */
    if (arr[i] < x) {
      fibK = fib1
      fib1 = fib2
      fib2 = fibK - fib1
      offset = i
      /* If x is greater than the value at
            index fib2, cut the subarray array
            from offset to i */
    } else if (arr[i] > x) {
      fibK = fib2
      fib1 = fib1 - fib2
      fib2 = fibK - fib1
    } else {
    //  return index for found element
      return i
    }
  }

  //    comparing the last element with x */
  if (fib1 && arr[offset + 1] === x) {
    return offset + 1
  }
  //    element not found. return -1
  return -1
}

// Example
// const myArray = [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
// const n = myArray.length
// const x = 90
// const fibFinder = fibonacciSearch(myArray, x, n)

--#

--% C:/work/algos/Javascript/Search/InterpolationSearch.js
/**
 * Interpolation Search
 *
 * Time Complexity:
 * -Best case: O(1)
 * -Worst case: O(n)
 * -O((log(log(n))) If the data are uniformly distributed
 *
 *
 */

export function interpolationSearch (arr, key) {
  const length = arr.length - 1
  let low = 0
  let high = length
  let position = -1
  let delta = -1

  // Because the array is sorted the key must be between low and high
  while (low <= high && key >= arr[low] && key <= arr[high]) {
    delta = (key - arr[low]) / (arr[high] - arr[low])
    position = low + Math.floor((high - low) * delta)

    // Target found return its position
    if (arr[position] === key) {
      return position
    }

    // If the key is larger then it is in the upper part of the array
    if (arr[position] < key) {
      low = position + 1
      // If the key is smaller then it is in the lower part of the array
    } else {
      high = position - 1
    }
  }

  return -1
}

// const arr = [2, 6, 8, 10, 12, 14, 16, 18, 20, 22, 26, 34, 39]

// interpolationSearch(arr, 2)
// interpolationSearch(arr, 12)
// interpolationSearch(arr, 1000)
// interpolationSearch(arr, 39)

--#

--% C:/work/algos/Javascript/Search/JumpSearch.js
/* The Jump Search algorithm allows to combine a linear search with a speed optimization.
  * This means that instead of going 1 by 1, we will increase the step of n and increase that
  * step of n which make the step getting bigger and bigger.
  * The asymptotic analysis of Jump Search is o(n). Like the binary search, it needs to be sorted.
  * The advantage against binary search is that Jump Search traversed back only once.
 */

const jumpSearch = (arr, value) => {
  const length = arr.length
  let step = Math.floor(Math.sqrt(length))
  let lowerBound = 0
  while (arr[Math.min(step, length) - 1] < value) {
    lowerBound = step
    step += step
    if (lowerBound >= length) {
      return -1
    }
  }

  const upperBound = Math.min(step, length)
  while (arr[lowerBound] < value) {
    lowerBound++
    if (lowerBound === upperBound) {
      return -1
    }
  }
  if (arr[lowerBound] === value) {
    return lowerBound
  }
  return -1
}
const arr = [0, 0, 4, 7, 10, 23, 34, 40, 55, 68, 77, 90]
jumpSearch(arr, 4)
jumpSearch(arr, 34)
jumpSearch(arr, 77)

--#

--% C:/work/algos/Javascript/Search/LinearSearch.js
/*
 * Linear search or sequential search is a method for finding a target
 * value within a list. It sequentially checks each element of the list
 * for the target value until a match is found or until all the elements
 * have been searched.
 */
function SearchArray (searchNum, ar, output = v => console.log(v)) {
  const position = Search(ar, searchNum)
  if (position !== -1) {
    output('The element was found at ' + (position + 1))
  } else {
    output('The element not found')
  }
}

// Search theArray for the specified key value
function Search (theArray, key) {
  for (let n = 0; n < theArray.length; n++) {
    if (theArray[n] === key) { return n }
  }
  return -1
}

export { SearchArray, Search }

// const ar = [1, 2, 3, 4, 5, 6, 7, 8, 9]
// SearchArray(3, ar)
// SearchArray(4, ar)
// SearchArray(11, ar)

--#

--% C:/work/algos/Javascript/Search/QuickSelectSearch.js
/*
 * Places the `k` smallest elements in `array` in the first `k` indices: `[0..k-1]`
 * Modifies the passed in array *in place*
 * Returns a slice of the wanted elements for convenience
 * Efficient mainly because it never performs a full sort.
 *
 * The only guarantees are that:
 *
 * - The `k`th element is in its final sort index (if the array were to be sorted)
 * - All elements before index `k` are smaller than the `k`th element
 *
 * [Reference](http://en.wikipedia.org/wiki/Quickselect)
 */
export function quickSelectSearch (array, k) {
  if (!array || array.length <= k) {
    throw new Error('Invalid arguments')
  }

  let from = 0
  let to = array.length - 1
  while (from < to) {
    let left = from
    let right = to
    const pivot = array[Math.ceil((left + right) * 0.5)]

    while (left < right) {
      if (array[left] >= pivot) {
        const tmp = array[left]
        array[left] = array[right]
        array[right] = tmp
        --right
      } else {
        ++left
      }
    }

    if (array[left] > pivot) {
      --left
    }

    if (k <= left) {
      to = left
    } else {
      from = left + 1
    }
  }
  return array
}

/* ---------------------------------- Test ---------------------------------- */

// const arr = [1121111, 21, 333, 41, 5, 66, 7777, 28, 19, 11110]
// quickSelectSearch(arr, 5) // [ 19, 21, 28, 41, 5, 66, 333, 11110, 1121111, 7777 ]
// quickSelectSearch(arr, 2) // [ 19, 5, 21, 41, 28, 333, 11110, 1121111, 7777, 66 ]
// quickSelectSearch(arr, 7) // [ 19, 5, 21, 41, 28, 66, 333, 7777, 11110, 1121111 ]

--#

--% C:/work/algos/Javascript/Search/SlidingWindow.js
/**
* Sliding Window:
* This pattern involve creating a window which can either be
* an array or numbers from one position to another.
*
* Depending on a certain condition, the window either increases
* or closes (and a new window is created).
*
* Very useful for keeping track of a subset of data in an
* array/string etc.
*
* Time Complexity: Best - O(n);
*
* Examples:
* maxSubarraySum([1,2,5,2,8,1,5],2) // returns 10
* maxSubarraySum([1,2,5,2,8,1,5],15) // returns null
* maxSubarraySum([5,2,6,9],3) // returns 17
 * @param {[Int]} arr - An array of integers on which we will perform the test.
 * @param {Int} num - An integer that displays the size of the window you want to check.
 * @returns {Int / Null} - Returns a total of N consecutive numbers or null
 */

function slidingWindow (arr, num) {
  // Edge Case:
  // If the length of the array shorter than the window size (num) return null.
  if (arr.length < num) return null
  // The highest amount of consecutive numbers
  let maxSum = 0
  // Temp amount of consecutive numbers - For comparative purposes
  let tempSum = 0
  // loop over the array {num} times and save their total amount in {maxSum}
  for (let i = 0; i < num; i++) {
    maxSum += arr[i]
  }
  // initialize {tempSum} to {maxSum}.
  tempSum = maxSum
  // loop over the array n times
  for (let i = num; i < arr.length; i++) {
    // Add the next num in the array and remove the first one
    tempSum = tempSum - arr[i - num] + arr[i]
    // save the largest number between {maxNum} and {tempNum} in maxSum.
    maxSum = Math.max(maxSum, tempSum)
  }
  return maxSum
}

export { slidingWindow }

--#

--% C:/work/algos/Javascript/Search/StringSearch.js
/*
 * String Search
 */

function makeTable (str) {
  // create a table of size equal to the length of `str`
  // table[i] will store the prefix of the longest prefix of the substring str[0..i]
  const table = new Array(str.length)
  let maxPrefix = 0
  // the longest prefix of the substring str[0] has length
  table[0] = 0

  // for the substrings the following substrings, we have two cases
  for (let i = 1; i < str.length; i++) {
    // case 1. the current character doesn't match the last character of the longest prefix
    while (maxPrefix > 0 && str.charAt(i) !== str.charAt(maxPrefix)) {
      // if that is the case, we have to backtrack, and try find a character  that will be equal to the current character
      // if we reach 0, then we couldn't find a character
      maxPrefix = table[maxPrefix - 1]
    }
    // case 2. The last character of the longest prefix matches the current character in `str`
    if (str.charAt(maxPrefix) === str.charAt(i)) {
      // if that is the case, we know that the longest prefix at position i has one more character.
      // for example consider `.` be any character not contained in the set [a.c]
      // str = abc....abc
      // consider `i` to be the last character `c` in `str`
      // maxPrefix = will be 2 (the first `c` in `str`)
      // maxPrefix now will be 3
      maxPrefix++
      // so the max prefix for table[9] is 3
    }
    table[i] = maxPrefix
  }
  return table
}

// Find all the words that matches in a given string `str`
export function stringSearch (str, word) {
  // find the prefix table in O(n)
  const prefixes = makeTable(word)
  const matches = []

  // `j` is the index in `P`
  let j = 0
  // `i` is the index in `S`
  let i = 0
  while (i < str.length) {
    // Case 1.  S[i] == P[j] so we move to the next index in `S` and `P`
    if (str.charAt(i) === word.charAt(j)) {
      i++
      j++
    }
    // Case 2.  `j` is equal to the length of `P`
    // that means that we reached the end of `P` and thus we found a match
    // Next we have to update `j` because we want to save some time
    // instead of updating to j = 0 , we can jump to the last character of the longest prefix well known so far.
    // j-1 means the last character of `P` because j is actually `P.length`
    // e.g.
    // S =  a b a b d e
    // P = `a b`a b
    // we will jump to `a b` and we will compare d and a in the next iteration
    // a b a b `d` e
    //     a b `a` b
    if (j === word.length) {
      matches.push(i - j)
      j = prefixes[j - 1]
      // Case 3.
      // S[i] != P[j] There's a mismatch!
    } else if (str.charAt(i) !== word.charAt(j)) {
      // if we  found at least a character in common, do the same thing as in case 2
      if (j !== 0) {
        j = prefixes[j - 1]
      } else {
        // else j = 0, and we can move to the next character S[i+1]
        i++
      }
    }
  }

  return matches
}

// stringSearch('Hello search the position of me', 'pos')

--#

--% C:/work/algos/Javascript/Search/TernarySearch.js
/* Ternary search is similar to binary search but it divide the sorted array
 * into three parts and determine which part the key lies in. The array will
 * be divided into three intervals by using two middle points, mid1 and mid2.
 * The value of the key will first compared with the two mid points, the value
 * will be returned if there is a match. Then, if the value of the key is less
 * than mid1, narrow the interval to the first part. Else, if the value of the
 * key is greater than mid2, narrow the interval to the third part. Otherwise,
 * narrow the interval to the middle part. Repeat the steps until the value is
 * found or the interval is empty(value not found after checking all elements).
 *
 * Reference: https://www.geeksforgeeks.org/ternary-search/
 */

function ternarySearchRecursive (arr, key, low = 0, high = arr.length - 1) {
  if (high >= low) {
    // find the mid1 and mid2
    const mid1 = Math.floor(low + (high - low) / 3)
    const mid2 = Math.floor(high - (high - low) / 3)

    // check if key is found at any mid
    if (arr[mid1] === key) {
      // return index of key if found
      return mid1
    }
    if (arr[mid2] === key) {
      // return index of key if found
      return mid2
    }

    // since the key is not found at mid,
    // check in which region it is present
    // and repeat the Search operation
    // in that region
    if (key < arr[mid1]) {
      // the key lies in between low and mid1
      return ternarySearchRecursive(arr, key, low, mid1 - 1)
    } else if (key > arr[mid2]) {
      // the key lies in between mid2 and high
      return ternarySearchRecursive(arr, key, mid2 + 1, high)
    } else {
      // the key lies in between mid1 and mid2
      return ternarySearchRecursive(arr, key, mid1 + 1, mid2 - 1)
    }
  } else {
    // if low > high => we have searched the whole array without finding the item
    return -1
  }
}

function ternarySearchIterative (arr, key, low = 0, high = arr.length - 1) {
  while (high >= low) {
    // find the mid1 and mid2
    const mid1 = Math.floor(low + (high - low) / 3)
    const mid2 = Math.floor(high - (high - low) / 3)

    // check if key is found at any mid
    if (arr[mid1] === key) {
      // return index of key if found
      return mid1
    }
    if (arr[mid2] === key) {
      // return index of key if found
      return mid2
    }

    // since the key is not found at mid,
    // check in which region it is present
    // and repeat the Search operation
    // in that region
    if (key < arr[mid1]) {
      // the key lies in between low and mid1
      high = mid1 - 1
    } else if (key > arr[mid2]) {
      // the key lies in between mid2 and high
      low = mid2 + 1
    } else {
      // the key lies in between mid1 and mid2
      low = mid1 + 1
      high = mid2 - 1
    }
  }
  // the key was not found
  return -1
}

export { ternarySearchRecursive, ternarySearchIterative }

--#

--% C:/work/algos/Javascript/Search/UnionFind.js
/**
 * union find data structure for javascript
 *
 * In computer science, a disjoint-set data structure, also called a unionfind data structure or mergefind set,
 * is a data structure that stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition
 * of a set into disjoint subsets. It provides operations for adding new sets, merging sets (replacing them by their union),
 * and finding a representative member of a set.
 * The last operation allows to find out efficiently if any two elements are in the same or different sets.
 *
 * Disjoint-set data structures play a key role in Kruskal's algorithm for finding the minimum spanning tree of a graph.
 * The importance of minimum spanning trees means that disjoint-set data structures underlie a wide variety of algorithms.
 * In addition, disjoint-set data structures also have applications to symbolic computation, as well in compilers,
 * especially for register allocation problems.
 *
 * you can learn more on disjoint-set / unionfind data structure at https://en.wikipedia.org/wiki/Disjoint-set_data_structure
 */
function UnionFind (n, key) {
  if (!(this instanceof UnionFind)) return new UnionFind(n)
  if (key && typeof key !== 'function') {
    throw new Error('key has to be a function or else left undefined')
  }
  let cnt, length
  // init Union Find with number of distinct groups. Each group will be referred to as index of the array of size 'size' starting at 0.
  // Provide an optional key function that maps these indices. I.e. for the groups starting with 1 provide function(a){return a-1;}. The default value is function(a){return a;}.
  key = key || function (a) { return a }
  cnt = length = n
  const id = new Array(n)
  const sz = new Array(n)
  for (let i = 0; i < n; i++) {
    id[i] = i
    sz[i] = 1
  }
  // Returns the number of elements of uf object.
  this.size = function () {
    return length
  }
  // Returns the number of distinct groups left inside the object.
  this.count = function () {
    return cnt
  }
  // Return the root (value) of the group in which p is.
  this.find = function (p) {
    p = key(p)
    while (p !== id[p]) {
      id[p] = id[id[p]]
      p = id[p]
    }
    return p
  }
  // Returns true if p and p are both in same group, false otherwise.
  this.connected = function (p, q) {
    p = key(p)
    q = key(q)
    ensureIndexWithinBounds(p, q)
    return this.find(p) === this.find(q)
  }
  // Combine elements in groups p and q into a single group. In other words connect the two groups.
  this.union = function (p, q) {
    p = key(p)
    q = key(q)
    ensureIndexWithinBounds(p, q)
    const i = this.find(p)
    const j = this.find(q)
    if (i === j) return
    if (sz[i] < sz[j]) {
      id[i] = j; sz[j] += sz[i]
    } else {
      id[j] = i; sz[i] += sz[j]
    }
    cnt--
  }
  function ensureIndexWithinBounds (args) {
    for (let i = arguments.length - 1; i >= 0; i--) {
      const p = arguments[i]
      if (p >= length) throw new Error('Index out of bounds. The maximum index can be length-1')
    }
  }
}

export { UnionFind }

--#

--% C:/work/algos/Javascript/Search/test/SlidingWindow.test.js
import { slidingWindow } from '../SlidingWindow'

test('expect to return the largest sum of sequence in the array', () => {
  const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 2)
  expect(sum).toBe(10)
})

test('expect to return the largest sum of sequence in the array', () => {
  const sum = slidingWindow([5, 2, 6, 9], 3)
  expect(sum).toBe(17)
})

test('expect to return null when the sequence size is larger then the array length', () => {
  const sum = slidingWindow([1, 2, 5, 2, 8, 1, 5], 15)
  expect(sum).toBe(null)
})

--#

--% C:/work/algos/Javascript/Search/test/TernarySearch.test.js
import { ternarySearchRecursive, ternarySearchIterative } from '../TernarySearch'

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3)
  expect(indexNumber).toBe(2)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 8)
  expect(indexNumber).toBe(7)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchRecursive([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 0)
  expect(indexNumber).toBe(-1)
})

test('should return the index of a number in an array of numbers:', () => {
  const indexNumber = ternarySearchIterative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 12)
  expect(indexNumber).toBe(-1)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Cathrynli')
  expect(indexNumber).toBe(1)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Josuke')
  expect(indexNumber).toBe(2)
})

test('should return the index of a string in an array of strings:', () => {
  const indexNumber = ternarySearchRecursive(['Ali', 'Cathrynli', 'Josuke', 'Thomas'], 'Angela')
  expect(indexNumber).toBe(-1)
})

--#

--% C:/work/algos/Javascript/Search/test/UnionFind.test.js
import { UnionFind } from '../UnionFind'

const uf = new UnionFind(5)

test('should expose .size():', () => {
  const size = uf.size()
  expect(size).toBe(5)
})

test('should do .union(num1, num2):', () => {
  uf.union(1, 2)
  uf.union(3, 4)
  uf.union(0, 4)
  expect(uf.connected(1, 2)).toBe(true)
  expect(uf.connected(1, 2)).toBe(true)

  expect(uf.connected(3, 4)).toBe(true)
  expect(uf.connected(3, 0)).toBe(true)
  expect(uf.connected(4, 0)).toBe(true)

  expect(uf.connected(1, 3)).toBe(false)
  expect(uf.connected(1, 4)).toBe(false)
  expect(uf.connected(1, 0)).toBe(false)
  expect(uf.connected(2, 3)).toBe(false)
  expect(uf.connected(2, 4)).toBe(false)
  expect(uf.connected(2, 0)).toBe(false)
})

test('.count(), should return the number of disparate groups:', () => {
  expect(uf.count()).toBe(2)
})

test('should check if two components are connected, .connected(num1, num2):', () => {
  expect(uf.connected(1, 2)).toBe(true)
  expect(uf.connected(1, 3)).toBe(false)
})

test('should find the root of the tree in which the given element lives, .find(num):', () => {
  expect(uf.find(1)).toBe(1)
  expect(uf.find(2)).toBe(1)
  expect(uf.find(3)).toBe(3)
  expect(uf.find(4)).toBe(3)
  expect(uf.find(0)).toBe(3)
})

test('should always change the id of the smaller tree and preserve the id of the larger one', () => {
  uf.union(2, 3)
  expect(uf.count()).toBe(1)
  expect(uf.find(0)).toBe(3)
  expect(uf.find(1)).toBe(3)
  expect(uf.find(2)).toBe(3)
  expect(uf.find(3)).toBe(3)
  expect(uf.find(4)).toBe(3)
})

--#

--% C:/work/algos/Javascript/Sorts/AlphaNumericalSort.js
/*
  https://en.wikipedia.org/wiki/Natural_sort_order

  In computing, natural sort order (or natural sorting) is the ordering of strings in alphabetical order,
  except that multi-digit numbers are treated atomically, i.e., as if they were a single character. Natural sort order
  has been promoted as being more human-friendly ("natural") than machine-oriented, pure alphabetical sort order.[1]

  For example, in alphabetical sorting, "z11" would be sorted before "z2" because the "1" in the first string is sorted as smaller
  than "2", while in natural sorting "z2" is sorted before "z11" because "2" is treated as smaller than "11".

  Alphabetical sorting:
  1.z11
  2.z2

  Natural sorting:
  1. z2
  2. z11

  P.S. use this function, as there are a lot of implementations on the stackoverflow and other forums, but many of them don't work correctly (can't pass all my tests)

*/

const alphaNumericalSort = (a, b) => {
  /*
    https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare

    The localeCompare() method returns a number indicating whether a reference string comes before, or after, or is the same as the given string in sort order.

    The new locales and options arguments let applications specify the language whose sort order should be used and customize the behavior of the function.
    In older implementations, which ignore the locales and options arguments, the locale and sort order used are entirely implementation-dependent.
    Syntax:
    localeCompare(compareString, locales, options)

  */
  return a.localeCompare(b, undefined, { numeric: true })
}

export { alphaNumericalSort }

--#

--% C:/work/algos/Javascript/Sorts/BeadSort.js
/**
 * Bead Sort, also known as Gravity sort.
 *
 * This algorithm was inspired from natural phenomena and was designed keeping in mind objects (or beads) falling under
 * the influence of gravity.
 *
 * NOTE: It only works for arrays of positive integers.
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Bead_sort
 */
export function beadSort (sequence) {
  /* Let's ensure our sequence has only Positive Integers */
  if (sequence.some((integer) => integer < 0)) {
    throw RangeError('Sequence must be a list of Positive integers Only!')
  }

  const sequenceLength = sequence.length
  const max = Math.max(...sequence)

  // Set initial Grid
  const grid = sequence.map(number => {
    const maxArr = new Array(max)

    for (let i = 0; i < number; i++) {
      maxArr[i] = '*'
    }

    return maxArr
  })

  // Drop the Beads!
  for (let col = 0; col < max; col++) {
    let beadsCount = 0

    for (let row = 0; row < sequenceLength; row++) {
      if (grid[row][col] === '*') {
        beadsCount++
      }
    }

    for (let row = sequenceLength - 1; row > -1; row--) {
      if (beadsCount) {
        grid[row][col] = '*'
        beadsCount--
      } else {
        grid[row][col] = undefined
      }
    }
  }

  /* Finally, let's turn our Bead rows into their Respective Numbers */
  return grid.map((beadArray) => {
    const beadsArray = beadArray.filter(bead => bead === '*')
    return beadsArray.length
  })
}

--#

--% C:/work/algos/Javascript/Sorts/BogoSort.js
/**
 * Checks whether the given array is sorted in ascending order.
 */
export function isSorted (array) {
  const length = array.length
  for (let i = 0; i < length - 1; i++) {
    if (array[i] > array[i + 1]) {
      return false
    }
  }
  return true
}

/**
 * Shuffles the given array randomly in place.
 */
function shuffle (array) {
  for (let i = array.length - 1; i; i--) {
    const m = Math.floor(Math.random() * i)
    const n = array[i - 1]
    array[i - 1] = array[m]
    array[m] = n
  }
}

/**
 * Implementation of the bogosort algorithm.
 *
 * This sorting algorithm randomly rearranges the array until it is sorted.
 *
 * For more information see: https://en.wikipedia.org/wiki/Bogosort
 */
export function bogoSort (items) {
  while (!isSorted(items)) {
    shuffle(items)
  }
  return items
}

--#

--% C:/work/algos/Javascript/Sorts/BubbleSort.js
/* Bubble Sort is an algorithm to sort an array. It
*  compares adjacent element and swaps their position
*  The big O on bubble sort in worst and best case is O(N^2).
*  Not efficient.
*
*  In bubble sort, we keep iterating while something was swapped in
*  the previous inner-loop iteration. By swapped I mean, in the
*  inner loop iteration, we check each number if the number proceeding
*  it is greater than itself, if so we swap them.
*
*  Wikipedia: https://en.wikipedia.org/wiki/Bubble_sort
*  Animated Visual: https://www.toptal.com/developers/sorting-algorithms/bubble-sort
*/

/**
 * Using 2 for loops.
 */
export function bubbleSort (items) {
  const length = items.length

  for (let i = (length - 1); i > 0; i--) {
    // Number of passes
    for (let j = (length - i); j > 0; j--) {
      // Compare the adjacent positions
      if (items[j] < items[j - 1]) {
        // Swap the numbers
        [items[j], items[j - 1]] = [items[j - 1], items[j]]
      }
    }
  }

  return items
}

/**
 * Using a while loop and a for loop.
 */
export function alternativeBubbleSort (arr) {
  let swapped = true

  while (swapped) {
    swapped = false
    for (let i = 0; i < arr.length - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]
        swapped = true
      }
    }
  }

  return arr
}

--#

--% C:/work/algos/Javascript/Sorts/BucketSort.js
/**
 * BucketSort implementation.
 *
 * Wikipedia says: Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array
 * into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by
 * recursively applying the bucket sorting algorithm. It is a distribution sort, and is a cousin of radix sort in the
 * most to least significant digit flavour. Bucket sort is a generalization of pigeonhole sort. Bucket sort can be
 * implemented with comparisons and therefore can also be considered a comparison sort algorithm. The computational
 * complexity estimates involve the number of buckets.
 *
 * @see https://en.wikipedia.org/wiki/Bucket_sort#:~:text=Bucket%20sort%2C%20or%20bin%20sort,applying%20the%20bucket%20sorting%20algorithm.&text=Sort%20each%20non%2Dempty%20bucket.
 *
 * Time Complexity of Solution:
 * Best Case O(n); Average Case O(n); Worst Case O(n)
 *
 * @param {number[]} list The array of numbers to be sorted.
 * @param {number} size The size of the buckets used. If not provided, size will be 5.
 * @return {number[]} An array of numbers sorted in increasing order.
 */
export function bucketSort (list, size) {
  if (undefined === size) {
    size = 5
  }
  if (list.length === 0) {
    return list
  }
  let min = list[0]
  let max = list[0]
  // find min and max
  for (let iList = 0; iList < list.length; iList++) {
    if (list[iList] < min) {
      min = list[iList]
    } else if (list[iList] > max) {
      max = list[iList]
    }
  }
  // how many buckets we need
  const count = Math.floor((max - min) / size) + 1

  // create buckets
  const buckets = []
  for (let iCount = 0; iCount < count; iCount++) {
    buckets.push([])
  }

  // bucket fill
  for (let iBucket = 0; iBucket < list.length; iBucket++) {
    const key = Math.floor((list[iBucket] - min) / size)
    buckets[key].push(list[iBucket])
  }
  const sorted = []
  // now sort every bucket and merge it to the sorted list
  for (let iBucket = 0; iBucket < buckets.length; iBucket++) {
    const arr = buckets[iBucket].sort((a, b) => a - b)
    for (let iSorted = 0; iSorted < arr.length; iSorted++) {
      sorted.push(arr[iSorted])
    }
  }
  return sorted
}

--#

--% C:/work/algos/Javascript/Sorts/CocktailShakerSort.js
/**
 * Cocktail Shaker Sort is an algorithm that is a Bidirectional Bubble Sort.
 *
 * The algorithm extends bubble sort by operating in two directions.
 * While it improves on bubble sort by more quickly moving items to the beginning of the list, it provides only marginal
 * performance improvements.
 *
 * Wikipedia (Cocktail Shaker Sort): https://en.wikipedia.org/wiki/Cocktail_shaker_sort
 * Wikipedia (Bubble Sort): https://en.wikipedia.org/wiki/Bubble_sort
 */
export function cocktailShakerSort (items) {
  for (let i = items.length - 1; i > 0; i--) {
    let j

    // Backwards
    for (j = items.length - 1; j > i; j--) {
      if (items[j] < items[j - 1]) {
        [items[j], items[j - 1]] = [items[j - 1], items[j]]
      }
    }

    // Forwards
    for (j = 0; j < i; j++) {
      if (items[j] > items[j + 1]) {
        [items[j], items[j + 1]] = [items[j + 1], items[j]]
      }
    }
  }

  return items
}

--#

--% C:/work/algos/Javascript/Sorts/CombSort.js
/**
 * Comb sort improves on bubble sort.
 *
 * The basic idea is to eliminate turtles, or small values
 * near the end of the list, since in a bubble sort these slow the sorting
 * down tremendously. Rabbits, large values around the beginning of the list,
 * do not pose a problem in bubble sort.
 *
 * In bubble sort, when any two elements are compared, they always have a
 * gap (distance from each other) of 1. The basic idea of comb sort is
 * that the gap can be much more than 1. The inner loop of bubble sort,
 * which does the actual swap, is modified such that gap between swapped
 * elements goes down (for each iteration of outer loop) in steps of
 * a "shrink factor" k: [ n/k, n/k2, n/k3, ..., 1 ].
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Comb_sort
 */

/**
 * combSort returns an array of numbers sorted in increasing order.
 *
 * @param {number[]} list The array of numbers to sort.
 * @return {number[]} The array of numbers sorted in increasing order.
 */
function combSort (list) {
  if (list.length === 0) {
    return list
  }
  const shrink = 1.3
  let gap = list.length
  let isSwapped = true
  let i = 0

  while (gap > 1 || isSwapped) {
    // Update the gap value for a next comb
    gap = parseInt(parseFloat(gap) / shrink, 10)

    isSwapped = false
    i = 0

    while (gap + i < list.length) {
      if (list[i] > list[i + gap]) {
        [list[i], list[i + gap]] = [list[i + gap], list[i]]
        isSwapped = true
      }
      i += 1
    }
  }
  return list
}

export { combSort }

--#

--% C:/work/algos/Javascript/Sorts/CountingSort.js
/**
 * Counting sort is an algorithm for sorting a collection
 * of objects according to keys that are small integers.
 *
 * It is an integer sorting algorithm.
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Counting_sort
 * Animated Visual: https://www.cs.usfca.edu/~galles/visualization/CountingSort.html
 */

export const countingSort = (arr, min, max) => {
  // Create an auxiliary resultant array
  const res = []
  // Create and initialize the frequency[count] array
  const count = new Array(max - min + 1).fill(0)
  // Populate the freq array
  for (let i = 0; i < arr.length; i++) {
    count[arr[i] - min]++
  }
  // Create a prefix sum array out of the frequency[count] array
  count[0] -= 1
  for (let i = 1; i < count.length; i++) {
    count[i] += count[i - 1]
  }
  // Populate the result array using the prefix sum array
  for (let i = arr.length - 1; i >= 0; i--) {
    res[count[arr[i] - min]] = arr[i]
    count[arr[i] - min]--
  }
  return res
}

/**
 * Implementation of Counting Sort
 */
// const array = [3, 0, 2, 5, 4, 1]
// countingSort(array, 0, 5)

--#

--% C:/work/algos/Javascript/Sorts/CycleSort.js
/**
 * Cycle sort is an in-place, unstable sorting algorithm,
 * a comparison sort that is theoretically optimal in terms of the total
 * number of writes to the original array, unlike any other in-place sorting
 * algorithm. It is based on the idea that the permutation to be sorted can
 * be factored into cycles, which can individually be rotated to give a sorted result.
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Cycle_sort
 */

/**
 * cycleSort takes an input array of numbers and returns the array sorted in increasing order.
 *
 * @param {number[]} list An array of numbers to be sorted.
 * @return {number[]} An array of numbers sorted in increasing order.
 */
function cycleSort (list) {
  for (let cycleStart = 0; cycleStart < list.length; cycleStart++) {
    let value = list[cycleStart]
    let position = cycleStart

    // search position
    for (let i = cycleStart + 1; i < list.length; i++) {
      if (list[i] < value) {
        position++
      }
    }
    // if it is the same, continue
    if (position === cycleStart) {
      continue
    }
    while (value === list[position]) {
      position++
    }

    const oldValue = list[position]
    list[position] = value
    value = oldValue

    // rotate the rest
    while (position !== cycleStart) {
      position = cycleStart
      for (let i = cycleStart + 1; i < list.length; i++) {
        if (list[i] < value) {
          position++
        }
      }
      while (value === list[position]) {
        position++
      }
      const oldValueCycle = list[position]
      list[position] = value
      value = oldValueCycle
    }
  }
  return list
}

export { cycleSort }

--#

--% C:/work/algos/Javascript/Sorts/FindSecondLargestElement.js
/*
* Find Second Largest is a real technical interview question.
* Chances are you will be asked to find the second largest value
* inside of an array of numbers. You must also be able to filter
* out duplicate values.  It's important to know how to do this with
* clean code that is also easy to explain.
*
* Resources:
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
*/

const secondLargestElement = (array) => {
  const largestElement = Math.max(...array)
  let element = 0

  for (let i = 0; i < array.length; i++) {
    if (element < array[i] && array[i] !== largestElement) {
      element = array[i]
    }
  }

  return element
}

export { secondLargestElement }

--#

--% C:/work/algos/Javascript/Sorts/FisherYatesShuffle.js
export const shuffle = (array) => {
  let maxLength = array.length
  let temp
  let idx

  // While there remain elements to shuffle...
  while (maxLength) {
    // Pick a remaining element...
    idx = Math.floor(Math.random() * maxLength--)

    // And swap it with the current element
    temp = array[maxLength]
    array[maxLength] = array[idx]
    array[idx] = temp
  }

  return array
}

--#

--% C:/work/algos/Javascript/Sorts/FlashSort.js
/**
 * Flashsort is a distribution sorting algorithm showing linear
 * computational complexity O(n) for uniformly distributed
 * data sets and relatively little additional memory requirement.
 *
 * Wikipedia: https://en.wikipedia.org/wiki/Flashsort
 */

export function flashSort (arr) {
  let max = 0; let min = arr[0]
  const n = arr.length
  const m = ~~(0.45 * n)
  const l = new Array(m)

  for (let i = 1; i < n; ++i) {
    if (arr[i] < min) {
      min = arr[i]
    }
    if (arr[i] > arr[max]) {
      max = i
    }
  }

  if (min === arr[max]) {
    return arr
  }

  const c1 = (m - 1) / (arr[max] - min)

  for (let k = 0; k < m; k++) {
    l[k] = 0
  }

  for (let j = 0; j < n; ++j) {
    const k = ~~(c1 * (arr[j] - min))
    ++l[k]
  }

  for (let p = 1; p < m; ++p) {
    l[p] = l[p] + l[p - 1]
  }

  let hold = arr[max]
  arr[max] = arr[0]
  arr[0] = hold

  // permutation
  let move = 0; let t; let flash
  let j = 0
  let k = m - 1

  while (move < (n - 1)) {
    while (j > (l[k] - 1)) {
      ++j
      k = ~~(c1 * (arr[j] - min))
    }
    if (k < 0) break
    flash = arr[j]
    while (j !== l[k]) {
      k = ~~(c1 * (flash - min))
      hold = arr[t = --l[k]]
      arr[t] = flash
      flash = hold
      ++move
    }
  }

  // insertion
  for (j = 1; j < n; j++) {
    hold = arr[j]
    let i = j - 1
    while (i >= 0 && arr[i] > hold) {
      arr[i + 1] = arr[i--]
    }
    arr[i + 1] = hold
  }
  return arr
}

/**
* Implementation of Flash Sort
*/
// const array = [3, 0, 2, 5, -1, 4, 1, -2]
// flashSort(array)

--#

--% C:/work/algos/Javascript/Sorts/GnomeSort.js
/*
 * Gnome sort is a sort algorithm that moving an element to its proper place is accomplished by a series of swap
 * more information: https://en.wikipedia.org/wiki/Gnome_sort
 *
 */
export function gnomeSort (items) {
  if (items.length <= 1) {
    return
  }

  let i = 1

  while (i < items.length) {
    if (items[i - 1] <= items[i]) {
      i++
    } else {
      [items[i], items[i - 1]] = [items[i - 1], items[i]]

      i = Math.max(1, i - 1)
    }
  }
}

// Implementation of gnomeSort

// const ar = [5, 6, 7, 8, 1, 2, 12, 14]
// gnomeSort(ar)

--#

--% C:/work/algos/Javascript/Sorts/HeapSort.js
/*
 * Build a max heap out of the array. A heap is a specialized tree like
 * data structure that satisfies the heap property. The heap property
 * for max heap is the following: "if P is a parent node of C, then the
 * key (the value) of node P is greater than the key of node C"
 * Source: https://en.wikipedia.org/wiki/Heap_(data_structure)
 */
/* eslint no-extend-native: ["off", { "exceptions": ["Object"] }] */
Array.prototype.heapify = function (index, heapSize) {
  let largest = index
  const leftIndex = 2 * index + 1
  const rightIndex = 2 * index + 2

  if (leftIndex < heapSize && this[leftIndex] > this[largest]) {
    largest = leftIndex
  }

  if (rightIndex < heapSize && this[rightIndex] > this[largest]) {
    largest = rightIndex
  }

  if (largest !== index) {
    const temp = this[largest]
    this[largest] = this[index]
    this[index] = temp

    this.heapify(largest, heapSize)
  }
}

/*
 * Heap sort sorts an array by building a heap from the array and
 * utilizing the heap property.
 * For more information see: https://en.wikipedia.org/wiki/Heapsort
 */
export function heapSort (items) {
  const length = items.length

  for (let i = Math.floor(length / 2) - 1; i > -1; i--) {
    items.heapify(i, length)
  }
  for (let j = length - 1; j > 0; j--) {
    const tmp = items[0]
    items[0] = items[j]
    items[j] = tmp
    items.heapify(0, j)
  }
  return items
}

// Implementation of heapSort

// const ar = [5, 6, 7, 8, 1, 2, 12, 14]
// heapSort(ar)

--#

--% C:/work/algos/Javascript/Sorts/HeapSortV2.js
let arrayLength = 0

/* to create MAX  array */

function heapRoot (input, i) {
  const left = 2 * i + 1
  const right = 2 * i + 2
  let max = i

  if (left < arrayLength && input[left] > input[max]) {
    max = left
  }

  if (right < arrayLength && input[right] > input[max]) {
    max = right
  }

  if (max !== i) {
    swap(input, i, max)
    heapRoot(input, max)
  }
}

function swap (input, indexA, indexB) {
  [input[indexA], input[indexB]] = [input[indexB], input[indexA]]
}

export function heapSort (input) {
  arrayLength = input.length

  for (let i = Math.floor(arrayLength / 2); i >= 0; i -= 1) {
    heapRoot(input, i)
  }

  for (let i = input.length - 1; i > 0; i--) {
    swap(input, 0, i)
    arrayLength--

    heapRoot(input, 0)
  }
}

--#

--% C:/work/algos/Javascript/Sorts/InsertionSort.js
/* In insertion sort, we divide the initial unsorted array into two parts;
* sorted part and unsorted part. Initially the sorted part just has one
* element (Array of only 1 element is a sorted array). We then pick up
* element one by one from unsorted part; insert into the sorted part at
* the correct position and expand sorted part one element at a time.
*/
export function insertionSort (unsortedList) {
  const len = unsortedList.length
  for (let i = 1; i < len; i++) {
    let j
    const tmp = unsortedList[i] // Copy of the current element.
    /* Check through the sorted part and compare with the number in tmp. If large, shift the number */
    for (j = i - 1; j >= 0 && (unsortedList[j] > tmp); j--) {
      // Shift the number
      unsortedList[j + 1] = unsortedList[j]
    }
    // Insert the copied number at the correct position
    // in sorted part.
    unsortedList[j + 1] = tmp
  }
}

--#

--% C:/work/algos/Javascript/Sorts/IntroSort.js
/**
 * @function Intosort (As implemented in STD C++ Lib)
 * The function performs introsort which is used in
 * C++ Standard LIbrary, the implementation is inspired from]
 * library routine itself.
 * ALGORITHM:
 * 1) It performs quicksort on array until the recursion depth
 *    exceeds a pre determined limit.
 * 2) If the limit is reached it switches to heapsort
 * 3) For array size less than a threshold(16) directly
 *    does insertion sort on array
 * @param {Array} array the array to be sorted
 * @param {Function} compare the comparison function
 *
 * @see [Introsort](https://en.wikipedia.org/wiki/Introsort)
 * @author [Lakhan Nad](https://github.com/Lakhan-Nad)
 */
function introsort (array, compare) {
  /**
   * @function Default Comparison Function
   * This function is same as implemented by
   * Array.sort method
   * @see [StackOverflow](https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function)
   * @param {*} a variable 1
   * @param {*} b variable 2
   * @returns {Number}
   * -1 if a is less than b
   *  0 if a is equal to b
   *  1 if a greater than b
   */
  const defaultComparator = function (x, y) {
    if (x === undefined && y === undefined) return 0
    if (x === undefined) return 1
    if (y === undefined) return -1
    const xString = toString(x)
    const yString = toString(y)
    if (xString < yString) return -1
    if (xString > yString) return 1
    return 0
  }
  /**
   * @function helper function for defaultComparator
   * Converts a given object to String
   * @throws TypeError()
   * @param {Object} obj
   * @returns {String} String representation of given object
   */
  const toString = function (obj) {
    if (obj === null) return 'null'
    if (typeof obj === 'boolean' || typeof obj === 'number') {
      return obj.toString()
    }
    if (typeof obj === 'string') return obj
    if (typeof obj === 'symbol') throw new TypeError()
    return obj.toString()
  }
  /**
   * Checks if the value passed is an array
   * or not
   */
  if (Array.isArray(array) === false) {
    return
  }
  /**
   * If the compare parameter is not a function
   * or not passed at all use default comparator
   * function
   */
  if (typeof compare !== 'function') {
    compare = defaultComparator // If compare is not a comparator function
  }
  /**
   * Use a closure to define the whole sort
   * implementation this is done through
   * [IIFE](https://en.wikipedia.org/wiki/Immediately_invoked_function_expression)
   */
  return (function (array, comparator) {
    const swap = function (index1, index2) {
      const temp = array[index1]
      array[index1] = array[index2]
      array[index2] = temp
    }
    /**
     * @constant THRESHOLD
     * If the length of array is less than
     * this then we simply perform insertion sort
     */
    const THRESHOLD = 16
    /**
     * @constant TUNEMAXDEPTH
     * Constant usec to increase or decrease value
     * of maxDepth
     */
    const TUNEMAXDEPTH = 1
    const len = array.length
    /**
     * Return if array is only of length 1
     * Array of size 1 is always sorted
     */
    if (len === 1) {
      return
    }
    /**
     * Calculate maxDepth = log2(len)
     * Taken from implementation in stdc++
     */
    const maxDepth = Math.floor(Math.log2(len)) * TUNEMAXDEPTH
    /**
     * The very first call to quicksort
     * this initiates sort routine
     */
    quickSort(0, len, maxDepth)
    /**
     * A final check call to insertion sort
     * on sorted array
     */
    insertionSort(0, len)
    /** *********************  Implementation of various routines  **************************/
    /**
     * @function
     * This is recursive quicksort implementation in array
     * of segment [start,last-1]
     * [QuickSort](https://en.wikipedia.org/wiki/Quicksort)
     * @param {Number} start the start index of array segment to be sorted
     * @param {Number} last  one more than the last index of array segment
     * @param {Number} depth this measures how many recursive calls are done
     */
    function quickSort (start, last, depth) {
      if (last - start <= THRESHOLD) {
        insertionSort(start, last)
        return
      } else if (depth <= 0) {
        heapSort(start, last)
        return
      }
      let pivot = (last + start) >> 1
      pivot = partition(start, last, pivot)
      quickSort(start, pivot, depth - 1)
      quickSort(pivot + 1, last, depth - 1)
    }
    /**
     * @function Helper function to quicksort
     * @param {Number} start the start of array segment to partition
     * @param {Number} last  one more than last index of the array segment
     * @param {Number} pivot the index of pivot to be used
     * @returns {Number} the index of pivot after partition
     */
    function partition (start, last, pivot) {
      swap(start, pivot)
      pivot = start
      let lo = start
      let hi = last
      while (true) {
        lo++
        while (comparator(array[lo], array[pivot]) <= 0 && lo !== last) {
          lo++
        }
        hi--
        while (comparator(array[hi], array[pivot]) > 0 && hi !== start) {
          hi--
        }
        if (lo >= hi) {
          break
        }
        swap(lo, hi)
      }
      swap(start, hi)
      return hi
    }
    /**
     * @function
     * Performs insertion sort on array of range
     * [start, last-1]
     * @param {Number} start the first index of array segment to be sorted
     * @param {Number} last  one more than last index of array to be sorted
     */
    function insertionSort (start, last) {
      let i, j
      for (i = start + 1; i < last; i++) {
        j = i - 1
        while (j >= 0 && comparator(array[j], array[j + 1]) > 0) {
          swap(j, j + 1)
          j--
        }
      }
    }
    /**
     * @function
     * Performs heapsort in array segment of range [start, last-1]
     * [HeapSort](https://en.wikipedia.org/wiki/Heapsort)
     * @param {Number} start the first index of array segment to be sorted
     * @param {Number} last  one more than last index of array to be sorted
     */
    function heapSort (start, last) {
      let x = (last + start) >> 1
      while (x - start >= 0) {
        heapify(x, start, last)
        x--
      }
      x = last - 1
      while (x - start > 0) {
        swap(start, x)
        heapify(start, start, x)
        x--
      }
    }
    /**
     * @function Helper function to heapsort routine
     * @param {Number} cur the index we need to heapify
     * @param {Number} start the start index of array segment that cur belongs to
     * @param {Number} last  one more than last index of segment that cur belongs to
     */
    function heapify (cur, start, last) {
      const size = last - start
      let max, lt, rt
      cur = cur - start
      while (true) {
        max = cur
        lt = 2 * max + 1
        rt = 2 * max + 2
        if (
          lt < size &&
          comparator(array[start + max], array[start + lt]) < 0
        ) {
          max = lt
        }
        if (
          rt < size &&
          comparator(array[start + max], array[start + rt]) < 0
        ) {
          max = rt
        }
        if (max !== cur) {
          swap(start + cur, start + max)
          cur = max
        } else {
          break
        }
      }
    }
  })(array, compare)
}

/**
 * @example Demo run of the sort routine
 * The data is randomly generated
 * Returns 'RIGHT:)' if the sort routine worked as expected,
 *         'WRONG!!' otherwise
 */
function demo1 () {
  const data = []
  const size = 1000000
  let i = 0
  let temp
  const c = function (a, b) {
    return a - b
  }
  for (i = 0; i < size; i++) {
    temp = Math.random() * Number.MAX_SAFE_INTEGER
    data.push(temp)
  }
  introsort(data, c)
  let faulty = false
  for (i = 1; i < size; i++) {
    if (data[i] < data[i - 1]) {
      faulty = true
      break
    }
  }
  if (faulty) {
    return 'WRONG!!'
  } else {
    return 'RIGHT:)'
  }
}

/**
 * @example Demo run of the sort routine
 * using the default compare function and
 * comparing the results with Array.sort
 */
function demo2 () {
  const data = []
  const data2 = []
  const size = 1000000
  let i = 0
  let temp
  for (i = 0; i < size; i++) {
    temp = Math.random() * Number.MAX_SAFE_INTEGER
    data.push(temp)
    data2.push(temp)
  }
  introsort(data)
  data2.sort()
  let faulty = false
  for (i = 1; i < size; i++) {
    if (data[i] !== data2[i]) {
      faulty = true
      break
    }
  }
  if (faulty) {
    return 'WRONG Implemented Comparator!!'
  } else {
    return 'Comparator Works Fine:)'
  }
}

export { introsort, demo1, demo2 }

--#

--% C:/work/algos/Javascript/Sorts/MergeSort.js
/*
 * MergeSort implementation.
 *
 * Merge Sort is an algorithm where the main list is divided down into two half sized lists, which then have merge sort
 * called on these two smaller lists recursively until there is only a sorted list of one.
 *
 * On the way up the recursive calls, the lists will be merged together inserting
 * the smaller value first, creating a larger sorted list.
 */

/**
 * Sort and merge two given arrays.
 *
 * @param {Array} list1 Sublist to break down.
 * @param {Array} list2 Sublist to break down.
 * @return {Array} The merged list.
 */
export function merge (list1, list2) {
  const results = []
  let i = 0
  let j = 0

  while (i < list1.length && j < list2.length) {
    if (list1[i] < list2[j]) {
      results.push(list1[i++])
    } else {
      results.push(list2[j++])
    }
  }

  return results.concat(list1.slice(i), list2.slice(j))
}

/**
 * Break down the lists into smaller pieces to be merged.
 *
 * @param {Array} list List to be sorted.
 * @return {Array} The sorted list.
 */
export function mergeSort (list) {
  if (list.length < 2) return list

  const listHalf = Math.floor(list.length / 2)
  const subList1 = list.slice(0, listHalf)
  const subList2 = list.slice(listHalf, list.length)

  return merge(mergeSort(subList1), mergeSort(subList2))
}

--#

--% C:/work/algos/Javascript/Sorts/OddEvenSort.js
/*
  oddeven sort or oddeven transposition sort
  is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections.
  It is a comparison sort related to bubble sort, with which it shares many characteristics.

   for more information : https://en.wikipedia.org/wiki/Odd%E2%80%93even_sort
*/

// Helper function to swap array items
function swap (arr, i, j) {
  const tmp = arr[i]
  arr[i] = arr[j]
  arr[j] = tmp
}

export function oddEvenSort (arr) {
  let sorted = false
  while (!sorted) {
    sorted = true
    for (let i = 1; i < arr.length - 1; i += 2) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        sorted = false
      }
    }
    for (let i = 0; i < arr.length - 1; i += 2) {
      if (arr[i] > arr[i + 1]) {
        swap(arr, i, i + 1)
        sorted = false
      }
    }
  }
}

--#

--% C:/work/algos/Javascript/Sorts/PancakeSort.js
/*
 * Unlike a traditional sorting algorithm, which attempts to sort with the fewest
 * comparisons possible, the goal of pancake sort is to sort the sequence in as few reversals as
 * possible. The idea is to do something similar to Selection Sort. We one by one place
 * maximum element at the end and reduce the size of current array by one.
 *
 * Source: https://www.geeksforgeeks.org/pancake-sorting/
 *
 * This sorting algorithm is inspired by the pancake problem (hence the name),
 * where a spatula can be placed anywhere between two pancakes and flip all pancakes
 * above.
 *
 * The interesting about this algorithm (besides its name) is that instead of comparisons,
 * the algorithm relies on flipping an array.
 *
 * Source: https://en.wikipedia.org/wiki/Pancake_sorting#The_original_pancake_problem
 *
 */

/**
 * Unlike Array.prototype.reverse, flipArray reverses only a subarray of the given
 * array, determined by the parameters startIndex and endIndex
 *
 * @param {number[]} array The array to flip
 * @param {number} startIndex The start of the subarray
 * @param {number} endIndex The end of the subarray
 * @returns The flipped array
 */
export function flipArray (array, startIndex, endIndex) {
  while (startIndex < endIndex) {
    // swap front and back of the subarray
    const temp = array[startIndex]
    array[startIndex] = array[endIndex]
    array[endIndex] = temp

    // essentially reducing the problem to a smaller subarray
    startIndex++
    endIndex--
  }

  return array
}

/**
 * Returns the index of the maximum number of a subarray in a given array
 *
 * @param {number[]} array The array to found the maximum number's index
 * @param {*} startIndex The start of the subarray
 * @param {*} endIndex The end of the subarray
 * @returns The index of the maximum number
 */
export function findMax (array, startIndex, endIndex) {
  let maxIndex = 0
  for (let i = startIndex; i <= endIndex; i++) {
    if (array[i] > array[maxIndex]) maxIndex = i
  }

  return maxIndex
}

/**
 * The Pancake Sort algorithm.
 *
 * Note that even though it's a completely different concept of sorting an
 * array, it's rather simple!
 *
 * @param {number[]} array The array to sort
 * @returns The sorted array
 */
export function pancakeSort (array) {
  for (let subarraySize = array.length; subarraySize > 1; subarraySize--) {
    const maximumIndex = findMax(array, 0, subarraySize - 1)

    if (maximumIndex !== subarraySize - 1) {
      flipArray(array, 0, maximumIndex)
      flipArray(array, 0, subarraySize - 1)
    }
  }

  return array
}

--#

--% C:/work/algos/Javascript/Sorts/PigeonHoleSort.js
/*
https://en.wikipedia.org/wiki/Pigeonhole_sort

*Pigeonhole sorting is a sorting algorithm that is suitable
* for sorting lists of elements where the number of elements
* (n) and the length of the range of possible key values (N)
* are approximately the same.
 */
export function pigeonHoleSort (arr) {
  let min = arr[0]
  let max = arr[0]

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > max) { max = arr[i] }
    if (arr[i] < min) { min = arr[i] }
  }

  const range = max - min + 1
  const pigeonhole = Array(range).fill(0)

  for (let i = 0; i < arr.length; i++) {
    pigeonhole[arr[i] - min]++
  }

  let index = 0

  for (let j = 0; j < range; j++) {
    while (pigeonhole[j]-- > 0) {
      arr[index++] = j + min
    }
  }
}

--#

--% C:/work/algos/Javascript/Sorts/QuickSort.js
/**
 * @function QuickSort
 * @description Quick sort is a comparison sorting algorithm that uses a divide and conquer strategy.
 * @param {Integer[]} items - Array of integers
 * @return {Integer[]} - Sorted array.
 * @see [QuickSort](https://en.wikipedia.org/wiki/Quicksort)
 */
function quickSort (items) {
  const length = items.length

  if (length <= 1) {
    return items
  }
  const PIVOT = items[0]
  const GREATER = []
  const LESSER = []

  for (let i = 1; i < length; i++) {
    if (items[i] > PIVOT) {
      GREATER.push(items[i])
    } else {
      LESSER.push(items[i])
    }
  }

  const sorted = [...quickSort(LESSER), PIVOT, ...quickSort(GREATER)]
  return sorted
}

export { quickSort }

--#

--% C:/work/algos/Javascript/Sorts/QuickSortRecursive.js
/*
    Quicksort is the most popular sorting algorithm and there have
    lots of different implementations but the "recursive" or "Partition in place"
    is one of the most efficient implementations below we have discussed how to
    implement it.

    Partition in place => "in place" Partition in place indicates that we
    do not need any other space to store the auxiliary array and the term
    "partition" denotes that we split the list into two parts one is less
    than the pivot and the other is greater than the pivot and repeats this
    process recursively and breaks the problem into sub-problems and makes
    it singular so that the behavior or "divide and conquer" get involved
    too.

    Problem & Source of Explanation => https://www.cs.auckland.ac.nz/software/AlgAnim/qsort1a.html
*/

/**
 * Partition in place QuickSort.
 * @param {number[]} inputList list of values.
 * @param {number} low lower index for partition.
 * @param {number} high higher index for partition.
 */
const quickSort = (inputList, low, high) => {
  if (!Array.isArray(inputList)) {
    throw new TypeError('Please input a valid list or array.')
  }
  if (low < high) {
    // get the partition index.
    const pIndex = partition(inputList, low, high)
    // recursively call the quickSort method again.
    quickSort(inputList, low, pIndex - 1)
    quickSort(inputList, pIndex + 1, high)
  }
  return inputList
}

/**
 * Partition In Place method.
 * @param {number[]} partitionList list for partitioning.
 * @param {number} low lower index for partition.
 * @param {number} high higher index for partition.
 * @returns {number} `pIndex` pivot index value.
 */
const partition = (partitionList, low, high) => {
  const pivot = partitionList[high]
  let pIndex = low
  for (let index = low; index <= high - 1; index++) {
    if (partitionList[index] < pivot) {
      // swap variables using array destructuring
      [partitionList[index], partitionList[pIndex]] = [partitionList[pIndex], partitionList[index]]
      pIndex += 1
    }
  }
  [partitionList[pIndex], partitionList[high]] = [partitionList[high], partitionList[pIndex]]
  return pIndex
}

export { quickSort }

--#

--% C:/work/algos/Javascript/Sorts/RadixSort.js
/*
* Radix sorts an integer array without comparing the integers.
* It groups the integers by their digits which share the same
* significant position.
* For more information see: https://en.wikipedia.org/wiki/Radix_sort
*/
export function radixSort (items, RADIX) {
  // default radix is then because we usually count to base 10
  if (RADIX === undefined || RADIX < 1) {
    RADIX = 10
  }

  let maxLength = false
  let placement = 1

  while (!maxLength) {
    maxLength = true
    const buckets = []

    for (let i = 0; i < RADIX; i++) {
      buckets.push([])
    }

    for (let j = 0; j < items.length; j++) {
      const tmp = items[j] / placement
      buckets[Math.floor(tmp % RADIX)].push(items[j])
      if (maxLength && tmp > 0) {
        maxLength = false
      }
    }

    let a = 0
    for (let b = 0; b < RADIX; b++) {
      const buck = buckets[b]
      for (let k = 0; k < buck.length; k++) {
        items[a] = buck[k]
        a++
      }
    }
    placement *= RADIX
  }
  return items
}

--#

--% C:/work/algos/Javascript/Sorts/SelectionSort.js
/* The selection sort algorithm sorts an array by repeatedly finding the minimum element
 *(considering ascending order) from unsorted part and putting it at the beginning. The
 *algorithm maintains two subarrays in a given array.
 *1) The subarray which is already sorted.
 *2) Remaining subarray which is unsorted.
 *
 *In every iteration of selection sort, the minimum element (considering ascending order)
 *from the unsorted subarray is picked and moved to the sorted subarray.
 */

export const selectionSort = (list) => {
  if (!Array.isArray(list)) {
    throw new TypeError('Given input is not an array')
  }
  const items = [...list] // We don't want to modify the original array
  const length = items.length
  for (let i = 0; i < length - 1; i++) {
    if (typeof items[i] !== 'number') {
      throw new TypeError('One of the items in your array is not a number')
    }
    // Number of passes
    let min = i // min holds the current minimum number position for each pass; i holds the Initial min number
    for (let j = i + 1; j < length; j++) { // Note that j = i + 1 as we only need to go through unsorted array
      if (items[j] < items[min]) { // Compare the numbers
        min = j // Change the current min number position if a smaller num is found
      }
    }
    if (min !== i) {
      // After each pass, if the current min num != initial min num, exchange the position.
      // Swap the numbers
      [items[i], items[min]] = [items[min], items[i]]
    }
  }
  return items
}

--#

--% C:/work/algos/Javascript/Sorts/ShellSort.js
/*
 * Shell Sort sorts an array based on  insertion sort algorithm
 * more information: https://en.wikipedia.org/wiki/Shellsort
 *
 */
export function shellSort (items) {
  let interval = 1

  while (interval < items.length / 3) {
    interval = interval * 3 + 1
  }

  while (interval > 0) {
    for (let outer = interval; outer < items.length; outer++) {
      const value = items[outer]
      let inner = outer

      while (inner > interval - 1 && items[inner - interval] >= value) {
        items[inner] = items[inner - interval]
        inner = inner - interval
      }
      items[inner] = value
    }
    interval = (interval - 1) / 3
  }
  return items
}

--#

--% C:/work/algos/Javascript/Sorts/TimSort.js
/**
  *  @function Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort,
  *  designed to perform well on many kinds of real-world data.
  *  It was implemented by Tim Peters in 2002 for use in the Python programming language.
  *  It is also used to sort arrays of non-primitive type in Java SE 7,
  *  on the Android platform, in GNU Octave, on V8, Swift and Rust.
  *  1) It sorts small partitions using Insertion Sort.
  *  2) Merges the partition using Merge Sort.
  *  @see [Timsort](https://en.wikipedia.org/wiki/Timsort)
  *  @param {Array} array
  */

const Timsort = (array) => {
  // Default size of a partition
  const RUN = 32
  const n = array.length
  // Sorting the partitions using Insertion Sort
  for (let i = 0; i < n; i += RUN) {
    InsertionSort(array, i, Math.min(i + RUN - 1, n - 1))
  }
  for (let size = RUN; size < n; size *= 2) {
    for (let left = 0; left < n; left += 2 * size) {
      const mid = left + size - 1
      const right = Math.min(left + 2 * size - 1, n - 1)
      Merge(array, left, mid, right)
    }
  }
}

/**
 * @function performs insertion sort on the partition
 * @param {Array} array array to be sorted
 * @param {Number} left left index of partition
 * @param {Number} right right index of partition
 */

const InsertionSort = (array, left, right) => {
  for (let i = left + 1; i <= right; i++) {
    const key = array[i]
    let j = i - 1
    while (j >= left && array[j] > key) {
      array[j + 1] = array[j]
      j--
    }
    array[j + 1] = key
  }
}

/**
 * @function merges two sorted partitions
 * @param {Array} array array to be sorted
 * @param {Number} left left index of partition
 * @param {Number} mid mid index of partition
 * @param {Number} right right index of partition
 */

const Merge = (array, left, mid, right) => {
  if (mid >= right) return
  const len1 = mid - left + 1
  const len2 = right - mid
  const larr = Array(len1)
  const rarr = Array(len2)
  for (let i = 0; i < len1; i++) {
    larr[i] = array[left + i]
  }
  for (let i = 0; i < len2; i++) {
    rarr[i] = array[mid + 1 + i]
  }
  let i = 0; let j = 0; let k = left
  while (i < larr.length && j < rarr.length) {
    if (larr[i] < rarr[j]) {
      array[k++] = larr[i++]
    } else {
      array[k++] = rarr[j++]
    }
  }
  while (i < larr.length) {
    array[k++] = larr[i++]
  }
  while (j < rarr.length) {
    array[k++] = rarr[j++]
  }
}

/**
 * @example Test of Timsort functions.
 * Data is randomly generated.
 * Return "RIGHT" if it works as expected,
 * otherwise "FAULTY"
 */
const demo = () => {
  const size = 1000000
  const data = Array(size)
  for (let i = 0; i < size; i++) {
    data[i] = Math.random() * Number.MAX_SAFE_INTEGER
  }
  const isSorted = function (array) {
    const n = array.length
    for (let i = 0; i < n - 1; i++) {
      if (array[i] > array[i + 1]) return false
    }
    return true
  }
  Timsort(data)
  if (isSorted(data)) {
    return 'RIGHT'
  } else {
    return 'FAULTY'
  }
}

export { Timsort, demo }

--#

--% C:/work/algos/Javascript/Sorts/TopologicalSort.js

export function TopologicalSorter () {
  const graph = {}
  let isVisitedNode
  let finishTimeCount
  let finishingTimeList
  let nextNode

  this.addOrder = function (nodeA, nodeB) {
    nodeA = String(nodeA)
    nodeB = String(nodeB)
    graph[nodeA] = graph[nodeA] || []
    graph[nodeA].push(nodeB)
  }

  this.sortAndGetOrderedItems = function () {
    isVisitedNode = Object.create(null)
    finishTimeCount = 0
    finishingTimeList = []

    for (const node in graph) {
      if (Object.prototype.hasOwnProperty.call(graph, node) && !isVisitedNode[node]) {
        dfsTraverse(node)
      }
    }

    finishingTimeList.sort(function (item1, item2) {
      return item1.finishTime > item2.finishTime ? -1 : 1
    })

    return finishingTimeList.map(function (value) { return value.node })
  }

  function dfsTraverse (node) {
    isVisitedNode[node] = true
    if (graph[node]) {
      for (let i = 0; i < graph[node].length; i++) {
        nextNode = graph[node][i]
        if (isVisitedNode[nextNode]) continue
        dfsTraverse(nextNode)
      }
    }

    finishingTimeList.push({
      node: node,
      finishTime: ++finishTimeCount
    })
  }
}

/* TEST */
// const topoSorter = new TopologicalSorter()
// topoSorter.addOrder(5, 2)
// topoSorter.addOrder(5, 0)
// topoSorter.addOrder(4, 0)
// topoSorter.addOrder(4, 1)
// topoSorter.addOrder(2, 3)
// topoSorter.addOrder(3, 1)
// topoSorter.sortAndGetOrderedItems()

--#

--% C:/work/algos/Javascript/Sorts/WiggleSort.js
/*
 * Wiggle sort sorts the array into a wave like array.
 * An array arr[0..n-1] is sorted in wave form if arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4] >= ..
 *
 */

export const wiggleSort = function (arr) {
  for (let i = 0; i < arr.length; ++i) {
    const shouldNotBeLessThan = i % 2
    const isLessThan = arr[i] < arr[i + 1]
    if (shouldNotBeLessThan && isLessThan) {
      [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]
    }
  }
  return arr
}

// Implementation of wiggle sort

// > wiggleSort([3, 5, 2, 1, 6, 4])
// [ 3, 5, 2, 6, 1, 4 ]

--#

--% C:/work/algos/Javascript/Sorts/test/AlphaNumericalSort.test.js
import { alphaNumericalSort } from '../AlphaNumericalSort'

describe('alphaNumericalComparer', () => {
  test('given array of eng symbols return correct sorted array', () => {
    const src = ['b', 'a', 'c']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['a', 'b', 'c'])
  })

  test('given array of numbers return correct sorted array', () => {
    const src = ['15', '0', '5']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['0', '5', '15'])
  })

  test('correct sort with numbers and strings', () => {
    const src = ['3', 'a1b15c', 'z', 'a1b14c']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['3', 'a1b14c', 'a1b15c', 'z'])
  })

  test('correct sort with long numbers', () => {
    const src = ['abc999999999999999999999999999999999cba', 'abc999999999999999999999999999999990cba', 'ab']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['ab', 'abc999999999999999999999999999999990cba', 'abc999999999999999999999999999999999cba'])
  })

  test('correct sort with z prefix', () => {
    const src = ['z', 'abc003def', 'abc1def', 'a']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['a', 'abc1def', 'abc003def', 'z'])
  })

  test('correct sort with other language', () => {
    const src = ['10', '2', '10', '05']
    src.sort(alphaNumericalSort)
    expect(src).toEqual(['2', '10', '05', '10'])
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/BeadSort.test.js
import { beadSort } from '../BeadSort'

describe('BeadSort', () => {
  it('should sort arrays correctly', () => {
    expect(beadSort([5, 4, 3, 2, 1])).toEqual([1, 2, 3, 4, 5])
    expect(beadSort([7, 9, 4, 3, 5])).toEqual([3, 4, 5, 7, 9])
  })

  it('should throw a RangeError when the array contains negative integers', () => {
    expect(() => beadSort([-1, 5, 8, 4, 3, 19])).toThrow(RangeError)
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/BogoSort.test.js
import { bogoSort, isSorted } from '../BogoSort'

describe('isSorted', () => {
  it('should return true for empty arrays', () => {
    expect(isSorted([])).toBe(true)
  })

  it('should return true for single-element arrays', () => {
    expect(isSorted([1])).toBe(true)
  })

  it('should return true for arrays that are properly sorted', () => {
    expect(isSorted([1, 2, 3])).toBe(true)
  })

  it('should return false for arrays that are not properly sorted', () => {
    expect(isSorted([3, 2, 1])).toBe(false)
  })
})

describe('bogoSort', () => {
  it('should (eventually) sort the array', () => {
    expect(bogoSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/BubbleSort.test.js
import { alternativeBubbleSort, bubbleSort } from '../BubbleSort'

describe('bubbleSort', () => {
  it('should sort arrays correctly', () => {
    expect(bubbleSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(bubbleSort([])).toEqual([])
    expect(bubbleSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(bubbleSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})

describe('alternativeBubbleSort', () => {
  it('should sort arrays correctly', () => {
    expect(alternativeBubbleSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(alternativeBubbleSort([])).toEqual([])
    expect(alternativeBubbleSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(alternativeBubbleSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/BucketSort.test.js
import { bucketSort } from '../BucketSort'

describe('Tests for bucketSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(bucketSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(bucketSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(bucketSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(bucketSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(bucketSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(bucketSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(bucketSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(bucketSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(bucketSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(bucketSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(bucketSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(bucketSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(bucketSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(bucketSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(bucketSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/CocktailShakerSort.test.js
import { cocktailShakerSort } from '../CocktailShakerSort'

describe('CocktailShakerSort', () => {
  it('should sort arrays correctly', () => {
    expect(cocktailShakerSort([5, 4, 1, 2, 3])).toEqual([1, 2, 3, 4, 5])
    expect(cocktailShakerSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(cocktailShakerSort([5, 6, 7, 8, 1, 2, 12, 14])).toEqual([1, 2, 5, 6, 7, 8, 12, 14])
  })

  it('should work for empty arrays, too', () => {
    expect(cocktailShakerSort([])).toEqual([])
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/CombSort.test.js
import { combSort } from '../CombSort'

describe('combSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(combSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(combSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(combSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(combSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(combSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(combSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(combSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(combSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(combSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(combSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(combSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(combSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(combSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(combSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(combSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/CycleSort.test.js
import { cycleSort } from '../CycleSort'

describe('cycleSort function', () => {
  it('should correctly sort an input list that is sorted backwards', () => {
    const array = [5, 4, 3, 2, 1]
    expect(cycleSort(array)).toEqual([1, 2, 3, 4, 5])
  })

  it('should correctly sort an input list that is unsorted', () => {
    const array = [15, 24, 3, 2224, 1]
    expect(cycleSort(array)).toEqual([1, 3, 15, 24, 2224])
  })

  describe('Variations of input array lengths', () => {
    it('should return an empty list with the input list is an empty list', () => {
      expect(cycleSort([])).toEqual([])
    })

    it('should correctly sort an input list of length 1', () => {
      expect(cycleSort([100])).toEqual([100])
    })

    it('should correctly sort an input list of an odd length', () => {
      expect(cycleSort([101, -10, 321])).toEqual([-10, 101, 321])
    })

    it('should correctly sort an input list of an even length', () => {
      expect(cycleSort([40, 42, 56, 45, 12, 3])).toEqual([3, 12, 40, 42, 45, 56])
    })
  })

  describe('Variations of input array elements', () => {
    it('should correctly sort an input list that contains only positive numbers', () => {
      expect(cycleSort([50, 33, 11, 2])).toEqual([2, 11, 33, 50])
    })

    it('should correctly sort an input list that contains only negative numbers', () => {
      expect(cycleSort([-1, -21, -2, -35])).toEqual([-35, -21, -2, -1])
    })

    it('should correctly sort an input list that contains only a mix of positive and negative numbers', () => {
      expect(cycleSort([-40, 42, 56, -45, 12, -3])).toEqual([-45, -40, -3, 12, 42, 56])
    })

    it('should correctly sort an input list that contains only whole numbers', () => {
      expect(cycleSort([11, 3, 12, 4, -15])).toEqual([-15, 3, 4, 11, 12])
    })

    it('should correctly sort an input list that contains only decimal numbers', () => {
      expect(cycleSort([1.0, 1.42, 2.56, 33.45, 13.12, 2.3])).toEqual([1.0, 1.42, 2.3, 2.56, 13.12, 33.45])
    })

    it('should correctly sort an input list that contains only a mix of whole and decimal', () => {
      expect(cycleSort([32.40, 12.42, 56, 45, 12, 3])).toEqual([3, 12, 12.42, 32.40, 45, 56])
    })

    it('should correctly sort an input list that contains only fractional numbers', () => {
      expect(cycleSort([0.98, 0.4259, 0.56, -0.456, -0.12, 0.322])).toEqual([-0.456, -0.12, 0.322, 0.4259, 0.56, 0.98])
    })

    it('should correctly sort an input list that contains only a mix of whole, decimal, and fractional', () => {
      expect(cycleSort([-40, -0.222, 5.6, -4.5, 12, 0.333])).toEqual([-40, -4.5, -0.222, 0.333, 5.6, 12])
    })

    it('should correctly sort an input list that contains duplicates', () => {
      expect(cycleSort([4, 3, 4, 2, 1, 2])).toEqual([1, 2, 2, 3, 4, 4])
    })
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/FisherYatesShuffle.test.js
import { shuffle } from '../FisherYatesShuffle'

describe('shuffle', () => {
  it('expects to have a new array with same size', () => {
    const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    const mixedArray = shuffle(fibonacci)

    expect(mixedArray).toHaveLength(fibonacci.length)
  })

  it('expects to have a new array with same values', () => {
    const fibonacci = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
    const mixedArray = shuffle(fibonacci)

    expect(mixedArray).toContain(0)
    expect(mixedArray).toContain(1)
    expect(mixedArray).toContain(2)
    expect(mixedArray).toContain(3)
    expect(mixedArray).toContain(5)
    expect(mixedArray).toContain(8)
    expect(mixedArray).toContain(13)
    expect(mixedArray).toContain(21)
    expect(mixedArray).toContain(34)
    expect(mixedArray).toContain(55)
    expect(mixedArray).toContain(89)
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/MergeSort.test.js
import { merge, mergeSort } from '../MergeSort'

describe('merge', () => {
  it('should merge arrays correctly', () => {
    expect(merge([5, 4], [1, 2, 3])).toEqual([1, 2, 3, 5, 4])
    expect(merge([], [1, 2])).toEqual([1, 2])
    expect(merge([1, 2, 3], [1])).toEqual([1, 1, 2, 3])
    expect(merge([], [])).toEqual([])
  })
})

describe('MergeSort', () => {
  it('should work for empty arrays', () => {
    expect(mergeSort([])).toEqual([])
  })

  it('should sort arrays correctly', () => {
    expect(mergeSort([5, 4])).toEqual([4, 5])
    expect(mergeSort([8, 4, 10, 15, 9])).toEqual([4, 8, 9, 10, 15])
    expect(mergeSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(mergeSort([10, 5, 3, 8, 2, 6, 4, 7, 9, 1])).toEqual([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/PancakeSort.test.js
import { flipArray, findMax, pancakeSort } from '../PancakeSort'

describe('flipArray', () => {
  it('should flip any subarray of any array', () => {
    expect(flipArray([1, 2, 3, 4], 0, 3)).toEqual([4, 3, 2, 1])
    expect(flipArray([1, 2, 3, 4, 5], 2, 4)).toEqual([1, 2, 5, 4, 3])
    expect(flipArray([], 0, 0)).toEqual([])
  })
})

describe('findMax', () => {
  it('should find the index of the maximum value in any subarray of any array', () => {
    expect(findMax([1, 3, 2, 5], 0, 3)).toEqual(3)
    expect(findMax([1, 3, 2, 5], 0, 2)).toEqual(1)
  })
})

describe('pancakeSort', () => {
  it('should sort any array', () => {
    expect(pancakeSort([4, 3, 2, 1])).toEqual([1, 2, 3, 4])
    expect(pancakeSort([3, 1, 4, 2])).toEqual([1, 2, 3, 4])
    expect(pancakeSort([100, 1000, 10, 1])).toEqual([1, 10, 100, 1000])
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/QuickSort.test.js
import { quickSort } from '../QuickSort'

describe('QuickSort', () => {
  it('should work for empty arrays', () => {
    expect(quickSort([])).toEqual([])
  })

  it('should sort arrays correctly', () => {
    expect(quickSort([5, 4, 3, 10, 2, 1])).toEqual([1, 2, 3, 4, 5, 10])
    expect(quickSort([5, 4])).toEqual([4, 5])
    expect(quickSort([1, 2, 3])).toEqual([1, 2, 3])
    expect(quickSort([0, 5, 3, 2, 2])).toEqual([0, 2, 2, 3, 5])
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/QuickSortRecursive.test.js
import { quickSort } from '../QuickSortRecursive'

describe('QuickSortRecursive | Partition In Place Method', () => {
  it('Expectedly, throw some error if we pass a non-array input', () => {
    expect(() => quickSort('xyz', 0, 2)).toThrow('Please input a valid list or array.')
    expect(() => quickSort(null, 0, 4)).toThrow('Please input a valid list or array.')
    expect(() => quickSort(55, 0, 2)).toThrow('Please input a valid list or array.')
  })

  it('Expectedly, the quickSort method will sort the unsorted list in ascending order', () => {
    const unSortArray = [5, 9, 3, 4, 6, 2, 0, 1, 7, 8]
    const sortedExpectedArray = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    expect(quickSort(unSortArray, 0, unSortArray.length - 1)).toEqual(sortedExpectedArray)
  })

  it('Expectedly, the quickSort method will arrange the list of character values in dictionary order.', () => {
    const unSortList = ['d', 'e', 'c', 'a', 'f', 'b']
    const sortedExpectedList = ['a', 'b', 'c', 'd', 'e', 'f']
    expect(quickSort(unSortList, 0, unSortList.length - 1)).toEqual(sortedExpectedList)
  })
})

--#

--% C:/work/algos/Javascript/Sorts/test/SelectionSort.test.js
import { selectionSort } from '../SelectionSort'

describe('selectionSort', () => {
  it('expects to return the array sorted in ascending order', () => {
    const toSort = [5, 6, 7, 8, 1, 2, 12, 14]
    const expected = [1, 2, 5, 6, 7, 8, 12, 14]

    expect(selectionSort(toSort)).toEqual(expected)
  })

  it('expects to throw if it is not a valid array', () => {
    expect(() => selectionSort('abc')).toThrow('Given input is not an array')
    expect(() => selectionSort(123)).toThrow('Given input is not an array')
    expect(() => selectionSort({})).toThrow('Given input is not an array')
    expect(() => selectionSort(null)).toThrow('Given input is not an array')
    expect(() => selectionSort()).toThrow('Given input is not an array')
  })

  it('expects to throw if one of the elements in the array is not a number', () => {
    expect(() => selectionSort([1, 'x', 2])).toThrow('One of the items in your array is not a number')
  })
})

--#

--% C:/work/algos/Javascript/String/AlphaNumericPalindrome.js
/*****************************************************************************
 * @function alphaNumericPlaindrome
 * @description alphaNumericPlaindrome should return true if the string has alphanumeric characters that are palindrome irrespective of special characters and the letter case.
 * @param {string} str the string to check
 * @returns {Boolean}
 * @see [Factorial](https://en.wikipedia.org/wiki/Palindrome)
 * @example
 * The function alphaNumericPlaindrome() receives a string with varying formats
 * like "racecar", "RaceCar", and "race CAR"
 * The string can also have special characters
 * like "2A3*3a2", "2A3 3a2", and "2_A3*3#A2"
 *
 * But the catch is, we have to check only if the alphanumeric characters
 * are palindrome i.e remove spaces, symbols, punctuations etc
 * and the case of the characters doesn't matter
 *
 ****************************************************************************/

const alphaNumericPlaindrome = (str) => {
  // removing all the special characters and turning everything to lowercase
  const newStr = str.replace(/[^a-zA-Z0-9]*/g, '').toLowerCase()

  for (let i = 0; i < newStr.length; i++) {
    if (newStr[i] !== newStr[newStr.length - 1 - i]) {
      return false
    }
  }

  return true
}

export { alphaNumericPlaindrome }

--#

--% C:/work/algos/Javascript/String/AlternativeStringArrange.js
// Alternative arrange the two given strings in one string in O(n) time complexity.

// Problem Source & Explanation: https://www.geeksforgeeks.org/alternatively-merge-two-strings-in-java/

/**
 * Alternative arrange the two given strings in one string in O(n) time complexity.
 * @param {String} str1 first input string
 * @param {String} str2 second input string
 * @returns `String` return one alternative arrange string.
 */
const AlternativeStringArrange = (str1, str2) => {
  // firstly, check that both inputs are strings.
  if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    return 'Not string(s)'
  }

  // output string value.
  let outStr = ''

  // get first string length.
  const firstStringLength = str1.length
  // get second string length.
  const secondStringLength = str2.length
  // absolute length for operation.
  const absLength = firstStringLength > secondStringLength ? firstStringLength : secondStringLength

  // Iterate the character count until the absolute count is reached.
  for (let charCount = 0; charCount < absLength; charCount++) {
    // If firstStringLength is lesser than the charCount it means they are able to re-arrange.
    if (charCount < firstStringLength) {
      outStr += str1[charCount]
    }

    // If secondStringLength is lesser than the charCount it means they are able to re-arrange.
    if (charCount < secondStringLength) {
      outStr += str2[charCount]
    }
  }

  // return the output string.
  return outStr
}

export { AlternativeStringArrange }

--#

--% C:/work/algos/Javascript/String/CheckAnagram.js
// An [Anagram](https://en.wikipedia.org/wiki/Anagram) is a string that is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
// Anagram check is case sensitive; i.e. Aba and aba is not a anagram.
// inputs are strings i.e. str1 and str2
const checkAnagram = (str1, str2) => {
  // check that inputs are strings.
  if (typeof str1 !== 'string' || typeof str2 !== 'string') {
    return 'Not string(s)'
  }

  // If both strings have not same lengths then they can not be anagram.
  if (str1.length !== str2.length) {
    return false
  }

  // Use hashmap to keep count of characters in str1

  const str1CharCount = new Map()

  for (let i = 0; i < str1.length; i++) {
    let previousCount = 0
    if (str1CharCount.has(str1[i])) {
      previousCount = str1CharCount.get(str1[i])
    }
    str1CharCount.set(str1[i], previousCount + 1)
  }

  // Now check if second string has same characters?

  for (let i = 0; i < str2.length; i++) {
    let previousCount = 0
    // if str1CharCount has no key for str2[i] then not anagram.
    if (!str1CharCount.has(str2[i])) return false

    previousCount = str1CharCount.get(str2[i])
    str1CharCount.set(str2[i], previousCount - 1)
  }

  // Now check if all entries in hashmap has zeros.

  for (const key in str1CharCount) {
    if (str1CharCount[key] !== 0) return false
  }

  return true
}

export { checkAnagram }

--#

--% C:/work/algos/Javascript/String/CheckCamelCase.js
// CheckCamelCase method checks the given string is in camelCase or not.

// Problem Source & Explanation: https://en.wikipedia.org/wiki/Camel_case

/**
 * checkCamelCase method returns true if the string in camelCase, else return the false.
 * @param {String} varName the name of the variable to check.
 * @returns `Boolean` return true if the string is in camelCase, else return false.
 */
const checkCamelCase = (varName) => {
  // firstly, check that input is a string or not.
  if (typeof varName !== 'string') {
    throw new TypeError('Argument is not a string.')
  }

  const pat = /^[a-z][A-Za-z]*$/
  return pat.test(varName)
}

export { checkCamelCase }

--#

--% C:/work/algos/Javascript/String/CheckFlatCase.js
// checkFlatCase method checks if the given string is in flatcase or not. Flatcase is a convention
// where all letters are in lowercase, and there are no spaces between words.
// thisvariable is an example of flatcase. In camelCase it would be thisVariable, snake_case this_variable and so on.

// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)

/**
 * checkFlatCase method returns true if the string in flatcase, else return the false.
 * @param {string} varname the name of the variable to check.
 * @returns {boolean} return true if the string is in flatcase, else return false.
 */
const checkFlatCase = (varname) => {
  // firstly, check that input is a string or not.
  if (typeof varname !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /^[a-z]*$/
  return pat.test(varname)
}

export { checkFlatCase }

--#

--% C:/work/algos/Javascript/String/CheckKebabCase.js
// CheckKebabCase method checks the given string is in kebab-case or not.

// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)

/**
 * CheckKebabCase method returns true if the string in kebab-case, else return the false.
 * @param {String} varName the name of the variable to check.
 * @returns `Boolean` return true if the string is in kebab-case, else return false.
 */
const CheckKebabCase = (varName) => {
  // firstly, check that input is a string or not.
  if (typeof varName !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /(\w+)-(\w)([\w-]*)/
  return pat.test(varName) && !varName.includes('_')
}

export { CheckKebabCase }

--#

--% C:/work/algos/Javascript/String/CheckPalindrome.js
// Palindrome check is case sensitive; i.e. Aba is not a palindrome
// input is a string
const checkPalindrome = (str) => {
  // check that input is a string
  if (typeof str !== 'string') {
    return 'Not a string'
  }
  if (str.length === 0) {
    return 'Empty string'
  }
  // Reverse only works with array, thus convert the string to array, reverse it and convert back to string
  // return as palindrome if the reversed string is equal to the input string
  const reversed = [...str].reverse().join('')
  return str === reversed ? 'Palindrome' : 'Not a Palindrome'
}

export { checkPalindrome }

--#

--% C:/work/algos/Javascript/String/CheckPangram.js
/*
  Pangram is a sentence that contains all the letters in the alphabet
  https://en.wikipedia.org/wiki/Pangram
 */

const checkPangram = (string) => {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const frequency = new Set()

  for (const letter of string.toLowerCase()) {
    if (letter >= 'a' && letter <= 'z') {
      frequency.add(letter)
    }
  }

  return frequency.size === 26
}

export { checkPangram }

--#

--% C:/work/algos/Javascript/String/CheckPascalCase.js
// CheckPascalCase method checks the given string is in PascalCase or not.

// Problem Source & Explanation: https://www.theserverside.com/definition/Pascal-case

/**
 * CheckPascalCase method returns true if the string in PascalCase, else return the false.
 * @param {String} VarName the name of the variable to check.
 * @returns `Boolean` return true if the string is in PascalCase, else return false.
 */
const CheckPascalCase = (VarName) => {
  // firstly, check that input is a string or not.
  if (typeof VarName !== 'string') {
    return new TypeError('Argument is not a string.')
  }

  const pat = /^[A-Z][A-Za-z]*$/
  return pat.test(VarName)
}

export { CheckPascalCase }

--#

--% C:/work/algos/Javascript/String/CheckRearrangePalindrome.js
/**
  * What is a palindrome? https://en.wikipedia.org/wiki/Palindrome
  * Receives a string and returns whether it can be rearranged to become a palindrome or not
  * The string can only be a palindrome if the count of ALL characters is even or if the ONLY ONE character count is odd
  * Input is a string
  *
  **/

export const palindromeRearranging = (str) => {
  // check that input is a string
  if (typeof str !== 'string') {
    return 'Not a string'
  }
  // Check if is a empty string
  if (str.length === 0) {
    return 'Empty string'
  }

  // First obtain the character count for each character in the string and store it in an object.
  // Filter the object's values to only the odd character counts.
  const charCounts = [...str].reduce((counts, char) => {
    counts[char] = counts[char] ? counts[char] + 1 : 1
    return counts
  }, {})
  // If the length of the resulting array is 0 or 1, the string can be a palindrome.
  return Object.values(charCounts).filter(count => count % 2 !== 0).length <= 1
}

// testing

// > palindromeRearranging('aaeccrr')
// true

// > palindromeRearranging('leve')
// false

--#

--% C:/work/algos/Javascript/String/CheckSnakeCase.js
// CheckSnakeCase method checks the given string is in snake_case or not.

// Problem Source & Explanation: https://en.wikipedia.org/wiki/Naming_convention_(programming)

/**
 * checkSnakeCase method returns true if the string in snake_case, else return the false.
 * @param {String} varName the name of the variable to check.
 * @returns `Boolean` return true if the string is in snake_case, else return false.
 */
const checkSnakeCase = (varName) => {
  // firstly, check that input is a string or not.
  if (typeof varName !== 'string') {
    throw new TypeError('Argument is not a string.')
  }

  const pat = /(.*?)_([a-zA-Z])*/
  return pat.test(varName)
}

export { checkSnakeCase }

--#

--% C:/work/algos/Javascript/String/CheckWordOccurrence.js
/**
  * Check and count occurrence of each word in a string
  * Inputs a String eg. Madonna and Boolean
  **/

const checkWordOccurrence = (str, isCaseSensitive = false) => {
  if (typeof str !== 'string') {
    throw new TypeError('The first param should be a string')
  }
  if (typeof isCaseSensitive !== 'boolean') {
    throw new TypeError('The second param should be a boolean')
  }

  const result = {}
  if (str.length > 0) {
    for (let i = 0; i < str.length; i++) {
      const word = isCaseSensitive ? str[i] : str[i].toUpperCase()
      if (/\s/.test(word)) continue
      result[word] = (!result[word]) ? 1 : result[word] + 1
    }
  }

  return result
}
export { checkWordOccurrence }

--#

--% C:/work/algos/Javascript/String/CountVowels.js
/**
 * @function countVowels
 * @description Given a string of words or phrases, count the number of vowels.
 * @param {String} url - The input string
 * @return {Number} count
 * @example countVowels("ABCDE") => 2
 * @example countVowels("Hello") => 2
 */

const countVowels = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Input should be a string')
  }
  const vowels = new Set(['a', 'e', 'i', 'o', 'u'])
  let count = 0
  for (let i = 0; i < str.length; i++) {
    const char = str[i].toLowerCase()
    if (vowels.has(char)) {
      count++
    }
  }
  return count
}

export { countVowels }

--#

--% C:/work/algos/Javascript/String/CreatePermutations.js
/*
a permutation of a set is, loosely speaking, an arrangement of its members into a sequence or linear order, or if the set is already ordered, a rearrangement of its elements.
The word "permutation" also refers to the act or process of changing the linear order of an ordered set
More at : https://en.wikipedia.org/wiki/Permutation
*/

const createPermutations = (str) => {
// convert string to array
  const arr = str.split('')

  // get array length
  const strLen = arr.length
  // this will hold all the permutations
  const perms = []
  let rest
  let picked
  let restPerms
  let next

  // if strLen is zero, return the same string
  if (strLen === 0) { return [str] }
  // loop to the length to get all permutations
  for (let i = 0; i < strLen; i++) {
    rest = Object.create(arr)
    picked = rest.splice(i, 1)

    restPerms = createPermutations(rest.join(''))

    for (let j = 0, jLen = restPerms.length; j < jLen; j++) {
      next = picked.concat(restPerms[j])
      perms.push(next.join(''))
    }
  }
  return perms
}
export { createPermutations }

--#

--% C:/work/algos/Javascript/String/DiceCoefficient.js
/* The SrensenDice coefficient is a statistic used to gauge the similarity of two samples.
 * Applied to strings, it can give you a value between 0 and 1 (included) which tells you how similar they are.
 * Dice coefficient is calculated by comparing the bigrams of both strings,
 * a bigram is a substring of the string of length 2.
 * read more: https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient
 */

// Time complexity: O(m + n), m and n being the sizes of string A and string B

// Find the bistrings of a string and return a hashmap (key => bistring, value => count)
function mapBigrams (string) {
  const bigrams = new Map()
  for (let i = 0; i < string.length - 1; i++) {
    const bigram = string.substring(i, i + 2)
    const count = bigrams.get(bigram)
    bigrams.set(bigram, (count || 0) + 1)
  }
  return bigrams
}

// Calculate the number of common bigrams between a map of bigrams and a string

function countCommonBigrams (bigrams, string) {
  let count = 0
  for (let i = 0; i < string.length - 1; i++) {
    const bigram = string.substring(i, i + 2)
    if (bigrams.has(bigram)) count++
  }
  return count
}

// Calculate Dice coeff of 2 strings
function diceCoefficient (stringA, stringB) {
  if (stringA === stringB) return 1
  else if (stringA.length < 2 || stringB.length < 2) return 0

  const bigramsA = mapBigrams(stringA)

  const lengthA = stringA.length - 1
  const lengthB = stringB.length - 1

  let dice = (2 * countCommonBigrams(bigramsA, stringB)) / (lengthA + lengthB)

  // cut 0.xxxxxx to 0.xx for simplicity
  dice = Math.floor(dice * 100) / 100

  return dice
}

export { diceCoefficient }

--#

--% C:/work/algos/Javascript/String/FormatPhoneNumber.js
// function that takes 10 digits and returns a string of the formatted phone number
// e.g.: 1234567890 -> (123) 456-7890

const formatPhoneNumber = (numbers) => {
  const numbersString = numbers.toString()
  if ((numbersString.length !== 10) || isNaN(numbersString)) {
    // return "Invalid phone number."
    throw new TypeError('Invalid phone number.')
  }
  const arr = '(XXX) XXX-XXXX'.split('')
  Array.from(numbersString).forEach(n => {
    arr[arr.indexOf('X')] = n
  })
  return arr.join('')
}

export { formatPhoneNumber }

--#

--% C:/work/algos/Javascript/String/GenerateGUID.js
/*
Generates a UUID/GUID in Node.Js.
The script uses `Math.random` in combination with the timestamp for better randomness.
The function generate an RFC4122 (https://www.ietf.org/rfc/rfc4122.txt) version 4 UUID/GUID
*/

export const Guid = () => {
  const pattern = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'
  let currentDateMilliseconds = new Date().getTime()
  return pattern.replace(/[xy]/g, currentChar => {
    const randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0
    currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16)
    return (currentChar === 'x' ? randomChar : (randomChar & 0x7 | 0x8)).toString(16)
  })
}

// > Guid()
// 'edc848db-3478-1760-8b55-7986003d895f'

--#

--% C:/work/algos/Javascript/String/HammingDistance.js
/**
 * Hamming Distance: https://en.wikipedia.org/wiki/Hamming_distance
 *
 *
 * Hamming distance is a metric for comparing two binary data strings.
 *
 * While comparing two binary strings of equal length, Hamming distance
 * is the number of bit positions in which the two bits are different.
 * The Hamming distance between two strings, a and b is denoted as d(a,b)
 */

/**
 * @param {string} a
 * @param {string} b
 * @return {number}
 */

export const hammingDistance = (a, b) => {
  if (a.length !== b.length) {
    throw new Error('Strings must be of the same length')
  }

  let distance = 0

  for (let i = 0; i < a.length; i += 1) {
    if (a[i] !== b[i]) {
      distance += 1
    }
  }

  return distance
}

--#

--% C:/work/algos/Javascript/String/KMPPatternSearching.js
// Implementing KMP Search Algorithm to search all the instances of pattern in
// given text
// Reference Book: Introduction to Algorithms, CLRS

// Explanation: https://www.topcoder.com/community/competitive-programming/tutorials/introduction-to-string-searching-algorithms/

const computeLPS = (pattern) => {
  const lps = Array(pattern.length)
  lps[0] = 0
  for (let i = 1; i < pattern.length; i++) {
    let matched = lps[i - 1]
    while (matched > 0 && pattern[i] !== pattern[matched]) {
      matched = lps[matched - 1]
    }
    if (pattern[i] === pattern[matched]) {
      matched++
    }
    lps[i] = matched
  }
  return lps
}

/**
 * Returns all indices where pattern starts in text
 * @param {*} text a big text in which pattern string is to find
 * @param {*} pattern the string to find
 */
const KMPSearch = (text, pattern) => {
  if (!pattern || !text) {
    return [] // no results
  }

  // lps[i] = length of proper prefix of pattern[0]...pattern[i-1]
  //          which is also proper suffix of it
  const lps = computeLPS(pattern)
  const result = []

  let matched = 0
  for (let i = 0; i < text.length; i++) {
    while (matched > 0 && text[i] !== pattern[matched]) {
      matched = lps[matched - 1]
    }
    if (text[i] === pattern[matched]) {
      matched++
    }
    if (matched === pattern.length) {
      result.push(i - pattern.length + 1)
      matched = lps[matched - 1]
    }
  }

  return result
}

export { KMPSearch }

--#

--% C:/work/algos/Javascript/String/LevenshteinDistance.js
/* The Levenshtein distance (a.k.a edit distance) is a
measure of similarity between two strings. It is
defined as the minimum number of changes required to
convert string a into string b (this is done by
inserting, deleting or replacing a character in
string a).
The smaller the Levenshtein distance,
the more similar the strings are. This is a very
common problem in the application of Dynamic Programming.
*/

const levenshteinDistance = (a, b) => {
  // Declaring array 'D' with rows = len(a) + 1 and columns = len(b) + 1:
  const distanceMatrix = Array(b.length + 1)
    .fill(null)
    .map(() => Array(a.length + 1).fill(null))

  // Initializing first column:
  for (let i = 0; i <= a.length; i += 1) {
    distanceMatrix[0][i] = i
  }

  // Initializing first row:
  for (let j = 0; j <= b.length; j += 1) {
    distanceMatrix[j][0] = j
  }

  for (let j = 1; j <= b.length; j += 1) {
    for (let i = 1; i <= a.length; i += 1) {
      const indicator = a[i - 1] === b[j - 1] ? 0 : 1
      // choosing the minimum of all three, vis-a-vis:
      distanceMatrix[j][i] = Math.min(
        distanceMatrix[j][i - 1] + 1, // deletion
        distanceMatrix[j - 1][i] + 1, // insertion
        distanceMatrix[j - 1][i - 1] + indicator // substitution
      )
    }
  }

  return distanceMatrix[b.length][a.length]
}

export { levenshteinDistance }

--#

--% C:/work/algos/Javascript/String/Lower.js
/**
 * @function lower
 * @description Will convert the entire string to lowercase letters.
 * @param {String} url - The input URL string
 * @return {String} Lowercase string
 * @example lower("HELLO") => hello
 * @example lower("He_llo") => he_llo
 */

const lower = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input Type')
  }

  let lowerString = ''

  for (const char of str) {
    let asciiCode = char.charCodeAt(0)
    if (asciiCode >= 65 && asciiCode <= 90) {
      asciiCode += 32
    }
    lowerString += String.fromCharCode(asciiCode)
  }

  return lowerString
}

export { lower }

--#

--% C:/work/algos/Javascript/String/MaxCharacter.js
/*
  Given a string of characters, return the character that appears the most often.
  Example: input = "Hello World!" return "l"
*/
const maxCharacter = (value) => {
  if (typeof value !== 'string') {
    throw new TypeError('The param should be a string')
  } else if (!value) {
    throw new Error('The param should be a valid string')
  }

  const occurrences = {}
  for (let i = 0; i < value.length; i++) {
    const char = value[i]
    if (/\s/.test(char)) continue
    occurrences[char] = occurrences[char] + 1 || 1
  }
  let maxCharacter = null
  let maxCount = 0
  Object.keys(occurrences).forEach(char => {
    if (occurrences[char] > maxCount) {
      maxCount = occurrences[char]
      maxCharacter = char
    }
  })
  return maxCharacter
}

export { maxCharacter }

--#

--% C:/work/algos/Javascript/String/MaxWord.js
// Given a sentence, return the most occurring word

/**
 * @param {string} sentence - the sentence you want to find the most occurring word
 * @returns {string} - the most occurring word
 *
 * @example
 *     -  maxWord('lala lili lala'); // lala
 */
const maxWord = (sentence = '') => {
  if (typeof sentence !== 'string') {
    throw new TypeError('the param should be string')
  }

  if (!sentence) {
    return null
  }

  const words = sentence.split(' ')
  if (words.length < 2) {
    return words[0]
  }

  const occurrences = {}
  words.forEach(word => {
    occurrences[word.toLocaleLowerCase()] = occurrences[word.toLocaleLowerCase()] + 1 || 1
  })

  const max = Object.keys(occurrences).reduce((n, word) => {
    if (occurrences[word] > n.count) { return { word, count: occurrences[word] } } else { return n }
  }, { word: '', count: 0 })

  return max.word
}

export { maxWord }

--#

--% C:/work/algos/Javascript/String/PatternMatching.js
/*
Pattern matching is case insensitive as
the inputs are converted to lower case before the
algorithm is run.

The algorithm will run through the entire text and
return the starting index if the given pattern is
available in the text
*/
const checkIfPatternExists = (text, pattern) => {
  if (typeof text !== 'string' || typeof pattern !== 'string') {
    throw new TypeError('Given input is not a string')
  }
  const textLength = text.length // Store the length of the text in a variable
  const patternLength = pattern.length // Store the length of the pattern in a variable

  // Iterate through the text until the textlength - patternlength index
  for (let i = 0; i <= textLength - patternLength; i++) {
    // For each character in the text check if the subsequent character
    // are matching the given pattern; if not break from the condition
    for (let j = 0; j < textLength; j++) {
      if (text[i + j] !== pattern[j]) break

      // For each iteration of j check if the value of
      // j + 1 is equal to the length of the pattern
      if (j + 1 === patternLength) {
        return `Given pattern is found at index ${i}`
      }
    }
  }
}

export { checkIfPatternExists }

--#

--% C:/work/algos/Javascript/String/PermutateString.js
'use strict'

const permutate = (aString) => {
  if (typeof aString !== 'string' || !aString) {
    throw new Error('The arg must be a valid, non empty string')
  }
  const characters = aString.split('')
  let permutations = [[characters.shift()]]
  while (characters.length) {
    const currentCharacter = characters.shift()
    permutations = calculateCurrentCharacterPermutation(permutations, currentCharacter)
  }
  return permutations
    .map(character => character.join(''))
    .filter((item, index, self) => (self.indexOf(item) === index))
    .sort()
}

const calculateCurrentCharacterPermutation = (allPermutations, currentCharacter) => {
  const currentPermutations = []
  allPermutations.forEach(permutation => {
    let index = 0
    while (index <= permutation.length) {
      const tmp = [...permutation]
      tmp.splice(index, 0, currentCharacter)
      currentPermutations.push(tmp)
      index++
    }
  })
  return currentPermutations
}

export { permutate }

--#

--% C:/work/algos/Javascript/String/ReverseString.js
/**
 * A short example showing how to reverse a string.
 */
function ReverseStringIterative (string) {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }
  let reversedString = ''
  let index

  for (index = string.length - 1; index >= 0; index--) {
    reversedString += string[index]
  }

  return reversedString
}

/**
 * JS disallows string mutation so we're actually a bit slower.
 *
 * @complexity O(n)
 */
function ReverseStringIterativeInplace (string) {
  if (typeof string !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const _string = string.split('')

  for (let i = 0; i < Math.floor(_string.length / 2); i++) {
    const first = _string[i]
    _string[i] = _string[_string.length - 1 - i]
    _string[_string.length - 1 - i] = first
  }

  return _string.join('')
}

export { ReverseStringIterative, ReverseStringIterativeInplace }

--#

--% C:/work/algos/Javascript/String/ReverseWords.js
const reverseWords = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('The given value is not a string')
  }
  // Split string into words
  // Ex. "I Love JS" => ["I", "Love", "JS"]
  const words = str.split(' ')
  // reverse words
  // ["I", "Love", "JS"] => ["JS", "Love", "I"]
  const reversedWords = words.reverse()
  // join reversed words with space and return
  // ["JS", "Love", "I"] => "JS Love I"
  return reversedWords.join(' ')
}

export { reverseWords }

--#

--% C:/work/algos/Javascript/String/ScrambleStrings.js
// Problem Statement and Explanation: https://leetcode.com/problems/scramble-string/

/**
 * Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */

const isScramble = (s1, s2) => {
  return helper({}, s1, s2)
}

const helper = function (dp, s1, s2) {
  const map = {}

  if (dp[s1 + s2] !== undefined) return dp[s1 + s2]
  if (s1 === s2) return true

  for (let j = 0; j < s1.length; j++) {
    if (map[s1[j]] === undefined) map[s1[j]] = 0
    if (map[s2[j]] === undefined) map[s2[j]] = 0
    map[s1[j]]++
    map[s2[j]]--
  }

  for (const key in map) {
    if (map[key] !== 0) {
      dp[s1 + s2] = false
      return false
    }
  }

  for (let i = 1; i < s1.length; i++) {
    if (
      (helper(dp, s1.substr(0, i), s2.substr(0, i)) &&
        helper(dp, s1.substr(i), s2.substr(i))) ||
      (helper(dp, s1.substr(0, i), s2.substr(s2.length - i)) &&
        helper(dp, s1.substr(i), s2.substr(0, s2.length - i)))
    ) {
      dp[s1 + s2] = true
      return true
    }
  }

  dp[s1 + s2] = false
  return false
}

export { isScramble }

--#

--% C:/work/algos/Javascript/String/Upper.js
/**
 * @function upper
 * @description Will convert the entire string to uppercase letters.
 * @param {String} url - The input URL string
 * @return {String} Uppercase string
 * @example upper("hello") => HELLO
 * @example upper("He_llo") => HE_LLO
 */

const upper = (str) => {
  if (typeof str !== 'string') {
    throw new TypeError('Invalid Input Type')
  }

  let upperString = ''

  for (const char of str) {
    let asciiCode = char.charCodeAt(0)
    if (asciiCode >= 97 && asciiCode <= 122) {
      asciiCode -= 32
    }
    upperString += String.fromCharCode(asciiCode)
  }

  return upperString
}

export { upper }

--#

--% C:/work/algos/Javascript/String/ValidateCreditCard.js
/**
 * Validate a given credit card number
 *
 * The core of the validation of credit card numbers is the Luhn algorithm.
 *
 * The validation sum should be completely divisible by 10 which is calculated as follows,
 * every first digit is added directly to the validation sum.
 * For every second digit in the credit card number, the digit is multiplied by 2.
 * If the product is greater than 10 the digits of the product are added.
 * This resultant digit is considered for the validation sum rather than the digit itself.
 *
 * Ref: https://www.geeksforgeeks.org/luhn-algorithm/
 */

const luhnValidation = (creditCardNumber) => {
  let validationSum = 0
  creditCardNumber.split('').forEach((digit, index) => {
    let currentDigit = parseInt(digit)
    if (index % 2 === 0) {
      // Multiply every 2nd digit from the left by 2
      currentDigit *= 2
      // if product is greater than 10 add the individual digits of the product to get a single digit
      if (currentDigit > 9) {
        currentDigit %= 10
        currentDigit += 1
      }
    }
    validationSum += currentDigit
  })

  return validationSum % 10 === 0
}

const validateCreditCard = (creditCardString) => {
  const validStartSubString = ['4', '5', '6', '37', '34', '35'] // Valid credit card numbers start with these numbers

  if (typeof creditCardString !== 'string') {
    throw new TypeError('The given value is not a string')
  }

  const errorMessage = `${creditCardString} is an invalid credit card number because `
  if (isNaN(creditCardString)) {
    throw new TypeError(errorMessage + 'it has nonnumerical characters.')
  }
  const creditCardStringLength = creditCardString.length
  if (!((creditCardStringLength >= 13) && (creditCardStringLength <= 16))) {
    throw new Error(errorMessage + 'of its length.')
  }
  if (!validStartSubString.some(subString => creditCardString.startsWith(subString))) {
    throw new Error(errorMessage + 'of its first two digits.')
  }
  if (!luhnValidation(creditCardString)) {
    throw new Error(errorMessage + 'it fails the Luhn check.')
  }

  return true
}

export { validateCreditCard }

--#

--% C:/work/algos/Javascript/String/ValidateEmail.js
/**
 * Returns whether the given string is a valid email address or not.
 */
const validateEmail = (str) => {
  if (str === '' || str === null) {
    throw new TypeError('Email Address String Null or Empty.')
  }

  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(str)
}

export { validateEmail }

--#

--% C:/work/algos/Javascript/String/ValidateUrl.js
/**
 * @function ValidateURL
 * @description validate the URL.
 * @param {String} url - The input URL string
 * @return {Boolean}
 */
const validateURL = (url) => {
  const URL_PATTERN = /^(https?:\/\/(?:www\.|(?!www))[^\s.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})$/gi

  return URL_PATTERN.test(url)
}

export { validateURL }

--#

--% C:/work/algos/Javascript/String/test/AlphaNumericPalindrome.test.js
import { alphaNumericPlaindrome } from '../AlphaNumericPalindrome'

test('should return true if the given string has alphanumeric characters that are palindrom irrespective of case and symbols', () => {
  expect(alphaNumericPlaindrome('eye')).toBe(true)
})

test('should return true if the given string has alphanumeric characters that are palindrom irrespective of case and symbols', () => {
  expect(alphaNumericPlaindrome('0_0 (: /-:) 0-0')).toBe(true)
})

test('should return true if the given string has alphanumeric characters that are palindrom irrespective of case and symbols', () => {
  expect(alphaNumericPlaindrome('five|_/|four')).toBe(false)
})

test('should return true if the given string has alphanumeric characters that are palindrom irrespective of case and symbols', () => {
  expect(alphaNumericPlaindrome('A man, a plan, a canal. Panama')).toBe(true)
})

test('should return true if the given string has alphanumeric characters that are palindrom irrespective of case and symbols', () => {
  expect(alphaNumericPlaindrome('1 eye for of 1 eye.')).toBe(false)
})

--#

--% C:/work/algos/Javascript/String/test/CheckAnagram.test.js
import { checkAnagram } from '../CheckAnagram'

describe('checkAnagram', () => {
  it.each`
    inputOne              | inputTwo
    ${123456}             | ${'abcd'}
    ${[1, 2, 3, 4, 5, 6]} | ${'abcd'}
    ${{ test: 'test' }}   | ${'abcd'}
    ${'abcd'}             | ${123456}
    ${'abcd'}             | ${[1, 2, 3, 4, 5, 6]}
    ${'abcd'}             | ${{ test: 'test' }}
  `(
    'expects to return "Not string(s)" given values $inputOne and $inputTwo',
    ({ inputOne, inputTwo }) => {
      const SUT = checkAnagram(inputOne, inputTwo)
      expect(SUT).toBe('Not string(s)')
    }
  )

  it('expects to return false if the arguments have different lengths', () => {
    const SUT = checkAnagram('abs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return false if the arguments are not anagrams', () => {
    const SUT = checkAnagram('abcs', 'abds')
    expect(SUT).toBe(false)
  })

  it('expects to return true if the arguments are anagrams', () => {
    const SUT = checkAnagram('abcd', 'bcad')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of length 1 and are the same letter', () => {
    const SUT = checkAnagram('a', 'a')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments of are both empty strings', () => {
    const SUT = checkAnagram('', '')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an odd length', () => {
    const SUT = checkAnagram('abcde', 'edcab')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams with an even length', () => {
    const SUT = checkAnagram('abcdef', 'fedcab')
    expect(SUT).toBe(true)
  })

  it('expects to return false if either argument is an empty string while the other is not', () => {
    const SUT = checkAnagram('', 'edcab')
    expect(SUT).toBe(false)
    const SUT2 = checkAnagram('edcab', '')
    expect(SUT2).toBe(false)
  })

  it('expects to return false if the arguments contain the same letters but have unequal case', () => {
    const SUT = checkAnagram('ABDCE', 'abcde')
    expect(SUT).toBe(false)
    const SUT2 = checkAnagram('AbCdE', 'aBCdE')
    expect(SUT2).toBe(false)
  })

  it('expects to return true if the arguments are anagrams and contain number characters', () => {
    const SUT = checkAnagram('a1b2', '12ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain space characters', () => {
    const SUT = checkAnagram('a1 b2', '1 2ba')
    expect(SUT).toBe(true)
  })

  it('expects to return true if the arguments are anagrams and contain punctuation characters', () => {
    const SUT = checkAnagram('a!1b@2', '1@2ba!')
    expect(SUT).toBe(true)
  })

  it('expects to return false if the arguments contain the same letters but contain a different amount of space characters', () => {
    const SUT = checkAnagram('ea        cb', 'e cba')
    expect(SUT).toBe(false)
  })
})

--#

--% C:/work/algos/Javascript/String/test/CheckCamelCase.test.js
import { checkCamelCase } from '../CheckCamelCase'
describe('checkCamelCase', () => {
  it('expect to throw an error if input is not a string', () => {
    expect(() => checkCamelCase(null)).toThrow()
  })

  it('expects to return true if the input is in camel case format', () => {
    const value = 'dockerBuild'
    const result = checkCamelCase(value)
    expect(result).toBe(true)
  })

  it('expects to return false if the input is not in camel case format', () => {
    const value = 'docker_build'
    const result = checkCamelCase(value)
    expect(result).toBe(false)
  })
})

--#

--% C:/work/algos/Javascript/String/test/CheckFlatCase.test.js
import { checkFlatCase } from '../CheckFlatCase'

describe('checkFlatCase function', () => {
  it('should return false when the input string is not in flatcase', () => {
    const actual = checkFlatCase('this is not in flatcase')
    expect(actual).toBe(false)
  })

  it('should return true when the input string is a single letter character', () => {
    const actual = checkFlatCase('a')
    expect(actual).toBe(true)
  })

  it('should return true when the input string is a string of lowercase letter characters with no spaces', () => {
    const actual = checkFlatCase('abcdefghijklmnopqrstuvwxyz')
    expect(actual).toBe(true)
  })
})

--#

--% C:/work/algos/Javascript/String/test/CheckPalindrome.test.js
import { checkPalindrome } from '../CheckPalindrome'

describe('checkPalindrome', () => {
  it('expects to return "Palindrome" if the given string is a palindrome', () => {
    const SUT = checkPalindrome('madam')
    expect(SUT).toBe('Palindrome')
  })
  it('expects to return "Empty string" if the given string is empty', () => {
    const SUT = checkPalindrome('')
    expect(SUT).toBe('Empty string')
  })
  it('expects to return "Not a string" if the given string is not a string', () => {
    const SUT = checkPalindrome(123)
    expect(SUT).toBe('Not a string')
  })
})

--#

--% C:/work/algos/Javascript/String/test/CheckPangram.test.js
import { checkPangram } from '../CheckPangram'

describe('checkPangram', () => {
  it('"The quick brown fox jumps over the lazy dog" is a pangram', () => {
    expect(
      checkPangram('The quick brown fox jumps over the lazy dog')
    ).toBeTruthy()
  })

  it('"Waltz, bad nymph, for quick jigs vex." is a pangram', () => {
    expect(checkPangram('Waltz, bad nymph, for quick jigs vex.')).toBeTruthy()
  })

  it('"Jived fox nymph grabs quick waltz." is a pangram', () => {
    expect(checkPangram('Jived fox nymph grabs quick waltz.')).toBeTruthy()
  })

  it('"My name is Unknown" is NOT a pangram', () => {
    expect(checkPangram('My name is Unknown')).toBeFalsy()
  })

  it('"The quick brown fox jumps over the la_y dog" is NOT a pangram', () => {
    expect(
      checkPangram('The quick brown fox jumps over the la_y dog')
    ).toBeFalsy()
  })

  it('Throws an error if given param is not a string', () => {
    expect(() => {
      checkPangram(undefined)
    }).toThrow('The given value is not a string')
  })
})

--#

--% C:/work/algos/Javascript/String/test/CheckSnakeCase.test.js
import { checkSnakeCase } from '../CheckSnakeCase'
describe('checkSnakeCase', () => {
  it('expect to throw an error if input is not a string', () => {
    expect(() => checkSnakeCase(0)).toThrow()
  })

  it('expects to return true if the input is in snake case format', () => {
    const value = 'docker_build'
    const result = checkSnakeCase(value)
    expect(result).toBe(true)
  })

  it('expects to return false if the input is not in snake case format', () => {
    const value = 'dockerBuild'
    const result = checkSnakeCase(value)
    expect(result).toBe(false)
  })
})

--#

--% C:/work/algos/Javascript/String/test/CheckWordOcurrence.test.js
import { checkWordOccurrence } from '../CheckWordOccurrence'
describe('checkWordOccurrence', () => {
  it('expects throw on insert wrong string', () => {
    const value = 123
    expect(() => checkWordOccurrence(value)).toThrow()
  })
  it('expect throw on insert wrong param for case sensitive', () => {
    const value = 'hello'
    expect(() => checkWordOccurrence(value, value)).toThrow()
  })
  it('check occurrence with case sensitive', () => {
    const stringToTest = 'A Mad World'
    const charsOccurrences = checkWordOccurrence(stringToTest, true)
    const expectResult = { A: 1, M: 1, a: 1, d: 2, W: 1, l: 1, o: 1, r: 1 }
    const occurrencesObjectKeys = Object.keys(charsOccurrences)
    const expectObjectKeys = Object.keys(expectResult)
    expect(occurrencesObjectKeys.length).toBe(expectObjectKeys.length)
    expectObjectKeys.forEach(key => {
      expect(expectResult[key]).toBe(charsOccurrences[key])
    })
  })
  it('check occurrence with case insensitive', () => {
    const stringToTest = 'A Mad World'
    const charsOccurrences = checkWordOccurrence(stringToTest, false)
    const expectResult = { A: 2, D: 2, L: 1, M: 1, O: 1, R: 1, W: 1 }
    const occurrencesObjectKeys = Object.keys(charsOccurrences)
    const expectObjectKeys = Object.keys(expectResult)
    expect(occurrencesObjectKeys.length).toBe(expectObjectKeys.length)
    expectObjectKeys.forEach(key => {
      expect(expectResult[key]).toBe(charsOccurrences[key])
    })
  })
})

--#

--% C:/work/algos/Javascript/String/test/CountVowels.test.js
import { countVowels } from '../CountVowels'

describe('CountVowels', () => {
  it('expect throws on use wrong param', () => {
    expect(() => countVowels(0)).toThrow()
  })

  it('count the vowels in a string', () => {
    const value = 'Mad World'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return 0 when input is a string with no vowels', () => {
    const value = 'bcdfgh'
    const count = countVowels(value)
    expect(count).toBe(0)
  })

  it('should return 1 when input is a string of length 1 that is a vowel', () => {
    const value = 'a'
    const count = countVowels(value)
    expect(count).toBe(1)
  })

  it('should return the correct result when input is in all uppercase letters', () => {
    const value = 'ABCDE'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return the correct result when input is in all lowercase letters', () => {
    const value = 'abcdefghi'
    const count = countVowels(value)
    expect(count).toBe(3)
  })

  it('should return the correct result when input string contains spaces', () => {
    const value = 'abc def   ghi'
    const count = countVowels(value)
    expect(count).toBe(3)
  })

  it('should return the correct result when input contains number characters', () => {
    const value = 'a1b2c3'
    const count = countVowels(value)
    expect(count).toBe(1)
  })

  it('should return the correct result when input contains punctuation characters', () => {
    const value = 'a!b.ce)'
    const count = countVowels(value)
    expect(count).toBe(2)
  })

  it('should return 0 when the input is an empty string', () => {
    const value = ''
    const count = countVowels(value)
    expect(count).toBe(0)
  })

  it('should count multiple occurrences of the same vowel in the input', () => {
    const value = 'aaaaa'
    const count = countVowels(value)
    expect(count).toBe(5)
  })
})

--#

--% C:/work/algos/Javascript/String/test/CreatePermutations.test.js
import { createPermutations } from '../CreatePermutations'

describe('createPermutations', () => {
  it('expects to generate 6 different combinations', () => {
    const text = 'abc'
    const SUT = createPermutations(text)
    expect(SUT).toStrictEqual(['abc', 'acb', 'bac', 'bca', 'cab', 'cba'])
  })
  it('expects to generate 2 different combinations', () => {
    const text = '12'
    const SUT = createPermutations(text)
    expect(SUT).toStrictEqual(['12', '21'])
  })
})

--#

--% C:/work/algos/Javascript/String/test/DiceCoefficient.test.js
import { diceCoefficient } from '../DiceCoefficient'

describe('diceCoefficient', () => {
  it('should calculate edit distance between two strings', () => {
    // equal strings return 1 (max possible value)
    expect(diceCoefficient('abc', 'abc')).toBe(1)
    expect(diceCoefficient('', '')).toBe(1)

    // string length needs to be at least 2 (unless equal)
    expect(diceCoefficient('a', '')).toBe(0)
    expect(diceCoefficient('', 'a')).toBe(0)

    expect(diceCoefficient('skate', 'ate')).toBe(0.66)

    expect(diceCoefficient('money', 'honey')).toBe(0.75)

    expect(diceCoefficient('love', 'hate')).toBe(0)

    expect(diceCoefficient('skilled', 'killed')).toBe(0.9)
  })
})

--#

--% C:/work/algos/Javascript/String/test/FormatPhoneNumber.test.js
import { formatPhoneNumber } from '../FormatPhoneNumber'

describe('PhoneNumberFormatting', () => {
  it('expects to return the formatted phone number', () => {
    expect(formatPhoneNumber('1234567890')).toEqual('(123) 456-7890')
  })

  it('expects to return the formatted phone number', () => {
    expect(formatPhoneNumber(1234567890)).toEqual('(123) 456-7890')
  })

  it('expects to throw a type error', () => {
    expect(() => { formatPhoneNumber('1234567') }).toThrow('Invalid phone number.')
  })

  it('expects to throw a type error', () => {
    expect(() => { formatPhoneNumber('123456text') }).toThrow('Invalid phone number.')
  })

  it('expects to throw a type error', () => {
    expect(() => { formatPhoneNumber(12345) }).toThrow('Invalid phone number.')
  })
})

--#

--% C:/work/algos/Javascript/String/test/HammingDistance.test.js
import { hammingDistance } from '../HammingDistance'

test('should throw an error when trying to compare the strings of different length', () => {
  const compareStringsOfDifferentLength = () => {
    hammingDistance('abc', 'abcd')
  }

  expect(compareStringsOfDifferentLength).toThrowError()
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('a', 'a')).toBe(0)
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('abc', 'add')).toBe(2)
})

test('should calculate difference between two strings', () => {
  expect(hammingDistance('1011101', '1001001')).toBe(2)
})

--#

--% C:/work/algos/Javascript/String/test/KMPPatternSearching.test.js
import { KMPSearch } from '../KMPPatternSearching'

describe('KMP Matcher', () => {
  it('TC1: expects to return matching indices for pattern in text', () => {
    const text = 'ABC ABCDAB ABCDABCDABDE'
    const pattern = 'ABCDABD'
    expect(KMPSearch(text, pattern)).toStrictEqual([15])
  })

  it('TC2: expects to return matching indices for pattern in text', () => {
    const text = 'ABC ABCDABD ABCDABCDABDE'
    const pattern = 'ABCDABD'
    expect(KMPSearch(text, pattern)).toStrictEqual([4, 16])
  })

  it('TC3: expects to return matching indices for pattern in text', () => {
    const text = 'AAAAA'
    const pattern = 'AAA'
    expect(KMPSearch(text, pattern)).toStrictEqual([0, 1, 2])
  })

  it('TC4: expects to return matching indices for pattern in text', () => {
    const text = 'ABCD'
    const pattern = 'BA'
    expect(KMPSearch(text, pattern)).toStrictEqual([])
  })
})

--#

--% C:/work/algos/Javascript/String/test/LevenshteinDistance.test.js
import { levenshteinDistance } from '../LevenshteinDistance'

describe('levenshteinDistance', () => {
  it('should calculate edit distance between two strings', () => {
    expect(levenshteinDistance('', '')).toBe(0)
    expect(levenshteinDistance('a', '')).toBe(1)
    expect(levenshteinDistance('', 'a')).toBe(1)
    expect(levenshteinDistance('abc', '')).toBe(3)
    expect(levenshteinDistance('', 'abc')).toBe(3)

    // Should just add I to the beginning.
    expect(levenshteinDistance('igloo', 'gloo')).toBe(1)

    // Should just substitute i with o, m with g and insert e at end
    expect(levenshteinDistance('firm', 'forge')).toBe(3)

    // Should just substitute f with s, g with t and delete h
    expect(levenshteinDistance('fighting', 'sitting')).toBe(3)

    // Should add 4 letters b, a, s and e at the beginning.
    expect(levenshteinDistance('ball', 'baseball')).toBe(4)

    // Should delete 4 letters b, a, s and e at the beginning and replace the last 4 with f, o, o, t
    expect(levenshteinDistance('baseball', 'foot')).toBe(8)
  })
})

--#

--% C:/work/algos/Javascript/String/test/Lower.test.js
import { lower } from '../Lower'

describe('Lower', () => {
  it('return uppercase strings', () => {
    expect(lower('hello')).toBe('hello')
    expect(lower('WORLD')).toBe('world')
    expect(lower('hello_WORLD')).toBe('hello_world')
  })
})

--#

--% C:/work/algos/Javascript/String/test/MaxCharacter.test.js
import { maxCharacter } from '../MaxCharacter'

describe('Testing the maxCharacter function', () => {
  it('Expect throw with wrong arg', () => {
    expect(() => maxCharacter(123)).toThrow()
  })
  it('Check the max character in string', () => {
    const theString = 'I can\'t do that'
    const maxChar = maxCharacter(theString)
    expect(maxChar).toBe('t')
  })
})

--#

--% C:/work/algos/Javascript/String/test/MaxWord.test.js
import { maxWord } from '../MaxWord'

describe('Testing the maxWord function', () => {
  it('Expect throw with non string argument', () => {
    expect(() => maxWord(10)).toThrow()
  })
  it('get the max word', () => {
    const string = 'be be be be a a banana'
    const mostOccurringWord = maxWord(string)
    expect(mostOccurringWord).toBe('be')
  })
})

--#

--% C:/work/algos/Javascript/String/test/PatternMatching.test.js
import { checkIfPatternExists } from '../PatternMatching'
describe('checkIfPatternExists', () => {
  it('expects to find a pattern with correct input', () => {
    const text = 'AABAACAADAABAAAABAA'
    const pattern = 'AABA'
    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())
    expect(SUT).toBe('Given pattern is found at index 0')
  })
  it('expects to return a message when there is no pattern', () => {
    const text = 'ABCDEFG'
    const pattern = 'AEG'
    const SUT = checkIfPatternExists(text.toLowerCase(), pattern.toLowerCase())
    expect(SUT).toBe(undefined)
  })
  it('expects to find a pattern independent of casing', () => {
    const text = 'AbCAAAAAAB'
    const pattern = 'abc'
    const SUT = checkIfPatternExists(text, pattern)
    expect(SUT).toBe(undefined)
  })
  it('expects to throw an error message when given input is not a string', () => {
    const text = 123444456
    const pattern = 123
    expect(() => checkIfPatternExists(text, pattern)).toThrow(
      'Given input is not a string'
    )
  })
})

--#

--% C:/work/algos/Javascript/String/test/PermutateString.test.js
import { permutate } from '../PermutateString'

describe('Permutate a string', () => {
  it('expects to throw an Error with an empty string', () => {
    expect(() => { permutate() }).toThrow('The arg must be a valid, non empty string')
  })
  it('expects to permute "no" into [no, on]', () => {
    expect(['no', 'on']).toEqual(permutate('no'))
  })
  it('expects to permute "yes" into [esy, eys, sey, sye, yes, yse]', () => {
    expect(['esy', 'eys', 'sey', 'sye', 'yes', 'yse']).toEqual(permutate('yes'))
  })
  it('expects to permute "good" into [dgoo dogo doog gdoo godo good odgo odog ogdo ogod oodg oogd ]', () => {
    expect(['dgoo', 'dogo', 'doog', 'gdoo', 'godo', 'good', 'odgo', 'odog', 'ogdo', 'ogod', 'oodg', 'oogd'])
      .toEqual(permutate('good'))
  })
})

--#

--% C:/work/algos/Javascript/String/test/ReverseString.test.js
import { ReverseStringIterative, ReverseStringIterativeInplace } from '../ReverseString'

describe('ReverseStringIterative', () => {
  it('expects to reverse a simple string', () => {
    expect(ReverseStringIterative('reverse')).toEqual('esrever')
    expect(ReverseStringIterative('some')).toEqual('emos')
    expect(ReverseStringIterative('string')).toEqual('gnirts')
    expect(ReverseStringIterative('The Algorithms Javascript')).toEqual('tpircsavaJ smhtiroglA ehT')
  })

  it('expects to reverse a string with spaces in between', () => {
    expect(ReverseStringIterative('reverse me')).toEqual('em esrever')
  })

  it('expects to reverse a simple string without capitalizing the first letter', () => {
    expect(ReverseStringIterative('Javascript')).toEqual('tpircsavaJ')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => ReverseStringIterative(input)).toThrow('The given value is not a string')
    }
  )

  it('expects to return a empty string with an empty string is given', () => {
    expect(ReverseStringIterative('')).toEqual('')
  })
})

describe('ReverseStringIterativeInplace', () => {
  it('expects to reverse a simple string', () => {
    expect(ReverseStringIterativeInplace('reverse')).toEqual('esrever')
    expect(ReverseStringIterativeInplace('some')).toEqual('emos')
    expect(ReverseStringIterativeInplace('string')).toEqual('gnirts')
    expect(ReverseStringIterativeInplace('The Algorithms Javascript')).toEqual('tpircsavaJ smhtiroglA ehT')
  })

  it('expects to reverse a simple string without capitalizing the first letter', () => {
    expect(ReverseStringIterativeInplace('Javascript')).toEqual('tpircsavaJ')
  })

  it('expects to return an empty string given an empty string', () => {
    expect(ReverseStringIterativeInplace('Javascript')).toEqual('tpircsavaJ')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => ReverseStringIterativeInplace(input)).toThrow('The given value is not a string')
    }
  )
})

--#

--% C:/work/algos/Javascript/String/test/ReverseWords.test.js
import { reverseWords } from '../ReverseWords'

describe('reverseWords', () => {
  it('expects to reverse words to return a joined word', () => {
    expect(reverseWords('I Love JS')).toBe('JS Love I')
    expect(reverseWords('Hello World')).toBe('World Hello')
    expect(reverseWords('The Algorithms Javascript')).toBe('Javascript Algorithms The')
  })

  it.each`
    input
    ${123456}
    ${[1, 2, 3, 4, 5, 6]}
    ${{ test: 'test' }}
    ${null}
  `(
    'expects to throw a type error given a value that is $input',
    ({ input }) => {
      expect(() => {
        reverseWords(input)
      }).toThrow('The given value is not a string')
    }
  )
})

--#

--% C:/work/algos/Javascript/String/test/ScrambleStrings.test.js
import { isScramble } from '../ScrambleStrings'

describe('ScrambleStrings', () => {
  it('expects to return true for same string', () => {
    expect(isScramble('a', 'a')).toBe(true)
  })

  it('expects to return false for non-scrambled strings', () => {
    expect(isScramble('abcde', 'caebd')).toBe(false)
  })

  it('expects to return true for scrambled strings', () => {
    expect(isScramble('great', 'rgeat')).toBe(true)
  })
})

--#

--% C:/work/algos/Javascript/String/test/Upper.test.js
import { upper } from '../Upper'

describe('Upper', () => {
  it('return uppercase strings', () => {
    expect(upper('hello')).toBe('HELLO')
    expect(upper('WORLD')).toBe('WORLD')
    expect(upper('hello_WORLD')).toBe('HELLO_WORLD')
  })
})

--#

--% C:/work/algos/Javascript/String/test/ValidateCreditCard.test.js
import { validateCreditCard } from '../ValidateCreditCard'

describe('Validate credit card number', () => {
  it('should throw error if card number is boolean', () => {
    const invalidCC = true
    expect(() => validateCreditCard(invalidCC)).toThrow(
      'The given value is not a string'
    )
  })
  it('returns true if the credit card number is valid', () => {
    const validCreditCard = '4111111111111111'
    const validationResult = validateCreditCard(validCreditCard)
    expect(validationResult).toBe(true)
  })
  it('should throw an error on non-numeric character in given credit card number', () => {
    const nonNumericCCNumbers = ['123ABCDEF', 'ABCDKDKD', 'ADS232']
    nonNumericCCNumbers.forEach(nonNumericCC => expect(() => validateCreditCard(nonNumericCC)).toThrow(
      `${nonNumericCC} is an invalid credit card number because ` + 'it has nonnumerical characters.'
    ))
  })
  it('should throw an error on credit card with invalid length', () => {
    const ccWithInvalidLength = ['41111', '4111111111111111111111']
    ccWithInvalidLength.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'of its length.'
    ))
  })
  it('should throw an error on credit card with invalid start substring', () => {
    const ccWithInvalidStartSubstring = ['12345678912345', '23456789123456', '789123456789123', '891234567891234', '912345678912345', '31345678912345', '32345678912345', '33345678912345', '38345678912345']
    ccWithInvalidStartSubstring.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'of its first two digits.'
    ))
  })
  it('should throw an error on credit card with luhn check fail', () => {
    const invalidCCs = ['411111111111111', '371211111111111', '49999999999999']
    invalidCCs.forEach(invalidCC => expect(() => validateCreditCard(invalidCC)).toThrow(
      `${invalidCC} is an invalid credit card number because ` + 'it fails the Luhn check.'
    ))
  })
})

--#

--% C:/work/algos/Javascript/String/test/ValidateEmail.test.js
import { validateEmail } from '../ValidateEmail'

describe('Validation of an Email Address', () => {
  it('expects to return false', () => {
    expect(validateEmail('mahfoudh.arous.com')).toEqual(false)
  })

  it('expects to return false', () => {
    expect(validateEmail('mahfoudh.arous@com')).toEqual(false)
  })

  it('expects to return true', () => {
    expect(validateEmail('mahfoudh.arous@gmail.com')).toEqual(true)
  })

  it('expects to return true', () => {
    expect(validateEmail('icristianbaciu@.helsinki.edu')).toEqual(true)
  })

  it('expects to throw a type error', () => {
    expect(() => { validateEmail('') }).toThrow('Email Address String Null or Empty.')
    expect(() => { validateEmail(null) }).toThrow('Email Address String Null or Empty.')
  })
})

--#

--% C:/work/algos/Javascript/String/test/ValidateUrl.test.js
import { validateURL } from '../ValidateUrl'

describe('ValidateUrl', () => {
  it('expects to return false', () => {
    expect(validateURL('google')).toEqual(false)
    expect(validateURL('link: https://www.google.com')).toEqual(false)
  })

  it('expects to return true', () => {
    expect(validateURL('http://www.google.com')).toEqual(true)
    expect(validateURL('https://www.google.com')).toEqual(true)
    expect(validateURL('www.google.com')).toEqual(true)
  })
})

--#

--% C:/work/algos/Javascript/Timing-Functions/GetMonthDays.js
/**
  function that takes month number and its year and returns the number of days within it
  * @param monthNumber.
  * @param year.
  e.g.: mahfoudh.arous@gmail.com -> true
  e.g.: mahfoudh.arous.com ->false
*/

const getMonthDays = (monthNumber, year) => {
  const the31DaysMonths = [1, 3, 5, 7, 8, 10, 12]
  const the30DaysMonths = [4, 6, 9, 11]

  if (!the31DaysMonths.includes(monthNumber) && !the30DaysMonths.includes(monthNumber) &&
    (monthNumber !== 2)
  ) {
    throw new TypeError('Invalid Month Number.')
  }

  if (the31DaysMonths.includes(monthNumber)) { return 31 }

  if (the30DaysMonths.includes(monthNumber)) { return 30 }

  // Check for Leap year
  if (year % 4 === 0) {
    if ((year % 100 !== 0) || (year % 100 === 0 && year % 400 === 0)) {
      return 29
    }
  }

  return 28
}

export { getMonthDays }

--#

--% C:/work/algos/Javascript/Timing-Functions/IntervalTimer.js
/**
 * @author Nandan V
 * Sunday, 26 July 2020 8:33 AM
 * @description Singleton class that handles the <b>timing of tests</b> and
 *   specs. <br/> The class is singleton as <u>javascript does not support
 *   multiple timer instances<u/>.
 */
class IntervalTimer {
  /**
   * @description Constructor for Timer.
   * @param interval Sets the interval for running the timer.
   * @param callBack The callback function to be executed.
   * @return {IntervalTimer} If exists, the existing object.
   */
  constructor (interval = 10,
    callBack = () => {}) {
    this.prevInterval = 0
    if (this.instance == null) {
      this.interval = interval
      this.callBack = callBack
      this.instance = this
    } else {
      return this.instance
    }
  }

  /**
   * @description Starts the timer.
   */
  startTimer () {
    this.timer = setInterval(this.callBack, this.interval)
  }

  /**
   * @description Resets the timer.
   * @return {number} Elapsed time in milliseconds.
   */
  resetTimer () {
    clearInterval(this.timer)
    this.callBack = () => {}
    return this.getElapsedTime()
  }

  /**
   * @return {number} Elapsed time in milliseconds since reset.
   */
  getElapsedTime (offset = 0) {
    this.timeElapsed = this.timer - this.prevInterval
    this.prevInterval = this.timer
    return this.timeElapsed - offset
  }

  /**
   * @return {number} Elapsed time since start.
   */
  getRunTime () {
    return this.timer
  }
}

/**
 * @author Nandan V
 * Saturday, 01 August 2020 8:33 AM
 * @description Example usage
 */
const ExampleIntervalTimer = function (output = v => console.log(v)) {
  /**
   * Create am object with default settings.
   * @type {IntervalTimer} Used to get timing information.
   */
  const timer = new IntervalTimer()
  timer.startTimer()

  // ... Initialization code ...
  // I generally use it for timing tests in Jasmine JS.

  /**
   * Gets the runtime till this point.
   * Can be subtracted from ElapsedTime to offset timing of initialization code.
   */
  const initOffset = timer.getRunTime()

  // ... A test ...
  // The time taken to run the test.
  output(timer.getElapsedTime(initOffset))

  /**
   * Returns the elapsed time and resets the timer to 0.
   */
  output(timer.resetTimer())
}

export { IntervalTimer, ExampleIntervalTimer }

--#

--% C:/work/algos/Javascript/Timing-Functions/test/GetMonthDays.test.js
import { getMonthDays } from '../GetMonthDays'

describe('Get the Days of a Month', () => {
  it('expects to return 28', () => {
    expect(getMonthDays(2, 2018)).toEqual(28)
  })

  it('expects to return 30', () => {
    expect(getMonthDays(6, 254)).toEqual(30)
  })

  it('expects to return 29', () => {
    expect(getMonthDays(2, 2024)).toEqual(29)
  })

  it('expects to throw a type error', () => {
    expect(() => { getMonthDays(13, 2020) }).toThrow('Invalid Month Number.')
  })
})

--#

--% C:/work/algos/Javascript/Trees/BreadthFirstTreeTraversal.js
/*
  Breadth First Tree Traversal or level order traversal implementation in javascript
  Author: @GerardUbuntu
*/

class Node {
  constructor (data) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinaryTree {
  constructor () {
    this.root = null
    this.traversal = []
  }

  breadthFirst () {
    const h = this.getHeight(this.root)
    for (let i = 0; i !== h; i++) {
      this.traverseLevel(this.root, i)
    }
    return this.traversal
  }

  // Computing the height of the tree
  getHeight (node) {
    if (node === null) {
      return 0
    }
    const lheight = this.getHeight(node.left)
    const rheight = this.getHeight(node.right)
    return lheight > rheight ? lheight + 1 : rheight + 1
  }

  traverseLevel (node, levelRemaining) {
    if (node === null) {
      return
    }
    if (levelRemaining === 0) {
      this.traversal.push(node.data)
    } else {
      this.traverseLevel(node.left, levelRemaining - 1)
      this.traverseLevel(node.right, levelRemaining - 1)
    }
  }
}

export { BinaryTree, Node }

--#

--% C:/work/algos/Javascript/Trees/DepthFirstSearch.js
/*
 * Author: Surendra Kumar
 * DFS Algorithm implementation in JavaScript
 * DFS Algorithm for traversing or searching graph data structures.
*/

function traverseDFS (root) {
  const stack = [root]
  const res = []

  while (stack.length) {
    const curr = stack.pop()
    res.push(curr.key)

    if (curr.right) {
      stack.push(curr.right)
    }

    if (curr.left) {
      stack.push(curr.left)
    }
  }

  return res.reverse()
}

function searchDFS (tree, value) {
  const stack = []

  stack.push(tree[0])

  while (stack.length !== 0) {
    for (let i = 0; i < stack.length; i++) {
      const node = stack.pop()

      if (node.value === value) {
        return node
      }
      if (node.right) {
        stack.push(tree[node.right])
      }
      if (node.left) {
        stack.push(tree[node.left])
      }
    }
  }
  return null
}

const tree = [
  { value: 6, left: 1, right: 2 },
  { value: 5, left: 3, right: 4 },
  { value: 7, left: null, right: 5 },
  { value: 3, left: 6, right: null },
  { value: 4, left: null, right: null },
  { value: 9, left: 7, right: 8 },
  { value: 2, left: 9, right: null },
  { value: 8, left: null, right: null },
  { value: 10, left: null, right: null },
  { value: 1, left: null, right: null }
]

searchDFS(tree, 9)
searchDFS(tree, 10)

traverseDFS(6)

//            6
//           / \
//          5   7
//         / \   \
//        3   4   9
//       /       / \
//      2       8   10
//     /
//    1

--#

--% C:/work/algos/Javascript/Trees/FenwickTree.js
/*
 * Author: Mohit Kumar
 * Fedwick Tree Implementation in JavaScript
 * Fedwick Tree Implementation for finding prefix sum.
*/

class FenwickTree {
  constructor (feneickArray, array, n) {
    for (let i = 1; i <= n; i++) {
      feneickArray[i] = 0
    }
    for (let i = 0; i < n; i++) {
      this.update(feneickArray, n, i, array[i])
    }
  }

  update (feneickArray, n, index, value) {
    index = index + 1
    while (index <= n) {
      feneickArray[index] += value
      index += index & (-index)
    }
  }

  getPrefixSum (feneickArray, index) {
    let currSum = 0
    index = index + 1
    while (index > 0) {
      currSum += feneickArray[index]
      index -= index & (-index)
    }

    return currSum
  }
}
export { FenwickTree }

--#

--% C:/work/algos/Javascript/Trees/test/BreadthFirstTreeTraversal.test.js
import { BinaryTree, Node } from '../BreadthFirstTreeTraversal'

describe('Breadth First Tree Traversal', () => {
  const binaryTree = new BinaryTree()

  const root = new Node(7)
  root.left = new Node(5)
  root.right = new Node(8)
  root.left.left = new Node(3)
  root.left.right = new Node(6)
  root.right.right = new Node(9)
  binaryTree.root = root

  // Visualization :
  //
  //            7
  //           / \
  //          5   8
  //         / \   \
  //        3   6   9

  it('Binary tree - Level order traversal', () => {
    expect(binaryTree.traversal).toStrictEqual([])
    const traversal = binaryTree.breadthFirst()
    expect(traversal).toStrictEqual([7, 5, 8, 3, 6, 9])
  })
})

--#

--% C:/work/algos/Javascript/Trees/test/FenwickTree.test.js
import { FenwickTree } from '../FenwickTree'

describe('Fenwick Tree Implementation', () => {
  const fenwickArray = new Array(1000)
  const array = [3, 2, 0, 6, 5, -1, 2]
  const length = array.length

  const fenwickTree = new FenwickTree(fenwickArray, array, length)

  it('Fenwick Tree - Prefix sum of array', () => {
    const prefixSum = fenwickTree.getPrefixSum(fenwickArray, 6)
    expect(prefixSum).toBe(23)
  })

  array[2] += 6
  fenwickTree.update(fenwickArray, length, 2, 6)

  it('Fenwick Tree - Prefix sum of Updated array', () => {
    const prefixSum = fenwickTree.getPrefixSum(fenwickArray, 6)
    expect(prefixSum).toBe(23)
  })
})

--#

