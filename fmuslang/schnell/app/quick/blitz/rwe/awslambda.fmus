--% index/fmus
__PWD,d
  .,d(/load=__FILE__=index/fmus/under_pwd*)
--#

--% index/fmus/under_pwd
__REPLACE_WITH_PROJECT_DIR_OR_INPUT__,d(/mk)
	%utama=__FILE__
	.gitignore,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/.gitignore)
	.gitmodules,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/.gitmodules)
	.travis.yml,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/.travis.yml)
	go.mod,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/go.mod)
	go.sum,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/go.sum)
	gobuild.sh,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/gobuild.sh)
	gomod.sh,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/gomod.sh)
	logo.png,f(b64=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/logo.png)
	Makefile,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/Makefile)
	readme.md,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/readme.md)
	serverless.yml,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/serverless.yml)
	angularjs-realworld-example-app,d(/mk)
	model,d(/mk)
		Article.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/Article.go)
		ArticlePriorityQueue.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/ArticlePriorityQueue.go)
		Article_test.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/Article_test.go)
		Auth.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/Auth.go)
		Comment.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/Comment.go)
		InputError.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/InputError.go)
		User.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/User.go)
	route,d(/mk)
		articles-feed-get,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-feed-get/main.go)
		articles-get,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-get/main.go)
		articles-post,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-post/main.go)
		articles-slug-delete,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-slug-delete/main.go)
		articles-slug-get,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-slug-get/main.go)
		articles-slug-put,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-slug-put/main.go)
		comments-delete,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/comments-delete/main.go)
		comments-get,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/comments-get/main.go)
		comments-post,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/comments-post/main.go)
		favorite-delete,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/favorite-delete/main.go)
		favorite-post,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/favorite-post/main.go)
		profiles-follow-delete,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/profiles-follow-delete/main.go)
		profiles-follow-post,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/profiles-follow-post/main.go)
		profiles-get,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/profiles-get/main.go)
		tags-get,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/tags-get/main.go)
		user-get,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/user-get/main.go)
		user-put,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/user-put/main.go)
		users-login-post,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/users-login-post/main.go)
		users-post,d(/mk)
			main.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/users-post/main.go)
	service,d(/mk)
		ArticleService.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/ArticleService.go)
		ArticleTagService.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/ArticleTagService.go)
		CommentService.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/CommentService.go)
		CommonDBOperation.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/CommonDBOperation.go)
		DynamoDBClient.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/DynamoDBClient.go)
		FavoriteArticleService.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/FavoriteArticleService.go)
		FollowService.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/FollowService.go)
		Rand.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/Rand.go)
		TableName.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/TableName.go)
		TagService.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/TagService.go)
		UserService.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/UserService.go)
		Util.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/Util.go)
		Util_test.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/Util_test.go)
	util,d(/mk)
		ErrorResponse.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/util/ErrorResponse.go)
		Math.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/util/Math.go)
		StringSet.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/util/StringSet.go)
		SuccessResponse.go,f(e=utama=E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/util/SuccessResponse.go)
--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/.gitignore
# Serverless directories
.serverless

# golang output binary directory
bin

# golang vendor (dependencies) directory
vendor

# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, build with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Custom
/.idea/

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/.gitmodules
[submodule "angularjs-realworld-example-app"]
	path = angularjs-realworld-example-app
	url = https://github.com/chrisxue815/angularjs-realworld-example-app.git

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/.travis.yml
language: go

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/go.mod
module github.com/chrisxue815/realworld-aws-lambda-dynamodb-go

go 1.14

require (
	github.com/aws/aws-lambda-go v1.6.0
	github.com/aws/aws-sdk-go v1.23.15
	github.com/dgrijalva/jwt-go v3.2.0+incompatible
	github.com/gosimple/slug v1.7.0
	github.com/rainycape/unidecode v0.0.0-20150907023854-cb7f23ec59be // indirect
	github.com/stretchr/testify v1.5.1
	golang.org/x/crypto v0.0.0-20190829043050-9756ffdc2472
)

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/go.sum
github.com/aws/aws-lambda-go v1.6.0 h1:T+u/g79zPKw1oJM7xYhvpq7i4Sjc0iVsXZUaqRVVSOg=
github.com/aws/aws-lambda-go v1.6.0/go.mod h1:zUsUQhAUjYzR8AuduJPCfhBuKWUaDbQiPOG+ouzmE1A=
github.com/aws/aws-sdk-go v1.23.15 h1:ut2ZzO0A34Ds18NXvvkWWKyO4aZqQ9uZquslWzCQvGU=
github.com/aws/aws-sdk-go v1.23.15/go.mod h1:KmX6BPdI08NWTb3/sm4ZGu5ShLoqVDhKgpiN924inxo=
github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=
github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
github.com/gosimple/slug v1.7.0 h1:BlCZq+BMGn+riOZuRKnm60Fe7+jX9ck6TzzkN1r8TW8=
github.com/gosimple/slug v1.7.0/go.mod h1:ER78kgg1Mv0NQGlXiDe57DpCyfbNywXXZ9mIorhxAf0=
github.com/jmespath/go-jmespath v0.0.0-20180206201540-c2b33e8439af h1:pmfjZENx5imkbgOkpRUYLnmbU7UEFbjtDA2hxJ1ichM=
github.com/jmespath/go-jmespath v0.0.0-20180206201540-c2b33e8439af/go.mod h1:Nht3zPeWKUH0NzdCt2Blrr5ys8VGpn0CEB0cQHVjt7k=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/rainycape/unidecode v0.0.0-20150907023854-cb7f23ec59be h1:ta7tUOvsPHVHGom5hKW5VXNc2xZIkfCKP8iaqOyYtUQ=
github.com/rainycape/unidecode v0.0.0-20150907023854-cb7f23ec59be/go.mod h1:MIDFMn7db1kT65GmV94GzpX9Qdi7N/pQlwb+AN8wh+Q=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/testify v1.5.1 h1:nOGnQDM7FYENwehXlg/kFVnos3rEvtKTjRvOWSzb6H4=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20190829043050-9756ffdc2472 h1:Gv7RPwsi3eZ2Fgewe3CBsuOebPwO27PoXzRpJPsvSSM=
golang.org/x/crypto v0.0.0-20190829043050-9756ffdc2472/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/gobuild.sh
#!/bin/bash
for r in route/*; do
    if [ -d "$r" ]; then
        r=$(basename "$r")
        env GO111MODULE=on GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o bin/$r route/$r/main.go
    fi
done

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/gomod.sh
#!/bin/bash
set -eu

touch go.mod

PROJECT_NAME=$(basename $(pwd | xargs dirname))
CURRENT_DIR=$(basename $(pwd))

CONTENT=$(cat <<-EOD
module github.com/${PROJECT_NAME}/${CURRENT_DIR}

require github.com/aws/aws-lambda-go v1.6.0
EOD
)

echo "$CONTENT" > go.mod

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/logo.png
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
--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/Makefile
.PHONY: build clean deploy gomodgen

build: gomodgen
	./gobuild.sh

clean:
	rm -rf ./bin ./vendor Gopkg.lock

deploy: clean build
	sls deploy --verbose

gomodgen:
	chmod u+x gomod.sh
	./gomod.sh

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/readme.md
# ![RealWorld Example App](logo.png)

> ### AWS Lambda + DynamoDB + Go codebase containing real world examples (CRUD, auth, advanced patterns, etc) that adheres to the [RealWorld](https://github.com/gothinkster/realworld) spec and API.

### [Demo](https://chrisxue815.github.io/realworld/build/#/)

[![Build Status](https://travis-ci.org/chrisxue815/realworld-aws-lambda-dynamodb-go.svg?branch=master)](https://travis-ci.org/chrisxue815/realworld-aws-lambda-dynamodb-go)

This codebase was created to demonstrate a fully fledged fullstack application built with **AWS Lambda + DynamoDB + Go** including CRUD operations, authentication, routing, pagination, and more.

We've gone to great lengths to adhere to the **AWS Lambda + DynamoDB + Go** community styleguides & best practices.

For more information on how to this works with other frontends/backends, head over to the [RealWorld](https://github.com/gothinkster/realworld) repo.

# Getting started

## Prerequisite

* Install Go, Node.js, Serverless CLI, AWS CLI
* In `angularjs-realworld-example-app`, run `npm install`

## Build and deploy backend

In the root directory of this project:

* `make build`
* `sls deploy --stage dev`

## Build and serve frontend

In `angularjs-realworld-example-app`:

* `npx gulp`

# How it works

Routes and their handlers are defined in `serverless.yml`.

For example, the following section means `POST /users` is handled by `bin/users-post`, which is built from `route/users-post/main.go`.

```
  users-post:
    handler: bin/users-post
    events:
      - http:
          path: users
          method: post
          cors: true
```

# Design choices
* Scrypt-based password hashing
* Input validation
* Data consistency with DynamoDB transactions

These tradeoffs were made for simpler code:
* Hardcoded Scrypt secret. Downside: tokens can't be invalidated
* Shared states (like DB and RNG) are singletons, no dependency injections used. Downside: lifecycles of shared states are not controllable. Potential memory leak. Unit-test-unfriendly
* Usernames are not changeable
* Usernames are case-sensitive
* Performance bottleneck in global secondary indices with a single hash-key value, like ArticleTable.CreatedAt and TagTable.ArticleCount
* Performance bottleneck in fan-in-based article feed aggregation

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/serverless.yml
service: realworld

frameworkVersion: '>=1.28.0 <2.0.0'

provider:
  name: aws
  runtime: go1.x
  stage: ${opt:stage, "dev"}
  region: ${opt:region, "eu-west-1"}
  environment:
    STAGE: ${self:provider.stage}
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:BatchGetItem
        - dynamodb:DeleteItem
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:Query
        - dynamodb:UpdateItem
      Resource: "arn:aws:dynamodb:${self:provider.region}:*:table/*"

package:
  exclude:
    - ./**
  include:
    - ./bin/**

functions:

  users-post:
    handler: bin/users-post
    events:
      - http:
          path: users
          method: post
          cors: true

  users-login-post:
    handler: bin/users-login-post
    events:
      - http:
          path: users/login
          method: post
          cors: true

  user-get:
    handler: bin/user-get
    events:
      - http:
          path: user
          method: get
          cors: true

  user-put:
    handler: bin/user-put
    events:
      - http:
          path: user
          method: put
          cors: true

  profiles-get:
    handler: bin/profiles-get
    events:
      - http:
          path: profiles/{username}
          method: get
          cors: true
          request:
            parameters:
              paths:
                username: true

  profiles-follow-post:
    handler: bin/profiles-follow-post
    events:
      - http:
          path: profiles/{username}/follow
          method: post
          cors: true
          request:
            parameters:
              paths:
                username: true

  profiles-follow-delete:
    handler: bin/profiles-follow-delete
    events:
      - http:
          path: profiles/{username}/follow
          method: delete
          cors: true
          request:
            parameters:
              paths:
                username: true

  articles-post:
    handler: bin/articles-post
    events:
      - http:
          path: articles
          method: post
          cors: true

  articles-get:
    handler: bin/articles-get
    events:
      - http:
          path: articles
          method: get
          cors: true

  articles-feed-get:
    handler: bin/articles-feed-get
    events:
      - http:
          path: articles/feed
          method: get
          cors: true

  articles-slug-get:
    handler: bin/articles-slug-get
    events:
      - http:
          path: articles/{slug}
          method: get
          cors: true
          request:
            parameters:
              paths:
                slug: true

  articles-slug-put:
    handler: bin/articles-slug-put
    events:
      - http:
          path: articles/{slug}
          method: put
          cors: true
          request:
            parameters:
              paths:
                slug: true

  articles-slug-delete:
    handler: bin/articles-slug-delete
    events:
      - http:
          path: articles/{slug}
          method: delete
          cors: true
          request:
            parameters:
              paths:
                slug: true

  comments-post:
    handler: bin/comments-post
    events:
      - http:
          path: articles/{slug}/comments
          method: post
          cors: true
          request:
            parameters:
              paths:
                slug: true

  comments-get:
    handler: bin/comments-get
    events:
      - http:
          path: articles/{slug}/comments
          method: get
          cors: true
          request:
            parameters:
              paths:
                slug: true

  comments-delete:
    handler: bin/comments-delete
    events:
      - http:
          path: articles/{slug}/comments/{id}
          method: delete
          cors: true
          request:
            parameters:
              paths:
                slug: true
                id: true

  favorite-post:
    handler: bin/favorite-post
    events:
      - http:
          path: articles/{slug}/favorite
          method: post
          cors: true
          request:
            parameters:
              paths:
                slug: true

  favorite-delete:
    handler: bin/favorite-delete
    events:
      - http:
          path: articles/{slug}/favorite
          method: delete
          cors: true
          request:
            parameters:
              paths:
                slug: true

  tags-get:
    handler: bin/tags-get
    events:
      - http:
          path: tags
          method: get
          cors: true

resources:
  Resources:
    UserTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: realworld-${self:provider.stage}-user
        AttributeDefinitions:
          - AttributeName: Username
            AttributeType: S
        KeySchema:  # GET /user, GET /profiles/:username
          - AttributeName: Username
            KeyType: HASH
        BillingMode: PROVISIONED
        ProvisionedThroughput:
          ReadCapacityUnits: 2
          WriteCapacityUnits: 2

    EmailUserTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: realworld-${self:provider.stage}-email-user
        AttributeDefinitions:
          - AttributeName: Email
            AttributeType: S
        KeySchema:  # POST /users/login
          - AttributeName: Email
            KeyType: HASH
        BillingMode: PROVISIONED
        ProvisionedThroughput:
          ReadCapacityUnits: 2
          WriteCapacityUnits: 2

    FollowTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: realworld-${self:provider.stage}-follow
        AttributeDefinitions:
          - AttributeName: Follower
            AttributeType: S
          - AttributeName: Publisher
            AttributeType: S
        KeySchema:  # GET /articles/feed
          - AttributeName: Follower
            KeyType: HASH
          - AttributeName: Publisher
            KeyType: RANGE
        BillingMode: PROVISIONED
        ProvisionedThroughput:
          ReadCapacityUnits: 2
          WriteCapacityUnits: 2

    ArticleTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: realworld-${self:provider.stage}-article
        AttributeDefinitions:
          - AttributeName: ArticleId
            AttributeType: N
          - AttributeName: CreatedAt
            AttributeType: N
          - AttributeName: Dummy
            AttributeType: N
          - AttributeName: Author
            AttributeType: S
        KeySchema:  # GET /articles/:slug
          - AttributeName: ArticleId
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: CreatedAt
            KeySchema:  # GET /articles
              - AttributeName: Dummy
                KeyType: HASH
              - AttributeName: CreatedAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
            ProvisionedThroughput:
              ReadCapacityUnits: 2
              WriteCapacityUnits: 2
          - IndexName: Author
            KeySchema:  # GET /articles?author=:author
              - AttributeName: Author
                KeyType: HASH
              - AttributeName: CreatedAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
            ProvisionedThroughput:
              ReadCapacityUnits: 2
              WriteCapacityUnits: 2
        BillingMode: PROVISIONED
        ProvisionedThroughput:
          ReadCapacityUnits: 2
          WriteCapacityUnits: 2

    ArticleTagTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: realworld-${self:provider.stage}-article-tag
        AttributeDefinitions:
          - AttributeName: Tag
            AttributeType: S
          - AttributeName: ArticleId
            AttributeType: N
          - AttributeName: CreatedAt
            AttributeType: N
        KeySchema:  # POST /articles, PUT /articles
          - AttributeName: Tag
            KeyType: HASH
          - AttributeName: ArticleId
            KeyType: RANGE
        LocalSecondaryIndexes:
          - IndexName: CreatedAt
            KeySchema:  # GET /articles?tag=:tag
              - AttributeName: Tag
                KeyType: HASH
              - AttributeName: CreatedAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
        BillingMode: PROVISIONED
        ProvisionedThroughput:
          ReadCapacityUnits: 2
          WriteCapacityUnits: 2

    TagTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: realworld-${self:provider.stage}-tag
        AttributeDefinitions:
          - AttributeName: Tag
            AttributeType: S
          - AttributeName: ArticleCount
            AttributeType: N
          - AttributeName: Dummy
            AttributeType: N
        KeySchema:
          - AttributeName: Tag
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: ArticleCount
            KeySchema:  # GET /tags
              - AttributeName: Dummy
                KeyType: HASH
              - AttributeName: ArticleCount
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
            ProvisionedThroughput:
              ReadCapacityUnits: 2
              WriteCapacityUnits: 2
        BillingMode: PROVISIONED
        ProvisionedThroughput:
          ReadCapacityUnits: 2
          WriteCapacityUnits: 2

    FavoriteArticleTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: realworld-${self:provider.stage}-favorite-article
        AttributeDefinitions:
          - AttributeName: Username
            AttributeType: S
          - AttributeName: ArticleId
            AttributeType: N
          - AttributeName: FavoritedAt
            AttributeType: N
        KeySchema:  # POST /articles/:slug/favorite
          - AttributeName: Username
            KeyType: HASH
          - AttributeName: ArticleId
            KeyType: RANGE
        LocalSecondaryIndexes:
          - IndexName: FavoritedAt
            KeySchema:  # GET /articles?favorited=:favorited
              - AttributeName: Username
                KeyType: HASH
              - AttributeName: FavoritedAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
        BillingMode: PROVISIONED
        ProvisionedThroughput:
          ReadCapacityUnits: 2
          WriteCapacityUnits: 2

    CommentTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: realworld-${self:provider.stage}-comment
        AttributeDefinitions:
          - AttributeName: ArticleId
            AttributeType: N
          - AttributeName: CommentId
            AttributeType: N
          - AttributeName: CreatedAt
            AttributeType: N
        KeySchema:  # POST /articles/:slug/comments
          - AttributeName: ArticleId
            KeyType: HASH
          - AttributeName: CommentId
            KeyType: RANGE
        LocalSecondaryIndexes:
          - IndexName: CreatedAt
            KeySchema:  # GET /articles/:slug/comments
              - AttributeName: ArticleId
                KeyType: HASH
              - AttributeName: CreatedAt
                KeyType: RANGE
            Projection:
              ProjectionType: ALL
        BillingMode: PROVISIONED
        ProvisionedThroughput:
          ReadCapacityUnits: 2
          WriteCapacityUnits: 2

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/Article.go
package model

import (
	"fmt"
	"github.com/gosimple/slug"
	"strconv"
	"strings"
)

const TimestampFormat = "2006-01-02T15:04:05.000Z"
const MaxArticleId = 0x1000000 // exclusive
const MaxNumTagsPerArticle = 5

type Article struct {
	ArticleId      int64
	Slug           string
	Title          string
	Description    string
	Body           string
	TagList        []string
	CreatedAt      int64
	UpdatedAt      int64
	FavoritesCount int64
	Author         string
	Dummy          byte // Always 0, used for sorting articles by index CreatedAt
}

type ArticleTag struct {
	Tag       string
	ArticleId int64
	CreatedAt int64
}

type Tag struct {
	Tag          string
	ArticleCount int64
	Dummy        byte // Always 0, used for sorting articles by index ArticleCount
}

type FavoriteArticleKey struct {
	Username  string
	ArticleId int64
}

type FavoriteArticle struct {
	FavoriteArticleKey
	FavoritedAt int64
}

func (article *Article) Validate() error {
	if article.Title == "" {
		return NewInputError("title", "can't be blank")
	}

	if article.Description == "" {
		return NewInputError("description", "can't be blank")
	}

	if article.Body == "" {
		return NewInputError("body", "can't be blank")
	}

	if article.TagList == nil {
		article.TagList = make([]string, 0)
	} else if len(article.TagList) > MaxNumTagsPerArticle {
		return NewInputError("tagList", fmt.Sprintf("cannot add more than %d tags per article", MaxNumTagsPerArticle))
	}

	return nil
}

func (article *Article) MakeSlug() {
	slugPrefix := slug.Make(article.Title)
	article.Slug = slugPrefix + "-" + strconv.FormatInt(article.ArticleId, 16)
}

func SlugToArticleId(slug string) (int64, error) {
	dashIndex := strings.LastIndexByte(slug, '-')

	articleId, err := strconv.ParseInt(slug[dashIndex+1:], 16, 64)
	if err != nil {
		return 0, NewInputError("slug", "invalid")
	}

	return articleId, nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/ArticlePriorityQueue.go
package model

import "container/heap"

type ArticlePriorityQueue [][]Article

func (pq ArticlePriorityQueue) Len() int { return len(pq) }

func (pq ArticlePriorityQueue) Less(i, j int) bool {
	// Pop empty lists first, to reduce computation complexity
	if len(pq[i]) == 0 {
		return true
	}
	if len(pq[j]) == 0 {
		return false
	}
	// We want Pop to give us the latest, not earliest, article so we use greater than here.
	return pq[i][0].CreatedAt > pq[j][0].CreatedAt
}

func (pq ArticlePriorityQueue) Swap(i, j int) {
	pq[i], pq[j] = pq[j], pq[i]
}

func (pq *ArticlePriorityQueue) Push(x interface{}) {
	item := x.([]Article)
	*pq = append(*pq, item)
}

func (pq *ArticlePriorityQueue) Pop() interface{} {
	old := *pq
	n := len(old)
	item := old[n-1]
	old[n-1] = nil // avoid memory leak
	*pq = old[0 : n-1]
	return item
}

func MergeArticles(pq ArticlePriorityQueue, offset, limit int) []Article {
	merged := make([]Article, 0, limit)
	heap.Init(&pq)
	numVisitedArticles := 0

	for len(pq) > 0 && numVisitedArticles < offset+limit {
		list := pq[0]

		if len(list) == 0 {
			heap.Pop(&pq)
		} else {
			if numVisitedArticles >= offset {
				article := list[0]
				merged = append(merged, article)
			}
			pq[0] = list[1:]
			heap.Fix(&pq, 0)
			numVisitedArticles++
		}
	}

	return merged
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/Article_test.go
package model

import (
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestSlugToArticleId(t *testing.T) {
	testCases := []struct {
		slug          string
		expected      int64
		expectedError bool
	}{
		{"how-to-train-your-dragon-74728a", 0x74728a, false},
		{"74728a", 0x74728a, false},
	}

	for _, testCase := range testCases {
		actual, err := SlugToArticleId("how-to-train-your-dragon-74728a")
		assert.Equal(t, testCase.expected, actual, "%+v", testCase)
		assert.Equal(t, testCase.expectedError, err != nil, "%+v", testCase)
	}
}

func PassArticleByValue(article Article, goPanic bool) {
	if goPanic {
		if article.ArticleId == 0 {
			// noinline
			// https://github.com/golang/go/wiki/CompilerOptimizations#function-inlining
			panic(nil)
		}
	}
}

func PassArticleByPointer(article *Article, goPanic bool) {
	if goPanic {
		if article.ArticleId == 0 {
			// noinline
			// https://github.com/golang/go/wiki/CompilerOptimizations#function-inlining
			panic(nil)
		}
	}
}

func BenchmarkPassArticleByValue(b *testing.B) {
	article := Article{}
	for i := 0; i < b.N; i++ {
		PassArticleByValue(article, false)
	}
}

func BenchmarkPassArticleByPointer(b *testing.B) {
	article := Article{}
	for i := 0; i < b.N; i++ {
		PassArticleByPointer(&article, false)
	}
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/Auth.go
package model

import (
	"fmt"
	"github.com/dgrijalva/jwt-go"
	"golang.org/x/crypto/scrypt"
	"strings"
	"time"
)

const TokenExpirationDays = 60

var passwordSalt = []byte("KU2YVXA7BSNExJIvemcdz61eL86IJDCC")
var jwtSecret = []byte("C92cw5od80NCWIvu4NZ8AKp5NyTbnBmG") // TODO: Generate random secrets and store in DynamoDB

func Scrypt(password string) ([]byte, error) {
	// https://godoc.org/golang.org/x/crypto/scrypt
	passwordHash, err := scrypt.Key([]byte(password), passwordSalt, 32768, 8, 1, PasswordKeyLength)
	if err != nil {
		return nil, err
	}

	return passwordHash, nil
}

func GenerateToken(username string) (string, error) {
	now := time.Now().UTC()
	exp := now.AddDate(0, 0, TokenExpirationDays).Unix()

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"sub": username,
		"exp": exp,
	})

	return token.SignedString(jwtSecret)
}

func VerifyAuthorization(auth string) (string, string, error) {
	parts := strings.SplitN(auth, " ", 2)
	if len(parts) != 2 || parts[0] != "Token" {
		return "", "", NewInputError("Authorization", "invalid format")
	}

	token := parts[1]
	username, err := VerifyToken(token)
	return username, token, err
}

func VerifyToken(tokenString string) (string, error) {
	token, err := jwt.Parse(tokenString, validateToken)

	if err != nil {
		return "", err
	}

	if token == nil || !token.Valid {
		return "", NewInputError("Authorization", "invalid token")
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return "", NewInputError("Authorization", "invalid claims")
	}

	if !claims.VerifyExpiresAt(time.Now().UTC().Unix(), true) {
		return "", NewInputError("Authorization", "token expired")
	}

	username, ok := claims["sub"].(string)
	if !ok {
		return "", NewInputError("Authorization", "sub missing")
	}

	return username, nil
}

func validateToken(token *jwt.Token) (interface{}, error) {
	_, ok := token.Method.(*jwt.SigningMethodHMAC)
	if !ok {
		return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
	}

	return jwtSecret, nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/Comment.go
package model

const MaxCommentId = 0x1000000 // exclusive

type CommentKey struct {
	ArticleId int64
	CommentId int64
}

type Comment struct {
	CommentKey
	CreatedAt int64
	UpdatedAt int64
	Body      string
	Author    string
}

func (comment *Comment) Validate() error {
	if comment.Body == "" {
		return NewInputError("body", "can't be blank")
	}

	return nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/InputError.go
package model

import "encoding/json"

type InputError map[string][]string

func (e InputError) Error() string {
	js, err := json.Marshal(e)
	if err != nil {
		return err.Error()
	}

	return string(js)
}

func NewInputError(inputName, message string) InputError {
	return InputError{
		inputName: {message},
	}
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/model/User.go
package model

import (
	"fmt"
)

const MinPasswordLength = 0
const PasswordKeyLength = 64

type User struct {
	Username     string
	Email        string
	PasswordHash []byte
	Image        string
	Bio          string
}

type EmailUser struct {
	Email    string
	Username string
}

type Follow struct {
	Follower  string
	Publisher string
}

func (u *User) Validate() error {
	if u.Username == "" {
		return NewInputError("username", "can't be blank")
	}

	if u.Email == "" {
		return NewInputError("email", "can't be blank")
	}

	if u.PasswordHash == nil || len(u.PasswordHash) != PasswordKeyLength {
		return NewInputError("password", "can't be blank")
	}

	return nil
}

func ValidatePassword(password string) error {
	if len(password) < MinPasswordLength {
		return NewInputError("password", fmt.Sprintf("must be at least %d characters in length", MinPasswordLength))
	}

	return nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-feed-get/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"strconv"
	"time"
)

type Response struct {
	Articles      []ArticleResponse `json:"articles"`
	ArticlesCount int               `json:"articlesCount"`
}

type ArticleResponse struct {
	Slug           string         `json:"slug"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Body           string         `json:"body"`
	TagList        []string       `json:"tagList"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	Favorited      bool           `json:"favorited"`
	FavoritesCount int64          `json:"favoritesCount"`
	Author         AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	offset, err := strconv.Atoi(input.QueryStringParameters["offset"])
	if err != nil {
		offset = 0
	}

	limit, err := strconv.Atoi(input.QueryStringParameters["limit"])
	if err != nil {
		limit = 20
	}

	articles, err := service.GetFeed(user.Username, offset, limit)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	isFavorited, authors, _, err := service.GetArticleRelatedProperties(user, articles, false)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	articleResponses := make([]ArticleResponse, 0, len(articles))

	for i, article := range articles {
		articleResponses = append(articleResponses, ArticleResponse{
			Slug:           article.Slug,
			Title:          article.Title,
			Description:    article.Description,
			Body:           article.Body,
			TagList:        article.TagList,
			CreatedAt:      time.Unix(0, article.CreatedAt).Format(model.TimestampFormat),
			UpdatedAt:      time.Unix(0, article.UpdatedAt).Format(model.TimestampFormat),
			Favorited:      isFavorited[i],
			FavoritesCount: article.FavoritesCount,
			Author: AuthorResponse{
				Username:  authors[i].Username,
				Bio:       authors[i].Bio,
				Image:     authors[i].Image,
				Following: true,
			},
		})
	}

	response := Response{
		Articles:      articleResponses,
		ArticlesCount: len(articleResponses),
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-get/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"strconv"
	"time"
)

type Response struct {
	Articles      []ArticleResponse `json:"articles"`
	ArticlesCount int               `json:"articlesCount"`
}

type ArticleResponse struct {
	Slug           string         `json:"slug"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Body           string         `json:"body"`
	TagList        []string       `json:"tagList"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	Favorited      bool           `json:"favorited"`
	FavoritesCount int64          `json:"favoritesCount"`
	Author         AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, _ := service.GetCurrentUser(input.Headers["Authorization"])

	offset, err := strconv.Atoi(input.QueryStringParameters["offset"])
	if err != nil {
		offset = 0
	}

	limit, err := strconv.Atoi(input.QueryStringParameters["limit"])
	if err != nil {
		limit = 20
	}

	author := input.QueryStringParameters["author"]
	tag := input.QueryStringParameters["tag"]
	favorited := input.QueryStringParameters["favorited"]

	articles, err := service.GetArticles(offset, limit, author, tag, favorited)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	isFavorited, authors, following, err := service.GetArticleRelatedProperties(user, articles, true)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	articleResponses := make([]ArticleResponse, 0, len(articles))

	for i, article := range articles {
		articleResponses = append(articleResponses, ArticleResponse{
			Slug:           article.Slug,
			Title:          article.Title,
			Description:    article.Description,
			Body:           article.Body,
			TagList:        article.TagList,
			CreatedAt:      time.Unix(0, article.CreatedAt).Format(model.TimestampFormat),
			UpdatedAt:      time.Unix(0, article.UpdatedAt).Format(model.TimestampFormat),
			Favorited:      isFavorited[i],
			FavoritesCount: article.FavoritesCount,
			Author: AuthorResponse{
				Username:  authors[i].Username,
				Bio:       authors[i].Bio,
				Image:     authors[i].Image,
				Following: following[i],
			},
		})
	}

	response := Response{
		Articles:      articleResponses,
		ArticlesCount: len(articleResponses),
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-post/main.go
package main

import (
	"encoding/json"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"time"
)

type Request struct {
	Article ArticleRequest `json:"article"`
}

type ArticleRequest struct {
	Title       string   `json:"title"`
	Description string   `json:"description"`
	Body        string   `json:"body"`
	TagList     []string `json:"tagList"`
}

type Response struct {
	Article ArticleResponse `json:"article"`
}

type ArticleResponse struct {
	Slug           string         `json:"slug"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Body           string         `json:"body"`
	TagList        []string       `json:"tagList"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	Favorited      bool           `json:"favorited"`
	FavoritesCount int64          `json:"favoritesCount"`
	Author         AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	request := Request{}
	err = json.Unmarshal([]byte(input.Body), &request)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	now := time.Now().UTC()
	nowUnixNano := now.UnixNano()
	nowStr := now.Format(model.TimestampFormat)

	article := model.Article{
		Title:       request.Article.Title,
		Description: request.Article.Description,
		Body:        request.Article.Body,
		TagList:     request.Article.TagList, // TODO .distinct()
		CreatedAt:   nowUnixNano,
		UpdatedAt:   nowUnixNano,
		Author:      user.Username,
	}

	err = service.PutArticle(&article)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Article: ArticleResponse{
			Slug:           article.Slug,
			Title:          article.Title,
			Description:    article.Description,
			Body:           article.Body,
			TagList:        article.TagList,
			CreatedAt:      nowStr,
			UpdatedAt:      nowStr,
			Favorited:      false,
			FavoritesCount: 0,
			Author: AuthorResponse{
				Username:  user.Username,
				Bio:       user.Bio,
				Image:     user.Image,
				Following: false,
			},
		},
	}

	return util.NewSuccessResponse(201, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-slug-delete/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	err = service.DeleteArticle(input.PathParameters["slug"], user.Username)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	return util.NewSuccessResponse(200, nil)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-slug-get/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"time"
)

type Response struct {
	Article ArticleResponse `json:"article"`
}

type ArticleResponse struct {
	Slug           string         `json:"slug"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Body           string         `json:"body"`
	TagList        []string       `json:"tagList"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	Favorited      bool           `json:"favorited"`
	FavoritesCount int64          `json:"favoritesCount"`
	Author         AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, _ := service.GetCurrentUser(input.Headers["Authorization"])

	article, err := service.GetArticleBySlug(input.PathParameters["slug"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	isFavorited, authors, following, err := service.GetArticleRelatedProperties(user, []model.Article{article}, true)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Article: ArticleResponse{
			Slug:           article.Slug,
			Title:          article.Title,
			Description:    article.Description,
			Body:           article.Body,
			TagList:        article.TagList,
			CreatedAt:      time.Unix(0, article.CreatedAt).Format(model.TimestampFormat),
			UpdatedAt:      time.Unix(0, article.UpdatedAt).Format(model.TimestampFormat),
			Favorited:      isFavorited[0],
			FavoritesCount: article.FavoritesCount,
			Author: AuthorResponse{
				Username:  authors[0].Username,
				Bio:       authors[0].Bio,
				Image:     authors[0].Image,
				Following: following[0],
			},
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/articles-slug-put/main.go
package main

import (
	"encoding/json"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"time"
)

type Request struct {
	Article ArticleRequest `json:"article"`
}

type ArticleRequest struct {
	Title       string   `json:"title"`
	Description string   `json:"description"`
	Body        string   `json:"body"`
	TagList     []string `json:"tagList"`
}

type Response struct {
	Article ArticleResponse `json:"article"`
}

type ArticleResponse struct {
	Slug           string         `json:"slug"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Body           string         `json:"body"`
	TagList        []string       `json:"tagList"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	Favorited      bool           `json:"favorited"`
	FavoritesCount int64          `json:"favoritesCount"`
	Author         AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	request := Request{}
	err = json.Unmarshal([]byte(input.Body), &request)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	oldArticle, err := service.GetArticleBySlug(input.PathParameters["slug"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	newArticle := createNewArticle(request, oldArticle)

	err = service.UpdateArticle(oldArticle, &newArticle)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	isFavorited, authors, following, err := service.GetArticleRelatedProperties(user, []model.Article{newArticle}, true)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Article: ArticleResponse{
			Slug:           newArticle.Slug,
			Title:          newArticle.Title,
			Description:    newArticle.Description,
			Body:           newArticle.Body,
			TagList:        newArticle.TagList,
			CreatedAt:      time.Unix(0, newArticle.CreatedAt).Format(model.TimestampFormat),
			UpdatedAt:      time.Unix(0, newArticle.UpdatedAt).Format(model.TimestampFormat),
			Favorited:      isFavorited[0],
			FavoritesCount: newArticle.FavoritesCount,
			Author: AuthorResponse{
				Username:  authors[0].Username,
				Bio:       authors[0].Bio,
				Image:     authors[0].Image,
				Following: following[0],
			},
		},
	}

	return util.NewSuccessResponse(200, response)
}

func createNewArticle(request Request, oldArticle model.Article) model.Article {
	newArticle := model.Article{
		ArticleId:      oldArticle.ArticleId,
		Title:          request.Article.Title,
		Description:    request.Article.Description,
		Body:           request.Article.Body,
		TagList:        request.Article.TagList,
		CreatedAt:      oldArticle.CreatedAt,
		UpdatedAt:      time.Now().UTC().UnixNano(),
		FavoritesCount: oldArticle.FavoritesCount,
		Author:         oldArticle.Author,
	}

	if newArticle.Title == "" {
		newArticle.Title = oldArticle.Title
	}

	if newArticle.Description == "" {
		newArticle.Description = oldArticle.Description
	}

	if newArticle.Body == "" {
		newArticle.Body = oldArticle.Body
	}

	if newArticle.TagList == nil {
		newArticle.TagList = oldArticle.TagList
	}

	return newArticle
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/comments-delete/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"strconv"
)

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	commentId, err := strconv.ParseInt(input.PathParameters["id"], 10, 64)
	if err != nil {
		return util.NewErrorResponse(model.NewInputError("id", "invalid"))
	}

	err = service.DeleteComment(input.PathParameters["slug"], commentId, user.Username)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	return util.NewSuccessResponse(200, nil)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/comments-get/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"time"
)

type Response struct {
	Comments []CommentResponse `json:"comments"`
}

type CommentResponse struct {
	Id        int64          `json:"id"`
	CreatedAt string         `json:"createdAt"`
	UpdatedAt string         `json:"updatedAt"`
	Body      string         `json:"body"`
	Author    AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, _ := service.GetCurrentUser(input.Headers["Authorization"])

	comments, err := service.GetComments(input.PathParameters["slug"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	authors, following, err := service.GetCommentRelatedProperties(user, comments)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	commentResponses := make([]CommentResponse, 0, len(comments))

	for i, comment := range comments {
		commentResponses = append(commentResponses, CommentResponse{
			Id:        comment.CommentId,
			Body:      comment.Body,
			CreatedAt: time.Unix(0, comment.CreatedAt).Format(model.TimestampFormat),
			UpdatedAt: time.Unix(0, comment.UpdatedAt).Format(model.TimestampFormat),
			Author: AuthorResponse{
				Username:  authors[i].Username,
				Bio:       authors[i].Bio,
				Image:     authors[i].Image,
				Following: following[i],
			},
		})
	}

	response := Response{
		Comments: commentResponses,
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/comments-post/main.go
package main

import (
	"encoding/json"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"time"
)

type Request struct {
	Comment CommentRequest `json:"comment"`
}

type CommentRequest struct {
	Body string `json:"body"`
}

type Response struct {
	Comment CommentResponse `json:"comment"`
}

type CommentResponse struct {
	Id        int64          `json:"id"`
	CreatedAt string         `json:"createdAt"`
	UpdatedAt string         `json:"updatedAt"`
	Body      string         `json:"body"`
	Author    AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	request := Request{}
	err = json.Unmarshal([]byte(input.Body), &request)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	// Make sure article exists, at least at this point
	article, err := service.GetArticleBySlug(input.PathParameters["slug"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	now := time.Now().UTC()
	nowUnixNano := now.UnixNano()
	nowStr := now.Format(model.TimestampFormat)

	comment := model.Comment{
		CommentKey: model.CommentKey{
			ArticleId: article.ArticleId,
		},
		CreatedAt: nowUnixNano,
		UpdatedAt: nowUnixNano,
		Body:      request.Comment.Body,
		Author:    user.Username,
	}

	err = service.PutComment(&comment)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Comment: CommentResponse{
			Id:        comment.CommentId,
			Body:      comment.Body,
			CreatedAt: nowStr,
			UpdatedAt: nowStr,
			Author: AuthorResponse{
				Username:  user.Username,
				Bio:       user.Bio,
				Image:     user.Image,
				Following: false,
			},
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/favorite-delete/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"time"
)

type Response struct {
	Article ArticleResponse `json:"article"`
}

type ArticleResponse struct {
	Slug           string         `json:"slug"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Body           string         `json:"body"`
	TagList        []string       `json:"tagList"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	Favorited      bool           `json:"favorited"`
	FavoritesCount int64          `json:"favoritesCount"`
	Author         AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	articleId, err := model.SlugToArticleId(input.PathParameters["slug"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	favoriteArticleKey := model.FavoriteArticleKey{
		Username:  user.Username,
		ArticleId: articleId,
	}

	err = service.UnfavoriteArticle(favoriteArticleKey)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	article, err := service.GetArticleByArticleId(articleId)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	isFavorited, authors, following, err := service.GetArticleRelatedProperties(user, []model.Article{article}, true)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Article: ArticleResponse{
			Slug:           article.Slug,
			Title:          article.Title,
			Description:    article.Description,
			Body:           article.Body,
			TagList:        article.TagList,
			CreatedAt:      time.Unix(0, article.CreatedAt).Format(model.TimestampFormat),
			UpdatedAt:      time.Unix(0, article.UpdatedAt).Format(model.TimestampFormat),
			Favorited:      isFavorited[0],
			FavoritesCount: article.FavoritesCount,
			Author: AuthorResponse{
				Username:  authors[0].Username,
				Bio:       authors[0].Bio,
				Image:     authors[0].Image,
				Following: following[0],
			},
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/favorite-post/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
	"time"
)

type Response struct {
	Article ArticleResponse `json:"article"`
}

type ArticleResponse struct {
	Slug           string         `json:"slug"`
	Title          string         `json:"title"`
	Description    string         `json:"description"`
	Body           string         `json:"body"`
	TagList        []string       `json:"tagList"`
	CreatedAt      string         `json:"createdAt"`
	UpdatedAt      string         `json:"updatedAt"`
	Favorited      bool           `json:"favorited"`
	FavoritesCount int64          `json:"favoritesCount"`
	Author         AuthorResponse `json:"author"`
}

type AuthorResponse struct {
	Username  string `json:"username"`
	Bio       string `json:"bio"`
	Image     string `json:"image"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	articleId, err := model.SlugToArticleId(input.PathParameters["slug"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	favoriteArticle := model.FavoriteArticle{
		FavoriteArticleKey: model.FavoriteArticleKey{
			Username:  user.Username,
			ArticleId: articleId,
		},
		FavoritedAt: time.Now().UTC().UnixNano(),
	}

	err = service.SetFavoriteArticle(favoriteArticle)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	article, err := service.GetArticleByArticleId(articleId)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	isFavorited, authors, following, err := service.GetArticleRelatedProperties(user, []model.Article{article}, true)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Article: ArticleResponse{
			Slug:           article.Slug,
			Title:          article.Title,
			Description:    article.Description,
			Body:           article.Body,
			TagList:        article.TagList,
			CreatedAt:      time.Unix(0, article.CreatedAt).Format(model.TimestampFormat),
			UpdatedAt:      time.Unix(0, article.UpdatedAt).Format(model.TimestampFormat),
			Favorited:      isFavorited[0],
			FavoritesCount: article.FavoritesCount,
			Author: AuthorResponse{
				Username:  authors[0].Username,
				Bio:       authors[0].Bio,
				Image:     authors[0].Image,
				Following: following[0],
			},
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/profiles-follow-delete/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

type Response struct {
	Profile ProfileResponse `json:"profile"`
}

type ProfileResponse struct {
	Username  string `json:"username"`
	Image     string `json:"image"`
	Bio       string `json:"bio"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	publisher, err := service.GetUserByUsername(input.PathParameters["username"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	err = service.Unfollow(user.Username, publisher.Username)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Profile: ProfileResponse{
			Username:  publisher.Username,
			Image:     publisher.Image,
			Bio:       publisher.Bio,
			Following: false,
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/profiles-follow-post/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

type Response struct {
	Profile ProfileResponse `json:"profile"`
}

type ProfileResponse struct {
	Username  string `json:"username"`
	Image     string `json:"image"`
	Bio       string `json:"bio"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	publisher, err := service.GetUserByUsername(input.PathParameters["username"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	err = service.Follow(user.Username, publisher.Username)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Profile: ProfileResponse{
			Username:  publisher.Username,
			Image:     publisher.Image,
			Bio:       publisher.Bio,
			Following: true,
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/profiles-get/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

type Response struct {
	Profile ProfileResponse `json:"profile"`
}

type ProfileResponse struct {
	Username  string `json:"username"`
	Image     string `json:"image"`
	Bio       string `json:"bio"`
	Following bool   `json:"following"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, _, _ := service.GetCurrentUser(input.Headers["Authorization"])

	publisher, err := service.GetUserByUsername(input.PathParameters["username"])
	if err != nil {
		return util.NewErrorResponse(err)
	}

	following, err := service.IsFollowing(user, []string{publisher.Username})
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Profile: ProfileResponse{
			Username:  publisher.Username,
			Image:     publisher.Image,
			Bio:       publisher.Bio,
			Following: following[0],
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/tags-get/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

type Response struct {
	Tags []string `json:"tags"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	tags, err := service.GetTags()
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		Tags: tags,
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/user-get/main.go
package main

import (
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

type Response struct {
	User UserResponse `json:"user"`
}

type UserResponse struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Image    string `json:"image"`
	Bio      string `json:"bio"`
	Token    string `json:"token"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	user, token, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	response := Response{
		User: UserResponse{
			Username: user.Username,
			Email:    user.Email,
			Image:    user.Image,
			Bio:      user.Bio,
			Token:    token,
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/user-put/main.go
package main

import (
	"encoding/json"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

type Request struct {
	User UserRequest `json:"user"`
}

type UserRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
	Image    string `json:"image"`
	Bio      string `json:"bio"`
}

type Response struct {
	User UserResponse `json:"user"`
}

type UserResponse struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Image    string `json:"image"`
	Bio      string `json:"bio"`
	Token    string `json:"token"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	oldUser, token, err := service.GetCurrentUser(input.Headers["Authorization"])
	if err != nil {
		return util.NewUnauthorizedResponse()
	}

	request := Request{}
	err = json.Unmarshal([]byte(input.Body), &request)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	err = model.ValidatePassword(request.User.Password)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	passwordHash, err := model.Scrypt(request.User.Password)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	newUser := model.User{
		Username:     oldUser.Username,
		Email:        request.User.Email,
		PasswordHash: passwordHash,
		Image:        request.User.Image,
		Bio:          request.User.Bio,
	}

	err = service.UpdateUser(*oldUser, newUser)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		User: UserResponse{
			Username: newUser.Username,
			Email:    newUser.Email,
			Image:    newUser.Image,
			Bio:      newUser.Bio,
			Token:    token,
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/users-login-post/main.go
package main

import (
	"bytes"
	"encoding/json"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

type Request struct {
	User UserRequest `json:"user"`
}

type UserRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type Response struct {
	User UserResponse `json:"user"`
}

type UserResponse struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Image    string `json:"image"`
	Bio      string `json:"bio"`
	Token    string `json:"token"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	request := Request{}
	err := json.Unmarshal([]byte(input.Body), &request)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	user, err := service.GetUserByEmail(request.User.Email)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	passwordHash, err := model.Scrypt(request.User.Password)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	if !bytes.Equal(passwordHash, user.PasswordHash) {
		return util.NewErrorResponse(model.NewInputError("password", "wrong password"))
	}

	token, err := model.GenerateToken(user.Username)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		User: UserResponse{
			Username: user.Username,
			Email:    user.Email,
			Image:    user.Image,
			Bio:      user.Bio,
			Token:    token,
		},
	}

	return util.NewSuccessResponse(200, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/route/users-post/main.go
package main

import (
	"encoding/json"
	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/service"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

type Request struct {
	User UserRequest `json:"user"`
}

type UserRequest struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Password string `json:"password"`
}

type Response struct {
	User UserResponse `json:"user"`
}

type UserResponse struct {
	Username string `json:"username"`
	Email    string `json:"email"`
	Image    string `json:"image"`
	Bio      string `json:"bio"`
	Token    string `json:"token"`
}

func Handle(input events.APIGatewayProxyRequest) (events.APIGatewayProxyResponse, error) {
	request := Request{}
	err := json.Unmarshal([]byte(input.Body), &request)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	err = model.ValidatePassword(request.User.Password)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	passwordHash, err := model.Scrypt(request.User.Password)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	user := model.User{
		Username:     request.User.Username,
		Email:        request.User.Email,
		PasswordHash: passwordHash,
	}

	err = service.PutUser(user)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	token, err := model.GenerateToken(user.Username)
	if err != nil {
		return util.NewErrorResponse(err)
	}

	response := Response{
		User: UserResponse{
			Username: user.Username,
			Email:    user.Email,
			Image:    user.Image,
			Bio:      user.Bio,
			Token:    token,
		},
	}

	return util.NewSuccessResponse(201, response)
}

func main() {
	lambda.Start(Handle)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/ArticleService.go
package service

import (
	"errors"
	"fmt"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/aws/aws-sdk-go/service/dynamodb/expression"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

func PutArticle(article *model.Article) error {
	err := article.Validate()
	if err != nil {
		return err
	}

	const maxAttempt = 5

	// Try to find a unique article id
	for attempt := 0; ; attempt++ {
		err := putArticleWithRandomId(article)

		if err == nil {
			return nil
		}

		if attempt >= maxAttempt {
			return err
		}

		if !IsConditionalCheckFailed(err) {
			return err
		}

		ArticleIdRand.RenewSeed()
	}
}

func putArticleWithRandomId(article *model.Article) error {
	article.ArticleId = 1 + ArticleIdRand.Get().Int63n(model.MaxArticleId-1) // range: [1, MaxArticleId)
	article.MakeSlug()

	articleItem, err := dynamodbattribute.MarshalMap(article)
	if err != nil {
		return err
	}

	transactItems := make([]*dynamodb.TransactWriteItem, 0, 1+2*len(article.TagList))

	// Put a new article
	transactItems = append(transactItems, &dynamodb.TransactWriteItem{
		Put: &dynamodb.Put{
			TableName:           aws.String(ArticleTableName),
			Item:                articleItem,
			ConditionExpression: aws.String("attribute_not_exists(ArticleId)"),
		},
	})

	for _, tag := range article.TagList {
		articleTag := model.ArticleTag{
			Tag:       tag,
			ArticleId: article.ArticleId,
			CreatedAt: article.CreatedAt,
		}

		item, err := dynamodbattribute.MarshalMap(articleTag)
		if err != nil {
			return err
		}

		// Link article with tag
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Put: &dynamodb.Put{
				TableName: aws.String(ArticleTagTableName),
				Item:      item,
			},
		})

		// Update article count for each tag
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Update: &dynamodb.Update{
				TableName:        aws.String(TagTableName),
				Key:              StringKey("Tag", tag),
				UpdateExpression: aws.String("ADD ArticleCount :one SET Dummy=:zero"),
				ExpressionAttributeValues: AWSObject{
					":one":  IntValue(1),
					":zero": IntValue(0),
				},
			},
		})
	}

	_, err = DynamoDB().TransactWriteItems(&dynamodb.TransactWriteItemsInput{
		TransactItems: transactItems,
	})

	return err
}

func GetArticles(offset, limit int, author, tag, favorited string) ([]model.Article, error) {
	if offset < 0 {
		return nil, model.NewInputError("offset", "must be non-negative")
	}

	if limit <= 0 {
		return nil, model.NewInputError("limit", "must be positive")
	}

	const maxDepth = 1000
	if offset+limit > maxDepth {
		return nil, model.NewInputError("offset + limit", fmt.Sprintf("must be smaller or equal to %d", maxDepth))
	}

	numFilters := getNumFilters(author, tag, favorited)
	if numFilters > 1 {
		return nil, model.NewInputError("author, tag, favorited", "only one of these can be specified")
	}

	if numFilters == 0 {
		return getAllArticles(offset, limit)
	}

	if author != "" {
		return getArticlesByAuthor(author, offset, limit)
	}

	if tag != "" {
		return getArticlesByTag(tag, offset, limit)
	}

	if favorited != "" {
		return getFavoriteArticlesByUsername(favorited, offset, limit)
	}

	return nil, errors.New("unreachable code")
}

func getNumFilters(author, tag, favorited string) int {
	numFilters := 0
	if author != "" {
		numFilters++
	}
	if tag != "" {
		numFilters++
	}
	if favorited != "" {
		numFilters++
	}
	return numFilters
}

func getAllArticles(offset, limit int) ([]model.Article, error) {
	queryArticles := dynamodb.QueryInput{
		TableName:                 aws.String(ArticleTableName),
		IndexName:                 aws.String("CreatedAt"),
		KeyConditionExpression:    aws.String("Dummy=:zero"),
		ExpressionAttributeValues: IntKey(":zero", 0),
		Limit:                     aws.Int64(int64(offset + limit)),
		ScanIndexForward:          aws.Bool(false),
	}

	items, err := QueryItems(&queryArticles, offset, limit)
	if err != nil {
		return nil, err
	}

	articles := make([]model.Article, len(items))
	err = dynamodbattribute.UnmarshalListOfMaps(items, &articles)
	if err != nil {
		return nil, err
	}

	return articles, nil
}

func getArticlesByAuthor(author string, offset, limit int) ([]model.Article, error) {
	queryArticles := dynamodb.QueryInput{
		TableName:                 aws.String(ArticleTableName),
		IndexName:                 aws.String("Author"),
		KeyConditionExpression:    aws.String("Author=:author"),
		ExpressionAttributeValues: StringKey(":author", author),
		Limit:                     aws.Int64(int64(offset + limit)),
		ScanIndexForward:          aws.Bool(false),
	}

	items, err := QueryItems(&queryArticles, offset, limit)
	if err != nil {
		return nil, err
	}

	articles := make([]model.Article, len(items))
	err = dynamodbattribute.UnmarshalListOfMaps(items, &articles)
	if err != nil {
		return nil, err
	}

	return articles, nil
}

func getArticlesByTag(tag string, offset, limit int) ([]model.Article, error) {
	articleIds, err := GetArticleIdsByTag(tag, offset, limit)
	if err != nil {
		return nil, err
	}

	return getArticlesByArticleIds(articleIds, limit)
}

func getFavoriteArticlesByUsername(username string, offset, limit int) ([]model.Article, error) {
	articleIds, err := GetFavoriteArticleIdsByUsername(username, offset, limit)
	if err != nil {
		return nil, err
	}

	return getArticlesByArticleIds(articleIds, limit)
}

func getArticlesByArticleIds(articleIds []int64, limit int) ([]model.Article, error) {
	if len(articleIds) == 0 {
		return make([]model.Article, 0), nil
	}

	keys := make([]AWSObject, 0, len(articleIds))
	for _, articleId := range articleIds {
		keys = append(keys, Int64Key("ArticleId", articleId))
	}

	batchGetArticles := dynamodb.BatchGetItemInput{
		RequestItems: map[string]*dynamodb.KeysAndAttributes{
			ArticleTableName: {
				Keys: keys,
			},
		},
	}

	responses, err := BatchGetItems(&batchGetArticles, limit)
	if err != nil {
		return nil, err
	}

	articles := make([]model.Article, len(articleIds))
	articleIdToIndex := ReverseIndexInt64(articleIds)

	for _, response := range responses {
		for _, items := range response {
			for _, item := range items {
				article := model.Article{}
				err = dynamodbattribute.UnmarshalMap(item, &article)
				if err != nil {
					return nil, err
				}

				index := articleIdToIndex[article.ArticleId]
				articles[index] = article
			}
		}
	}

	return articles, nil
}

func GetArticleRelatedProperties(user *model.User, articles []model.Article, getFollowing bool) ([]bool, []model.User, []bool, error) {
	isFavorited, err := IsArticleFavoritedByUser(user, articles)
	if err != nil {
		return nil, nil, nil, err
	}

	authorUsernames := make([]string, 0, len(articles))
	for _, article := range articles {
		authorUsernames = append(authorUsernames, article.Author)
	}

	authors, err := GetUserListByUsername(authorUsernames)
	if err != nil {
		return nil, nil, nil, err
	}

	following := make([]bool, 0)

	if getFollowing {
		following, err = IsFollowing(user, authorUsernames)
		if err != nil {
			return nil, nil, nil, err
		}
	}

	return isFavorited, authors, following, nil
}

func GetArticleBySlug(slug string) (model.Article, error) {
	articleId, err := model.SlugToArticleId(slug)
	if err != nil {
		return model.Article{}, err
	}

	return GetArticleByArticleId(articleId)
}

func GetArticleByArticleId(articleId int64) (model.Article, error) {
	article := model.Article{}
	found, err := GetItemByKey(ArticleTableName, Int64Key("ArticleId", articleId), &article)

	if err != nil {
		return model.Article{}, err
	}

	if !found {
		return model.Article{}, model.NewInputError("slug", "not found")
	}

	return article, nil
}

func UpdateArticle(oldArticle model.Article, newArticle *model.Article) error {
	err := newArticle.Validate()
	if err != nil {
		return err
	}

	newArticle.MakeSlug()

	oldTagSet := util.NewStringSetFromSlice(oldArticle.TagList)
	newTagSet := util.NewStringSetFromSlice(newArticle.TagList)
	oldTags := oldTagSet.Difference(newTagSet)
	newTags := newTagSet.Difference(oldTagSet)

	transactItems := make([]*dynamodb.TransactWriteItem, 0, 1+2*len(oldTags)+2*len(newTags))

	expr, err := buildArticleUpdateExpression(oldArticle, *newArticle, len(oldTags) != 0 || len(newTags) != 0)
	if err != nil {
		return err
	}

	// No field changed
	if expr.Update() == nil {
		return nil
	}

	// Update article
	transactItems = append(transactItems, &dynamodb.TransactWriteItem{
		Update: &dynamodb.Update{
			TableName:                 aws.String(ArticleTableName),
			Key:                       Int64Key("ArticleId", oldArticle.ArticleId),
			ConditionExpression:       aws.String("attribute_exists(ArticleId)"),
			UpdateExpression:          expr.Update(),
			ExpressionAttributeNames:  expr.Names(),
			ExpressionAttributeValues: expr.Values(),
		},
	})

	for tag := range oldTags {
		// Unlink article from tag
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Delete: &dynamodb.Delete{
				TableName: aws.String(ArticleTagTableName),
				Key: AWSObject{
					"Tag":       StringValue(tag),
					"ArticleId": Int64Value(oldArticle.ArticleId),
				},
			},
		})

		// Update article count for each tag
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Update: &dynamodb.Update{
				TableName:                 aws.String(TagTableName),
				Key:                       StringKey("Tag", tag),
				UpdateExpression:          aws.String("ADD ArticleCount :minus_one"),
				ExpressionAttributeValues: IntKey(":minus_one", -1),
			},
		})
	}

	for tag := range newTags {
		articleTag := model.ArticleTag{
			Tag:       tag,
			ArticleId: oldArticle.ArticleId,
			CreatedAt: oldArticle.CreatedAt,
		}

		item, err := dynamodbattribute.MarshalMap(articleTag)
		if err != nil {
			return err
		}

		// Link article with tag.
		// Ignored benign race condition:
		//   Current tag list: A B C
		//   Request 1:        A B      (Delete C)
		//   Request 2:        A B C D  (Add    D)
		//   There's a small chance for both requests to get through, leading to inconsistent result A B D
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Put: &dynamodb.Put{
				TableName: aws.String(ArticleTagTableName),
				Item:      item,
			},
		})

		// Update article count for each tag
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Update: &dynamodb.Update{
				TableName:        aws.String(TagTableName),
				Key:              StringKey("Tag", tag),
				UpdateExpression: aws.String("ADD ArticleCount :one SET Dummy=:zero"),
				ExpressionAttributeValues: AWSObject{
					":one":  IntValue(1),
					":zero": IntValue(0),
				},
			},
		})
	}

	_, err = DynamoDB().TransactWriteItems(&dynamodb.TransactWriteItemsInput{
		TransactItems: transactItems,
	})
	if err != nil {
		return err
	}

	return nil
}

func buildArticleUpdateExpression(oldArticle model.Article, newArticle model.Article, updateTagList bool) (expression.Expression, error) {
	update := expression.UpdateBuilder{}

	if oldArticle.Slug != newArticle.Slug {
		update = update.Set(expression.Name("Slug"), expression.Value(newArticle.Slug))
	}

	if oldArticle.Title != newArticle.Title {
		update = update.Set(expression.Name("Title"), expression.Value(newArticle.Title))
	}

	if oldArticle.Description != newArticle.Description {
		update = update.Set(expression.Name("Description"), expression.Value(newArticle.Description))
	}

	if oldArticle.Body != newArticle.Body {
		update = update.Set(expression.Name("Body"), expression.Value(newArticle.Body))
	}

	if updateTagList {
		update = update.Set(expression.Name("TagList"), expression.Value(newArticle.TagList))
	}

	if oldArticle.UpdatedAt != newArticle.UpdatedAt {
		update = update.Set(expression.Name("UpdatedAt"), expression.Value(newArticle.UpdatedAt))
	}

	if IsUpdateBuilderEmpty(update) {
		return expression.Expression{}, nil
	}

	builder := expression.NewBuilder().WithUpdate(update)
	return builder.Build()
}

func DeleteArticle(slug string, username string) error {
	article, err := GetArticleBySlug(slug)
	if err != nil {
		return err
	}

	transactItems := make([]*dynamodb.TransactWriteItem, 0, 3+2*len(article.TagList))

	transactItems = append(transactItems, &dynamodb.TransactWriteItem{
		Delete: &dynamodb.Delete{
			TableName:                 aws.String(ArticleTableName),
			Key:                       Int64Key("ArticleId", article.ArticleId),
			ConditionExpression:       aws.String("Author=:username"),
			ExpressionAttributeValues: StringKey(":username", username),
		},
	})

	// TODO: DynamoDB doesn't support deleting a whole partition by specifying just the partition key.
	// https://stackoverflow.com/questions/34259358/dynamodb-delete-all-items-having-same-hash-key
	// It's probably easier to delete related items in FavoriteArticleTable and CommentTable
	// offline (despite potential article id overwrite).

	for _, tag := range article.TagList {
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Delete: &dynamodb.Delete{
				TableName: aws.String(ArticleTagTableName),
				Key: AWSObject{
					"Tag":       StringValue(tag),
					"ArticleId": Int64Value(article.ArticleId),
				},
			},
		})

		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Update: &dynamodb.Update{
				TableName:                 aws.String(TagTableName),
				Key:                       StringKey("Tag", tag),
				UpdateExpression:          aws.String("ADD ArticleCount :minus_one"),
				ExpressionAttributeValues: IntKey(":minus_one", -1),
			},
		})
	}

	_, err = DynamoDB().TransactWriteItems(&dynamodb.TransactWriteItemsInput{
		TransactItems: transactItems,
	})
	if err != nil {
		return err
	}

	return nil
}

func GetFeed(username string, offset, limit int) ([]model.Article, error) {
	queryPublishers := dynamodb.QueryInput{
		TableName:                 aws.String(FollowTableName),
		KeyConditionExpression:    aws.String("Follower=:username"),
		ExpressionAttributeValues: StringKey(":username", username),
		ProjectionExpression:      aws.String("Publisher"),
	}

	const queryInitialCapacity = 16
	items, err := QueryItems(&queryPublishers, 0, queryInitialCapacity)
	if err != nil {
		return nil, err
	}

	follows := make([]model.Follow, 0, len(items))
	err = dynamodbattribute.UnmarshalListOfMaps(items, &follows)
	if err != nil {
		return nil, err
	}

	// TODO: DynamoDB doesn't support batch queries
	// https://stackoverflow.com/questions/24953783/dynamodb-batch-execute-queryrequests
	// Concurrent queries can probably improve the performance of the following operations.

	articlesByAuthor := make(model.ArticlePriorityQueue, 0, len(follows))

	for _, follow := range follows {
		articles, err := getArticlesByAuthor(follow.Publisher, 0, limit)
		if err != nil {
			return nil, err
		}

		articlesByAuthor = append(articlesByAuthor, articles)
	}

	return model.MergeArticles(articlesByAuthor, offset, limit), nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/ArticleTagService.go
package service

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
)

func GetArticleIdsByTag(tag string, offset, limit int) ([]int64, error) {
	queryArticleIds := dynamodb.QueryInput{
		TableName:                 aws.String(ArticleTagTableName),
		IndexName:                 aws.String("CreatedAt"),
		KeyConditionExpression:    aws.String("Tag=:tag"),
		ExpressionAttributeValues: StringKey(":tag", tag),
		Limit:                     aws.Int64(int64(offset + limit)),
		ScanIndexForward:          aws.Bool(false),
		ProjectionExpression:      aws.String("ArticleId"),
	}

	items, err := QueryItems(&queryArticleIds, offset, limit)
	if err != nil {
		return nil, err
	}

	articleTags := make([]model.ArticleTag, len(items))
	err = dynamodbattribute.UnmarshalListOfMaps(items, &articleTags)
	if err != nil {
		return nil, err
	}

	articleIds := make([]int64, 0, len(items))

	for _, articleTag := range articleTags {
		articleIds = append(articleIds, articleTag.ArticleId)
	}

	return articleIds, nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/CommentService.go
package service

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
)

func PutComment(comment *model.Comment) error {
	err := comment.Validate()
	if err != nil {
		return err
	}

	const maxAttempt = 5

	// Try to find a unique comment id
	for attempt := 0; ; attempt++ {
		err := putCommentWithRandomId(comment)

		if err == nil {
			return nil
		}

		if attempt >= maxAttempt {
			return err
		}

		if !IsConditionalCheckFailed(err) {
			return err
		}

		CommentIdRand.RenewSeed()
	}
}

func putCommentWithRandomId(comment *model.Comment) error {
	comment.CommentId = 1 + CommentIdRand.Get().Int63n(model.MaxCommentId-1) // range: [1, MaxCommentId)

	commentItem, err := dynamodbattribute.MarshalMap(comment)
	if err != nil {
		return err
	}

	// Put a new article
	_, err = DynamoDB().PutItem(&dynamodb.PutItemInput{
		TableName:           aws.String(CommentTableName),
		Item:                commentItem,
		ConditionExpression: aws.String("attribute_not_exists(CommentId)"),
	})

	return err
}

func GetCommentRelatedProperties(user *model.User, comments []model.Comment) ([]model.User, []bool, error) {
	authorUsernames := make([]string, 0, len(comments))
	for _, comment := range comments {
		authorUsernames = append(authorUsernames, comment.Author)
	}

	authors, err := GetUserListByUsername(authorUsernames)
	if err != nil {
		return nil, nil, err
	}

	following, err := IsFollowing(user, authorUsernames)
	if err != nil {
		return nil, nil, err
	}

	return authors, following, nil
}

func GetComments(slug string) ([]model.Comment, error) {
	articleId, err := model.SlugToArticleId(slug)
	if err != nil {
		return nil, err
	}

	queryComments := dynamodb.QueryInput{
		TableName:                 aws.String(CommentTableName),
		IndexName:                 aws.String("CreatedAt"),
		KeyConditionExpression:    aws.String("ArticleId=:articleId"),
		ExpressionAttributeValues: Int64Key(":articleId", articleId),
		ScanIndexForward:          aws.Bool(false),
	}

	const queryInitialCapacity = 16
	items, err := QueryItems(&queryComments, 0, queryInitialCapacity)
	if err != nil {
		return nil, err
	}

	comments := make([]model.Comment, len(items))
	err = dynamodbattribute.UnmarshalListOfMaps(items, &comments)
	if err != nil {
		return nil, err
	}

	return comments, nil
}

func DeleteComment(slug string, commentId int64, username string) error {
	articleId, err := model.SlugToArticleId(slug)
	if err != nil {
		return err
	}

	key := model.CommentKey{
		ArticleId: articleId,
		CommentId: commentId,
	}

	item, err := dynamodbattribute.MarshalMap(key)
	if err != nil {
		return err
	}

	deleteComment := dynamodb.DeleteItemInput{
		TableName:                 aws.String(CommentTableName),
		Key:                       item,
		ConditionExpression:       aws.String("Author=:username"),
		ExpressionAttributeValues: StringKey(":username", username),
	}

	_, err = DynamoDB().DeleteItem(&deleteComment)

	return err
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/CommonDBOperation.go
package service

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/util"
)

func GetItemByKey(tableName string, key AWSObject, out interface{}) (bool, error) {
	input := dynamodb.GetItemInput{
		TableName: aws.String(tableName),
		Key:       key,
	}

	output, err := DynamoDB().GetItem(&input)
	if err != nil {
		return false, err
	}

	if len(output.Item) == 0 {
		return false, nil
	}

	err = dynamodbattribute.UnmarshalMap(output.Item, out)
	if err != nil {
		return false, err
	}

	return true, nil
}

func QueryItems(queryInput *dynamodb.QueryInput, offset, cap int) ([]AWSObject, error) {
	items := make([]AWSObject, 0, cap)
	resultIndex := 0

	err := DynamoDB().QueryPages(queryInput, func(page *dynamodb.QueryOutput, lastPage bool) bool {
		pageCount := len(page.Items)

		if resultIndex+pageCount > offset {
			start := util.MaxInt(0, offset-resultIndex)
			for i := start; i < pageCount; i++ {
				items = append(items, page.Items[i])
			}
		}

		resultIndex += pageCount
		return true
	})

	if err != nil {
		return nil, err
	}

	return items, nil
}

func BatchGetItems(batchGetInput *dynamodb.BatchGetItemInput, cap int) ([]map[string][]AWSObject, error) {
	responses := make([]map[string][]AWSObject, 0, cap)

	err := DynamoDB().BatchGetItemPages(batchGetInput, func(page *dynamodb.BatchGetItemOutput, lastPage bool) bool {
		responses = append(responses, page.Responses)
		return true
	})

	if err != nil {
		return nil, err
	}

	return responses, nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/DynamoDBClient.go
package service

import (
	"github.com/aws/aws-sdk-go/aws/session"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"sync"
)

var once sync.Once
var svc *dynamodb.DynamoDB

func initializeSingletons() {
	sess := session.Must(session.NewSessionWithOptions(session.Options{
		SharedConfigState: session.SharedConfigEnable,
	}))

	svc = dynamodb.New(sess)
}

func DynamoDB() *dynamodb.DynamoDB {
	once.Do(initializeSingletons)
	return svc
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/FavoriteArticleService.go
package service

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
)

func GetFavoriteArticleIdsByUsername(username string, offset, limit int) ([]int64, error) {
	queryArticleIds := dynamodb.QueryInput{
		TableName:                 aws.String(FavoriteArticleTableName),
		IndexName:                 aws.String("FavoritedAt"),
		KeyConditionExpression:    aws.String("Username=:username"),
		ExpressionAttributeValues: StringKey(":username", username),
		Limit:                     aws.Int64(int64(offset + limit)),
		ScanIndexForward:          aws.Bool(false),
		ProjectionExpression:      aws.String("ArticleId"),
	}

	items, err := QueryItems(&queryArticleIds, offset, limit)
	if err != nil {
		return nil, err
	}

	favoriteArticles := make([]model.FavoriteArticle, len(items))
	err = dynamodbattribute.UnmarshalListOfMaps(items, &favoriteArticles)
	if err != nil {
		return nil, err
	}

	articleIds := make([]int64, 0, len(items))

	for _, favoriteArticle := range favoriteArticles {
		articleIds = append(articleIds, favoriteArticle.ArticleId)
	}

	return articleIds, nil
}

func IsArticleFavoritedByUser(user *model.User, articles []model.Article) ([]bool, error) {
	if user == nil || len(articles) == 0 {
		return make([]bool, len(articles)), nil
	}

	keys := make([]AWSObject, 0, len(articles))
	for _, article := range articles {
		keys = append(keys, AWSObject{
			"Username":  StringValue(user.Username),
			"ArticleId": Int64Value(article.ArticleId),
		})
	}

	batchGetFavoriteArticles := dynamodb.BatchGetItemInput{
		RequestItems: map[string]*dynamodb.KeysAndAttributes{
			FavoriteArticleTableName: {
				Keys:                 keys,
				ProjectionExpression: aws.String("ArticleId"),
			},
		},
	}

	responses, err := BatchGetItems(&batchGetFavoriteArticles, len(articles))
	if err != nil {
		return nil, err
	}

	isFavorited := make([]bool, len(articles))
	articleIdToIndex := reverseIndexArticleIds(articles)

	for _, response := range responses {
		for _, items := range response {
			for _, item := range items {
				favoriteArticle := model.FavoriteArticle{}
				err = dynamodbattribute.UnmarshalMap(item, &favoriteArticle)
				if err != nil {
					return nil, err
				}

				index := articleIdToIndex[favoriteArticle.ArticleId]
				isFavorited[index] = true
			}
		}
	}

	return isFavorited, nil
}

func reverseIndexArticleIds(articles []model.Article) map[int64]int {
	indices := make(map[int64]int)
	for i, article := range articles {
		indices[article.ArticleId] = i
	}
	return indices
}

func SetFavoriteArticle(favoriteArticle model.FavoriteArticle) error {
	item, err := dynamodbattribute.MarshalMap(favoriteArticle)
	if err != nil {
		return err
	}

	transactItems := make([]*dynamodb.TransactWriteItem, 0, 2)

	// Favorite the article
	transactItems = append(transactItems, &dynamodb.TransactWriteItem{
		Put: &dynamodb.Put{
			TableName:           aws.String(FavoriteArticleTableName),
			Item:                item,
			ConditionExpression: aws.String("attribute_not_exists(Username) AND attribute_not_exists(ArticleId)"),
		},
	})

	// Update favorites count
	transactItems = append(transactItems, &dynamodb.TransactWriteItem{
		Update: &dynamodb.Update{
			TableName:                 aws.String(ArticleTableName),
			Key:                       Int64Key("ArticleId", favoriteArticle.ArticleId),
			ConditionExpression:       aws.String("attribute_exists(ArticleId)"),
			UpdateExpression:          aws.String("ADD FavoritesCount :one"),
			ExpressionAttributeValues: IntKey(":one", 1),
		},
	})

	_, err = DynamoDB().TransactWriteItems(&dynamodb.TransactWriteItemsInput{
		TransactItems: transactItems,
	})

	if err != nil {
		return model.NewInputError("slug", "not found or already favorited")
	}

	return nil
}

func UnfavoriteArticle(favoriteArticle model.FavoriteArticleKey) error {
	item, err := dynamodbattribute.MarshalMap(favoriteArticle)
	if err != nil {
		return err
	}

	transactItems := make([]*dynamodb.TransactWriteItem, 0, 2)

	// Unfavorite the article
	transactItems = append(transactItems, &dynamodb.TransactWriteItem{
		Delete: &dynamodb.Delete{
			TableName:           aws.String(FavoriteArticleTableName),
			Key:                 item,
			ConditionExpression: aws.String("attribute_exists(Username) AND attribute_exists(ArticleId)"),
		},
	})

	// Update favorites count
	transactItems = append(transactItems, &dynamodb.TransactWriteItem{
		Update: &dynamodb.Update{
			TableName:                 aws.String(ArticleTableName),
			Key:                       Int64Key("ArticleId", favoriteArticle.ArticleId),
			ConditionExpression:       aws.String("attribute_exists(ArticleId)"),
			UpdateExpression:          aws.String("ADD FavoritesCount :minus_one"),
			ExpressionAttributeValues: IntKey(":minus_one", -1),
		},
	})

	_, err = DynamoDB().TransactWriteItems(&dynamodb.TransactWriteItemsInput{
		TransactItems: transactItems,
	})

	if err != nil {
		return model.NewInputError("slug", "not found or not favorited")
	}

	return nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/FollowService.go
package service

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
)

func IsFollowing(follower *model.User, publishers []string) ([]bool, error) {
	if follower == nil || len(publishers) == 0 {
		return make([]bool, len(publishers)), nil
	}

	publisherSet := make(map[string]bool)
	for _, publisher := range publishers {
		publisherSet[publisher] = true
	}

	keys := make([]AWSObject, 0, len(publisherSet))
	for publisher := range publisherSet {
		keys = append(keys, AWSObject{
			"Follower":  StringValue(follower.Username),
			"Publisher": StringValue(publisher),
		})
	}

	batchGetFollows := dynamodb.BatchGetItemInput{
		RequestItems: map[string]*dynamodb.KeysAndAttributes{
			FollowTableName: {
				Keys:                 keys,
				ProjectionExpression: aws.String("Publisher"),
			},
		},
	}

	responses, err := BatchGetItems(&batchGetFollows, len(publisherSet))
	if err != nil {
		return nil, err
	}

	followingUser := make(map[string]bool)

	for _, response := range responses {
		for _, items := range response {
			for _, item := range items {
				follow := model.Follow{}
				err = dynamodbattribute.UnmarshalMap(item, &follow)
				if err != nil {
					return nil, err
				}

				followingUser[follow.Publisher] = true
			}
		}
	}

	following := make([]bool, 0, len(publishers))
	for _, username := range publishers {
		following = append(following, followingUser[username])
	}

	return following, nil
}

func Follow(follower string, publisher string) error {
	follow := model.Follow{
		Follower:  follower,
		Publisher: publisher,
	}

	item, err := dynamodbattribute.MarshalMap(follow)
	if err != nil {
		return err
	}

	putFollow := dynamodb.PutItemInput{
		TableName: aws.String(FollowTableName),
		Item:      item,
	}

	_, err = DynamoDB().PutItem(&putFollow)

	return err
}

func Unfollow(follower string, publisher string) error {
	follow := model.Follow{
		Follower:  follower,
		Publisher: publisher,
	}

	item, err := dynamodbattribute.MarshalMap(follow)
	if err != nil {
		return err
	}

	deleteFollow := dynamodb.DeleteItemInput{
		TableName: aws.String(FollowTableName),
		Key:       item,
	}

	_, err = DynamoDB().DeleteItem(&deleteFollow)

	return err
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/Rand.go
package service

import (
	"math/rand"
	"time"
)

var ArticleIdRand = NewRand()
var CommentIdRand = NewRand()

type Rand struct {
	random *rand.Rand
}

func NewRand() Rand {
	r := Rand{}
	r.RenewSeed()
	return r
}

func (r *Rand) RenewSeed() {
	r.random = rand.New(rand.NewSource(time.Now().UnixNano()))
}

func (r *Rand) Get() *rand.Rand {
	return r.random
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/TableName.go
package service

import (
	"fmt"
	"os"
)

var Stage = os.Getenv("STAGE")

var UserTableName = makeTableName("user")
var EmailUserTableName = makeTableName("email-user")
var FollowTableName = makeTableName("follow")
var ArticleTableName = makeTableName("article")
var ArticleTagTableName = makeTableName("article-tag")
var TagTableName = makeTableName("tag")
var FavoriteArticleTableName = makeTableName("favorite-article")
var CommentTableName = makeTableName("comment")

func makeTableName(suffix string) string {
	return fmt.Sprintf("realworld-%s-%s", Stage, suffix)
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/TagService.go
package service

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
)

func GetTags() ([]string, error) {
	const maxNumTags = 20

	queryTags := dynamodb.QueryInput{
		TableName:                 aws.String(TagTableName),
		IndexName:                 aws.String("ArticleCount"),
		KeyConditionExpression:    aws.String("Dummy=:zero"),
		ExpressionAttributeValues: IntKey(":zero", 0),
		Limit:                     aws.Int64(maxNumTags),
		ScanIndexForward:          aws.Bool(false),
	}

	items, err := QueryItems(&queryTags, 0, maxNumTags)
	if err != nil {
		return nil, err
	}

	tagObjects := make([]model.Tag, len(items))
	err = dynamodbattribute.UnmarshalListOfMaps(items, &tagObjects)
	if err != nil {
		return nil, err
	}

	tags := make([]string, 0, len(tagObjects))
	for _, tagObject := range tagObjects {
		if tagObject.ArticleCount > 0 {
			tags = append(tags, tagObject.Tag)
		}
	}

	return tags, nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/UserService.go
package service

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
)

func PutUser(user model.User) error {
	err := user.Validate()
	if err != nil {
		return err
	}

	userItem, err := dynamodbattribute.MarshalMap(user)
	if err != nil {
		return err
	}

	emailUser := model.EmailUser{
		Email:    user.Email,
		Username: user.Username,
	}

	emailUserItem, err := dynamodbattribute.MarshalMap(emailUser)
	if err != nil {
		return err
	}

	// Put a new user, make sure username and email are unique
	transaction := dynamodb.TransactWriteItemsInput{
		TransactItems: []*dynamodb.TransactWriteItem{
			{
				Put: &dynamodb.Put{
					TableName:           aws.String(UserTableName),
					Item:                userItem,
					ConditionExpression: aws.String("attribute_not_exists(Username)"),
				},
			},
			{
				Put: &dynamodb.Put{
					TableName:           aws.String(EmailUserTableName),
					Item:                emailUserItem,
					ConditionExpression: aws.String("attribute_not_exists(Email)"),
				},
			},
		},
	}

	_, err = DynamoDB().TransactWriteItems(&transaction)
	if err != nil {
		// TODO: distinguish:
		// NewInputError("username", "has already been taken")
		// NewInputError("email", "has already been taken")
		return err
	}

	return nil
}

func UpdateUser(oldUser model.User, newUser model.User) error {
	err := newUser.Validate()
	if err != nil {
		return err
	}

	transactItems := make([]*dynamodb.TransactWriteItem, 0, 3)

	if oldUser.Email != newUser.Email {
		newEmailUser := model.EmailUser{
			Email:    newUser.Email,
			Username: newUser.Username,
		}

		newEmailUserItem, err := dynamodbattribute.MarshalMap(newEmailUser)
		if err != nil {
			return err
		}

		// Link user with the new email
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Put: &dynamodb.Put{
				TableName:           aws.String(EmailUserTableName),
				Item:                newEmailUserItem,
				ConditionExpression: aws.String("attribute_not_exists(Email)"),
			},
		})

		// Unlink user from the old email
		transactItems = append(transactItems, &dynamodb.TransactWriteItem{
			Delete: &dynamodb.Delete{
				TableName:           aws.String(EmailUserTableName),
				Key:                 StringKey("Email", oldUser.Email),
				ConditionExpression: aws.String("attribute_exists(Email)"),
			},
		})
	}

	newUserItem, err := dynamodbattribute.MarshalMap(newUser)
	if err != nil {
		return err
	}

	// Update user info
	transactItems = append(transactItems, &dynamodb.TransactWriteItem{
		Put: &dynamodb.Put{
			TableName:                 aws.String(UserTableName),
			Item:                      newUserItem,
			ConditionExpression:       aws.String("Email = :email"),
			ExpressionAttributeValues: StringKey(":email", oldUser.Email),
		},
	})

	_, err = DynamoDB().TransactWriteItems(&dynamodb.TransactWriteItemsInput{
		TransactItems: transactItems,
	})
	if err != nil {
		return err
	}

	return nil
}

func GetUserByEmail(email string) (model.User, error) {
	if email == "" {
		return model.User{}, model.NewInputError("email", "can't be blank")
	}

	username, err := GetUsernameByEmail(email)
	if err != nil {
		return model.User{}, err
	}

	return GetUserByUsername(username)
}

func GetUsernameByEmail(email string) (string, error) {
	emailUser := model.EmailUser{}
	found, err := GetItemByKey(EmailUserTableName, StringKey("Email", email), &emailUser)

	if err != nil {
		return "", err
	}

	if !found {
		return "", model.NewInputError("email", "not found")
	}

	return emailUser.Username, nil
}

func GetUserByUsername(username string) (model.User, error) {
	if username == "" {
		return model.User{}, model.NewInputError("username", "can't be blank")
	}

	user := model.User{}
	found, err := GetItemByKey(UserTableName, StringKey("Username", username), &user)

	if err != nil {
		return model.User{}, err
	}

	if !found {
		return model.User{}, model.NewInputError("username", "not found")
	}

	return user, err
}

func GetCurrentUser(auth string) (*model.User, string, error) {
	username, token, err := model.VerifyAuthorization(auth)
	if err != nil {
		return nil, "", err
	}

	user, err := GetUserByUsername(username)
	if err != nil {
		return nil, "", err
	}

	return &user, token, nil
}

func GetUserListByUsername(usernames []string) ([]model.User, error) {
	if len(usernames) == 0 {
		return make([]model.User, 0), nil
	}

	usernameSet := make(map[string]bool)
	for _, username := range usernames {
		usernameSet[username] = true
	}

	keys := make([]AWSObject, 0, len(usernameSet))
	for username := range usernameSet {
		keys = append(keys, StringKey("Username", username))
	}

	batchGetUsers := dynamodb.BatchGetItemInput{
		RequestItems: map[string]*dynamodb.KeysAndAttributes{
			UserTableName: {
				Keys: keys,
			},
		},
	}

	responses, err := BatchGetItems(&batchGetUsers, len(usernames))
	if err != nil {
		return nil, err
	}

	usersByUsername := make(map[string]model.User)

	for _, response := range responses {
		for _, items := range response {
			for _, item := range items {
				user := model.User{}
				err = dynamodbattribute.UnmarshalMap(item, &user)
				if err != nil {
					return nil, err
				}

				usersByUsername[user.Username] = user
			}
		}
	}

	users := make([]model.User, 0, len(usernames))
	for _, username := range usernames {
		users = append(users, usersByUsername[username])
	}

	return users, nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/Util.go
package service

import (
	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/service/dynamodb"
	"github.com/aws/aws-sdk-go/service/dynamodb/expression"
	"reflect"
	"strconv"
	"strings"
)

type AWSObject = map[string]*dynamodb.AttributeValue

func StringKey(name, value string) AWSObject {
	return AWSObject{
		name: StringValue(value),
	}
}

func StringValue(value string) *dynamodb.AttributeValue {
	return &dynamodb.AttributeValue{
		S: aws.String(value),
	}
}

func IntKey(name string, value int) AWSObject {
	return AWSObject{
		name: IntValue(value),
	}
}

func IntValue(value int) *dynamodb.AttributeValue {
	return &dynamodb.AttributeValue{
		N: aws.String(strconv.Itoa(value)),
	}
}

func Int64Key(name string, value int64) AWSObject {
	return AWSObject{
		name: Int64Value(value),
	}
}

func Int64Value(value int64) *dynamodb.AttributeValue {
	return &dynamodb.AttributeValue{
		N: aws.String(strconv.FormatInt(value, 10)),
	}
}

func BlobValue(value []byte) *dynamodb.AttributeValue {
	return &dynamodb.AttributeValue{
		B: value,
	}
}

func ReverseIndexInt64(values []int64) map[int64]int {
	indices := make(map[int64]int)
	for i, v := range values {
		indices[v] = i
	}
	return indices
}

func IsUpdateBuilderEmpty(update expression.UpdateBuilder) bool {
	return reflect.ValueOf(&update).Elem().FieldByName("operationList").IsNil()
}

func IsConditionalCheckFailed(err error) bool {
	aerr, ok := err.(awserr.Error)
	if !ok {
		return false
	}

	switch aerr.Code() {
	case dynamodb.ErrCodeConditionalCheckFailedException:
		return true
	case dynamodb.ErrCodeTransactionCanceledException:
		// TODO: DynamoDB Go client doesn't provide individual cancellation reasons for a transaction.
		// "If using Java, DynamoDB lists the cancellation reasons on the CancellationReasons
		// property. This property is not set for other languages."
		// https://docs.aws.amazon.com/sdk-for-go/api/service/dynamodb/#DynamoDB.TransactWriteItems
		// Here we depend on awserr.Error.Message(), which looks like
		// "Transaction cancelled, please refer cancellation reasons for specific reasons [ConditionalCheckFailed, None]"
		// https://github.com/aws/aws-sdk-go/issues/2318
		return strings.Contains(aerr.Message(), "ConditionalCheckFailed")
	default:
		return false
	}
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/service/Util_test.go
package service

import (
	"github.com/aws/aws-sdk-go/service/dynamodb/expression"
	"github.com/stretchr/testify/assert"
	"testing"
)

func TestIsUpdateBuilderEmpty(t *testing.T) {
	assert.True(t, IsUpdateBuilderEmpty(expression.UpdateBuilder{}))
	assert.False(t, IsUpdateBuilderEmpty(expression.Set(expression.Name("Name"), expression.Value("Value"))))
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/util/ErrorResponse.go
package util

import (
	"encoding/json"
	"github.com/aws/aws-lambda-go/events"
	"github.com/chrisxue815/realworld-aws-lambda-dynamodb-go/model"
)

type InputErrorResponse struct {
	Errors model.InputError `json:"errors"`
}

func NewErrorResponse(err error) (events.APIGatewayProxyResponse, error) {
	inputError, ok := err.(model.InputError)
	if !ok {
		// Internal server error
		return events.APIGatewayProxyResponse{}, err
	}

	body := InputErrorResponse{
		Errors: inputError,
	}

	jsonBody, err := json.Marshal(body)
	if err != nil {
		return events.APIGatewayProxyResponse{}, err
	}

	response := events.APIGatewayProxyResponse{
		StatusCode: 422,
		Body:       string(jsonBody),
		Headers:    CORSHeaders(),
	}
	return response, nil
}

func NewUnauthorizedResponse() (events.APIGatewayProxyResponse, error) {
	response := events.APIGatewayProxyResponse{
		StatusCode: 401,
		Headers:    CORSHeaders(),
	}
	return response, nil
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/util/Math.go
package util

func MaxInt(x, y int) int {
	if x < y {
		return y
	}
	return x
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/util/StringSet.go
package util

type StringSet map[string]bool

func NewStringSetFromSlice(slice []string) StringSet {
	s := make(StringSet, len(slice))
	for _, value := range slice {
		s[value] = true
	}
	return s
}

func (s StringSet) Difference(other StringSet) StringSet {
	result := make(StringSet)
	for value := range s {
		if !other[value] {
			result[value] = true
		}
	}
	return result
}

func (s StringSet) ToSlice() []string {
	result := make([]string, 0, len(s))
	for value := range s {
		result = append(result, value)
	}
	return result
}

--#

--% E:/desktop-laptop/_rwe/realworld-aws-lambda-dynamodb-go/util/SuccessResponse.go
package util

import (
	"encoding/json"
	"github.com/aws/aws-lambda-go/events"
)

func CORSHeaders() map[string]string {
	return map[string]string{
		"Access-Control-Allow-Origin":      "*",
		"Access-Control-Allow-Credentials": "true",
	}
}

func NewSuccessResponse(statusCode int, body interface{}) (events.APIGatewayProxyResponse, error) {
	response := events.APIGatewayProxyResponse{
		StatusCode: statusCode,
		Headers:    CORSHeaders(),
	}

	if body != nil {
		jsonBody, err := json.Marshal(body)
		if err != nil {
			return NewErrorResponse(err)
		}

		response.Body = string(jsonBody)
	}

	return response, nil
}

--#

