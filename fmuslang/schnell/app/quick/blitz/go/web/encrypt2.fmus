--% index/fmus
__PWD,d
    .,d(/load=__FILE__=index_under_pwd*)
--#

--% index_under_pwd
.,d(/mk)
	%__TEMPLATE_NAMA_GO_MOD_INIT=github.com/mexyusef/palsu
	$* go mod init __TEMPLATE_NAMA_GO_MOD_INIT
    main.go,f(e=__FILE__=main1.go)
	utils,d(/mk)
    	utils.go,f(e=__FILE__=main2.go)
--#

--% main1.go
package main

import (
	"log"

	"__TEMPLATE_NAMA_GO_MOD_INIT/utils"
)

// AES keys should be of length 16, 24, 32
func main() {
	key := "111023043350789514532147"
	message := "I am A Message"
	log.Println("Original message: ", message)
	encryptedString := utils.EncryptString(key, message)
	log.Println("Encrypted message: ", encryptedString)
	decryptedString := utils.DecryptString(key, encryptedString)
	log.Println("Decrypted message: ", decryptedString)
}

--#

--% main2.go
package utils

import (
	"crypto/aes"
	"crypto/cipher"
	"encoding/base64"
)

/* Initialization vector for the AES algorithm
   More details visit this link https://en.wikipedia.org/wiki/Advanced_Encryption_Standard */
var initVector = []byte{35, 46, 57, 24, 85, 35, 24, 74, 87, 35, 88, 98, 66, 32, 14, 05}

// EncryptString encrypts the string with given key
func EncryptString(key, text string) string {
	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		panic(err)
	}
	plaintext := []byte(text)
	cfb := cipher.NewCFBEncrypter(block, initVector)
	ciphertext := make([]byte, len(plaintext))
	cfb.XORKeyStream(ciphertext, plaintext)
	return base64.StdEncoding.EncodeToString(ciphertext)
}

// DecryptString decrypts the encrypted string to original
func DecryptString(key, text string) string {
	block, err := aes.NewCipher([]byte(key))
	if err != nil {
		panic(err)
	}
	ciphertext, _ := base64.StdEncoding.DecodeString(text)
	cfb := cipher.NewCFBDecrypter(block, initVector)
	plaintext := make([]byte, len(ciphertext))
	cfb.XORKeyStream(plaintext, ciphertext)
	return string(plaintext)
}
--#
