--% index/fmus
.,d(/mk)
	%utama=__FILE__
	example-11-1-minimal,d(/mk)
		Cargo.toml,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-1-minimal/Cargo.toml)
		src,d(/mk)
			main.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-1-minimal/src/main.rs)
	example-11-2-routes,d(/mk)
		Cargo.toml,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-2-routes/Cargo.toml)
		src,d(/mk)
			main.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-2-routes/src/main.rs)
		static,d(/mk)
			index.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-2-routes/static/index.html)
	example-11-3-json,d(/mk)
		Cargo.toml,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-3-json/Cargo.toml)
		src,d(/mk)
			main.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-3-json/src/main.rs)
		static,d(/mk)
			index.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-3-json/static/index.html)
	router,d(/mk)
		Cargo.toml,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/Cargo.toml)
		src,d(/mk)
			main.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/src/main.rs)
		static,d(/mk)
			comments.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/static/comments.html)
			index.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/static/index.html)
			login.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/static/login.html)
			script.js,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/static/script.js)
	router-cache,d(/mk)
		Cargo.toml,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/Cargo.toml)
		src,d(/mk)
			cache.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/src/cache.rs)
			main.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/src/main.rs)
		static,d(/mk)
			comments.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/static/comments.html)
			index.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/static/index.html)
			login.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/static/login.html)
			script.js,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/static/script.js)
	router-cache-ws,d(/mk)
		Cargo.toml,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/Cargo.toml)
		src,d(/mk)
			cache.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/src/cache.rs)
			main.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/src/main.rs)
			notify.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/src/notify.rs)
			repeater.rs,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/src/repeater.rs)
		static,d(/mk)
			comments.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/static/comments.html)
			index.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/static/index.html)
			login.html,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/static/login.html)
			script.js,f(e=utama=C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/static/script.js)
--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-1-minimal/Cargo.toml
[package]
name = "example-11-1-minimal"
version = "0.1.0"
authors = ["Yusef Ulum <yusef314159@gmail.com>"]
edition = "2018"

[dependencies]
actix-web = "0.7"

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-1-minimal/src/main.rs
extern crate actix_web;
use actix_web::{http, server, App, HttpRequest, Responder};

fn index(_: &HttpRequest) -> impl Responder {
    format!("Rust Microservice (actix)")
}

fn main() {
    server::new(
        || App::new()
            .resource("/", |r| r.method(http::Method::GET).f(index)))
        .bind("127.0.0.1:8080").unwrap()
        .run();
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-2-routes/Cargo.toml
[package]
name = "example-11-2-routes"
version = "0.1.0"
authors = ["Yusef Ulum <yusef314159@gmail.com>"]
edition = "2018"

[dependencies]
actix-web = "0.7"

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-2-routes/src/main.rs
extern crate actix_web;

use std::cell::RefCell;
use actix_web::{fs, server, App, HttpRequest, HttpResponse, Responder};
use actix_web::http::{self, header, Method};

struct AppState(RefCell<i64>);

impl AppState {
    fn new() -> Self {
        AppState(RefCell::default())
    }
}

fn count_up(req: HttpRequest<AppState>) -> impl Responder {
    *req.state().0.borrow_mut() += 1;
    format!("Count Up")
}

fn count_down(req: HttpRequest<AppState>) -> impl Responder {
    *req.state().0.borrow_mut() -= 1;
    format!("Count Down")
}

fn value(req: HttpRequest<AppState>) -> impl Responder {
    format!("Counter: {}", req.state().0.borrow())
}

fn main() {
    server::new(|| {
        App::with_state(AppState::new())
            .scope("/count", |scope| {
                scope.nested("/v1", |scope| {
                    scope
                        .route("/up", http::Method::GET, count_up)
                        .route("/down", http::Method::GET, count_down)
                })
                .route("/value", http::Method::GET, value)
            })
            .handler("/static", fs::StaticFiles::new("static").unwrap())
            .resource("/", |r| r.method(Method::GET).f(|_| {
                HttpResponse::Found()
                    .header(header::LOCATION, "static/index.html")
                    .finish()
}))
    })
    .bind("127.0.0.1:8080").unwrap().run();
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-2-routes/static/index.html
<!doctype html>
<html lang=en>
    <head>
        <meta charset=utf-8>
        <title>Rust Microservice (actix)</title>
    </head>
    <body>
        <p>Rust Microservice (actix)</p>
    </body>
</html>

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-3-json/Cargo.toml
[package]
name = "example-11-3-json"
version = "0.1.0"
authors = ["Yusef Ulum <yusef314159@gmail.com>"]
edition = "2018"

[dependencies]
serde = "1"
serde_derive = "1"
actix-web = "0.7"

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-3-json/src/main.rs
#[macro_use]
extern crate serde_derive;
extern crate actix_web;

use std::cell::RefCell;
use actix_web::{fs, server, App, Json, HttpRequest, HttpResponse, Responder};
use actix_web::http::{self, header, Method};

struct AppState(RefCell<i64>);

#[derive(Deserialize)]
struct NewState {
    value: i64,
}

impl AppState {
    fn new() -> Self {
        AppState(RefCell::default())
    }
}

fn count_up(req: HttpRequest<AppState>) -> impl Responder {
    *req.state().0.borrow_mut() += 1;
    format!("Count Up")
}

fn count_down(req: HttpRequest<AppState>) -> impl Responder {
    *req.state().0.borrow_mut() -= 1;
    format!("Count Down")
}

fn count_set((data, req): (Json<NewState>, HttpRequest<AppState>)) -> impl Responder {
    *req.state().0.borrow_mut() = data.value;
    format!("Count Set")
}

fn value(req: HttpRequest<AppState>) -> impl Responder {
    format!("Counter: {}", req.state().0.borrow())
}

fn main() {
    server::new(|| {
        App::with_state(AppState::new())
            .scope("/count", |scope| {
                scope.nested("/v1", |scope| {
                    scope
                        .route("/up", http::Method::GET, count_up)
                        .route("/down", http::Method::GET, count_down)
                })
                .route("/value", http::Method::GET, value)
            })
            .handler("/static", fs::StaticFiles::new("static").unwrap())
            .resource("/", |r| r.method(Method::GET).f(|_| {
                HttpResponse::Found()
                    .header(header::LOCATION, "static/index.html")
                    .finish()
}))
    })
    .bind("127.0.0.1:8080").unwrap().run();
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/example-11-3-json/static/index.html
<!doctype html>
<html lang=en>
    <head>
        <meta charset=utf-8>
        <title>Rust Microservice (actix)</title>
    </head>
    <body>
        <p>Rust Microservice (actix)</p>
    </body>
</html>

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/Cargo.toml
[package]
name = "router"
version = "0.1.0"
authors = ["Yusef Ulum <yusef314159@gmail.com>"]
edition = "2018"

[dependencies]
actix = "0.7"
actix-web = "0.7"
env_logger = "0.5"
failure = "0.1"
futures = "0.1"
log = "0.4"
serde = "1.0"
serde_derive = "1.0"
serde_urlencoded = "0.5"

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/src/main.rs
use actix_web::{
    client, middleware, server, fs, App, Error, Form, HttpMessage,
    HttpRequest, HttpResponse, FutureResponse, Result,
};
use actix_web::http::{self, header, StatusCode};
use actix_web::middleware::{Finished, Middleware, Response, Started};
use actix_web::middleware::identity::RequestIdentity;
use actix_web::middleware::identity::{CookieIdentityPolicy, IdentityService};
use failure::format_err;
use futures::{IntoFuture, Future};
use log::{error};
use serde::{Deserialize, Serialize};
use serde_derive::{Deserialize, Serialize};
use std::cell::RefCell;

fn boxed<I, E, F>(fut: F) -> Box<Future<Item = I, Error = E>>
where
    F: Future<Item = I, Error = E> + 'static,
{
    Box::new(fut)
}

fn get_request(url: &str) -> impl Future<Item = Vec<u8>, Error = Error> {
    client::ClientRequest::get(url)
        .finish().into_future()
        .and_then(|req| {
            req.send()
                .map_err(Error::from)
                .and_then(|resp| resp.body().from_err())
                .map(|bytes| bytes.to_vec())
        })
}

fn post_request<T, O>(url: &str, params: T) -> impl Future<Item = O, Error = Error>
where
    T: Serialize,
    O: for <'de> Deserialize<'de> + 'static,
{
    client::ClientRequest::post(url)
        .form(params)
        .into_future()
        .and_then(|req| {
            req.send()
                .map_err(Error::from)
                .and_then(|resp| {
                    if resp.status().is_success() {
                        let fut = resp
                            .json::<O>()
                            .from_err();
                        boxed(fut)
                    } else {
                        error!("Microservice error: {}", resp.status());
                        let fut = Err(format_err!("microservice error"))
                            .into_future()
                            .from_err();
                        boxed(fut)
                    }
                })
        })
}


#[derive(Deserialize, Serialize)]
pub struct UserForm {
    email: String,
    password: String,
}

#[derive(Deserialize)]
pub struct UserId {
    id: String,
}

#[derive(Deserialize, Serialize)]
pub struct Comment {
    pub id: Option<i32>,
    pub uid: String,
    pub text: String,
}

#[derive(Deserialize)]
pub struct AddComment {
    pub text: String,
}

#[derive(Serialize)]
pub struct NewComment {
    pub uid: String,
    pub text: String,
}

fn signup(params: Form<UserForm>) -> FutureResponse<HttpResponse> {
    let fut = post_request("http://127.0.0.1:8001/signup", params.into_inner())
        .map(|_: ()| {
            HttpResponse::Found()
            .header(header::LOCATION, "/login.html")
            .finish()
        });
    Box::new(fut)
}

fn signin((req, params): (HttpRequest<State>, Form<UserForm>)) -> FutureResponse<HttpResponse> {
    let fut = post_request("http://127.0.0.1:8001/signin", params.into_inner())
        .map(move |id: UserId| {
            req.remember(id.id);
            HttpResponse::build_from(&req)
            .status(StatusCode::FOUND)
            .header(header::LOCATION, "/comments.html")
            .finish()
        });
    Box::new(fut)
}

fn new_comment((req, params): (HttpRequest<State>, Form<AddComment>)) -> FutureResponse<HttpResponse> {
    let fut = req.identity()
        .ok_or(format_err!("not authorized").into())
        .into_future()
        .and_then(move |uid| {
            let params = NewComment {
                uid,
                text: params.into_inner().text,
            };
            post_request::<_, ()>("http://127.0.0.1:8003/new_comment", params)
        })
        .then(move |_| {
            let res = HttpResponse::build_from(&req)
                .status(StatusCode::FOUND)
                .header(header::LOCATION, "/comments.html")
                .finish();
            Ok(res)
        });
    Box::new(fut)
}

fn comments(_req: HttpRequest<State>) -> FutureResponse<HttpResponse> {
    let fut = get_request("http://127.0.0.1:8003/list")
        .map(|data| {
            HttpResponse::Ok().body(data)
        });
    Box::new(fut)
}

fn counter(req: HttpRequest<State>) -> String {
    format!("{}", req.state().0.borrow())
}


#[derive(Default)]
struct State(RefCell<i64>);

pub struct Counter;

impl Middleware<State> for Counter {
    fn start(&self, req: &HttpRequest<State>) -> Result<Started> {
        let value = *req.state().0.borrow();
        *req.state().0.borrow_mut() = value + 1;
        Ok(Started::Done)
    }

    fn response(&self, _req: &HttpRequest<State>, resp: HttpResponse) -> Result<Response> {
        Ok(Response::Done(resp))
    }

    fn finish(&self, _req: &HttpRequest<State>, _resp: &HttpResponse) -> Finished {
        Finished::Done
    }
}

fn main() {
    env_logger::init();
    let sys = actix::System::new("router");

    server::new(|| {
        App::with_state(State::default())
            .middleware(middleware::Logger::default())
            .middleware(IdentityService::new(
                    CookieIdentityPolicy::new(&[0; 32])
                    .name("auth-example")
                    .secure(false),
                    ))
            .middleware(Counter)
            .scope("/api", |scope| {
                scope
                    .route("/signup", http::Method::POST, signup)
                    .route("/signin", http::Method::POST, signin)
                    .route("/new_comment", http::Method::POST, new_comment)
                    .route("/comments", http::Method::GET, comments)
            })
            .route("/stats/counter", http::Method::GET, counter)
            .handler(
                "/",
                fs::StaticFiles::new("./static/").unwrap().index_file("index.html")
            )
    }).workers(1)
        .bind("127.0.0.1:8080")
        .unwrap()
        .start();

    println!("Started http server: 127.0.0.1:8080");
    let _ = sys.run();
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/static/comments.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/new_comment" method="post">
        Comment:<br>
        <input type="text" name="text"><br>
        <button type="submit">Add</button>
    </form>
    <div id="comments"></div>
  </body>
</html>


--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/static/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/signup" method="post">
        Email:<br>
        <input type="text" name="email"><br>
        Password<br>
        <input type="password" name="password"><br>
        <button type="submit">Signup</button>
    </form>
  </body>
</html>

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/static/login.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/signin" method="post">
        Email:<br>
        <input type="text" name="email"><br>
        Password<br>
        <input type="password" name="password"><br>
        <button type="submit">Login</button>
    </form>
  </body>
</html>


--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router/static/script.js

function create_node(text) {
    var element = document.getElementById("comments");
    var para = document.createElement("p");
    var node = document.createTextNode(text);
    para.appendChild(node);
    element.appendChild(para);
}

fetch('/api/comments')
    .then(function(response) {
        return response.json();
    })
    .then(function(data) {
        console.log(data);
        for(var i in data)
        {
            var item = data[i];
            create_node(item.uid);
            create_node(item.text);
        }
        console.log(JSON.stringify(comments));
    });

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/Cargo.toml
[package]
name = "router-cache"
version = "0.1.0"
authors = ["Yusef Ulum <yusef314159@gmail.com>"]
edition = "2018"

[dependencies]
actix = "0.7"
actix-web = "0.7"
env_logger = "0.5"
failure = "0.1"
futures = "0.1"
log = "0.4"
redis = "0.9"
serde = "1.0"
serde_derive = "1.0"
serde_urlencoded = "0.5"

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/src/cache.rs
use actix::prelude::*;
use failure::Error;
use futures::Future;
use redis::{Commands, Client, RedisError};

pub struct CacheActor {
    client: Client,
    expiration: usize,
}

impl CacheActor {
    pub fn new(addr: &str, expiration: usize) -> Self {
        let client = Client::open(addr).unwrap();
        Self { client, expiration }
    }
}

impl Actor for CacheActor {
    type Context = SyncContext<Self>;
}

struct SetValue {
    pub path: String,
    pub content: Vec<u8>,
}

impl Message for SetValue {
    type Result = Result<(), RedisError>;
}

impl Handler<SetValue> for CacheActor {
    type Result = Result<(), RedisError>;

    fn handle(&mut self, msg: SetValue, _: &mut Self::Context) -> Self::Result {
        self.client.set_ex(msg.path, msg.content, self.expiration)
    }
}

struct GetValue {
    pub path: String,
}

impl Message for GetValue {
    type Result = Result<Option<Vec<u8>>, RedisError>;
}

impl Handler<GetValue> for CacheActor {
    type Result = Result<Option<Vec<u8>>, RedisError>;

    fn handle(&mut self, msg: GetValue, _: &mut Self::Context) -> Self::Result {
        self.client.get(&msg.path)
    }
}

#[derive(Clone)]
pub struct CacheLink {
    addr: Addr<CacheActor>,
}

impl CacheLink {
    pub fn new(addr: Addr<CacheActor>) -> Self {
        Self { addr }
    }

    pub fn get_value(&self, path: &str) -> Box<Future<Item = Option<Vec<u8>>, Error = Error>> {
        let msg = GetValue {
            path: path.to_owned(),
        };
        let fut = self.addr.send(msg)
            .from_err::<Error>()
            .and_then(|x| x.map_err(Error::from));
        Box::new(fut)
    }

    pub fn set_value(&self, path: &str, value: &[u8]) -> Box<Future<Item = (), Error = Error>> {
        let msg = SetValue {
            path: path.to_owned(),
            content: value.to_owned(),
        };
        let fut = self.addr.send(msg)
            .from_err::<Error>()
            .and_then(|x| x.map_err(Error::from));
        Box::new(fut)
    }
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/src/main.rs
mod cache;

use actix::SyncArbiter;
use actix_web::{
    client, middleware, server, fs, App, Error, Form, HttpMessage,
    HttpRequest, HttpResponse, FutureResponse, Result,
};
use actix_web::http::{self, header, StatusCode};
use actix_web::middleware::{Finished, Middleware, Response, Started};
use actix_web::middleware::identity::RequestIdentity;
use actix_web::middleware::identity::{CookieIdentityPolicy, IdentityService};
use crate::cache::{CacheActor, CacheLink};
use failure::format_err;
use futures::{IntoFuture, Future, future};
use log::{debug, error};
use serde::{Deserialize, Serialize};
use serde_derive::{Deserialize, Serialize};
use std::cell::RefCell;

fn boxed<I, E, F>(fut: F) -> Box<Future<Item = I, Error = E>>
where
    F: Future<Item = I, Error = E> + 'static,
{
    Box::new(fut)
}

fn get_request(url: &str) -> impl Future<Item = Vec<u8>, Error = Error> {
    client::ClientRequest::get(url)
        .finish().into_future()
        .and_then(|req| {
            req.send()
                .map_err(Error::from)
                .and_then(|resp| resp.body().from_err())
                .map(|bytes| bytes.to_vec())
        })
}

fn post_request<T, O>(url: &str, params: T) -> impl Future<Item = O, Error = Error>
where
    T: Serialize,
    O: for <'de> Deserialize<'de> + 'static,
{
    client::ClientRequest::post(url)
        .form(params)
        .into_future()
        .and_then(|req| {
            req.send()
                .map_err(Error::from)
                .and_then(|resp| {
                    if resp.status().is_success() {
                        let fut = resp
                            .json::<O>()
                            .from_err();
                        boxed(fut)
                    } else {
                        error!("Microservice error: {}", resp.status());
                        let fut = Err(format_err!("microservice error"))
                            .into_future()
                            .from_err();
                        boxed(fut)
                    }
                })
        })
}


#[derive(Deserialize, Serialize)]
pub struct UserForm {
    email: String,
    password: String,
}

#[derive(Deserialize)]
pub struct UserId {
    id: String,
}

#[derive(Deserialize, Serialize)]
pub struct Comment {
    pub id: Option<i32>,
    pub uid: String,
    pub text: String,
}

#[derive(Deserialize)]
pub struct AddComment {
    pub text: String,
}

#[derive(Serialize)]
pub struct NewComment {
    pub uid: String,
    pub text: String,
}

fn signup(params: Form<UserForm>) -> FutureResponse<HttpResponse> {
    let fut = post_request("http://127.0.0.1:8001/signup", params.into_inner())
        .map(|_: ()| {
            HttpResponse::Found()
            .header(header::LOCATION, "/login.html")
            .finish()
        });
    Box::new(fut)
}

fn signin((req, params): (HttpRequest<State>, Form<UserForm>)) -> FutureResponse<HttpResponse> {
    let fut = post_request("http://127.0.0.1:8001/signin", params.into_inner())
        .map(move |id: UserId| {
            req.remember(id.id);
            HttpResponse::build_from(&req)
            .status(StatusCode::FOUND)
            .header(header::LOCATION, "/comments.html")
            .finish()
        });
    Box::new(fut)
}

fn new_comment((req, params): (HttpRequest<State>, Form<AddComment>)) -> FutureResponse<HttpResponse> {
    let fut = req.identity()
        .ok_or(format_err!("not authorized").into())
        .into_future()
        .and_then(move |uid| {
            let params = NewComment {
                uid,
                text: params.into_inner().text,
            };
            post_request::<_, ()>("http://127.0.0.1:8003/new_comment", params)
        })
        .then(move |_| {
            let res = HttpResponse::build_from(&req)
                .status(StatusCode::FOUND)
                .header(header::LOCATION, "/comments.html")
                .finish();
            Ok(res)
        });
    Box::new(fut)
}

fn comments(req: HttpRequest<State>) -> FutureResponse<HttpResponse> {
    let fut = get_request("http://127.0.0.1:8003/list");
    let fut = req.state().cache("/list", fut)
        .map(|data| {
            HttpResponse::Ok().body(data)
        });
    Box::new(fut)
}

fn counter(req: HttpRequest<State>) -> String {
    format!("{}", req.state().counter.borrow())
}



struct State {
    counter: RefCell<i64>,
    cache: CacheLink,
}

impl State {
    fn new(cache: CacheLink) -> Self {
        Self {
            counter: RefCell::default(),
            cache,
        }
    }

    fn cache<F>(&self, path: &str, fut: F)
        -> impl Future<Item = Vec<u8>, Error = Error>
    where
        F: Future<Item = Vec<u8>, Error = Error> + 'static,
    {
        let link = self.cache.clone();
        let path = path.to_owned();
        link.get_value(&path)
            .from_err::<Error>()
            .and_then(move |opt| {
                if let Some(cached) = opt {
                    debug!("Cached value used");
                    boxed(future::ok(cached))
                } else {
                    let res = fut.and_then(move |data| {
                        link.set_value(&path, &data)
                            .then(move |_| {
                                debug!("Cache updated");
                                future::ok::<_, Error>(data)
                            })
                            .from_err::<Error>()
                    });
                    boxed(res)
                }
            })
    }
}

pub struct Counter;

impl Middleware<State> for Counter {
    fn start(&self, req: &HttpRequest<State>) -> Result<Started> {
        let value = *req.state().counter.borrow();
        *req.state().counter.borrow_mut() = value + 1;
        Ok(Started::Done)
    }

    fn response(&self, _req: &HttpRequest<State>, resp: HttpResponse) -> Result<Response> {
        Ok(Response::Done(resp))
    }

    fn finish(&self, _req: &HttpRequest<State>, _resp: &HttpResponse) -> Finished {
        Finished::Done
    }
}

fn main() {
    env_logger::init();
    let sys = actix::System::new("router");

    let addr = SyncArbiter::start(3, || {
        CacheActor::new("redis://127.0.0.1:6379/", 10)
    });
    let cache = CacheLink::new(addr);

    server::new(move || {
        let state = State::new(cache.clone());
        App::with_state(state)
            .middleware(middleware::Logger::default())
            .middleware(IdentityService::new(
                    CookieIdentityPolicy::new(&[0; 32])
                    .name("auth-example")
                    .secure(false),
                    ))
            .middleware(Counter)
            .scope("/api", |scope| {
                scope
                    .route("/signup", http::Method::POST, signup)
                    .route("/signin", http::Method::POST, signin)
                    .route("/new_comment", http::Method::POST, new_comment)
                    .route("/comments", http::Method::GET, comments)
            })
            .route("/stats/counter", http::Method::GET, counter)
            .handler(
                "/",
                fs::StaticFiles::new("./static/").unwrap().index_file("index.html")
            )
    }).workers(1)
        .bind("127.0.0.1:8080")
        .unwrap()
        .start();

    println!("Started http server: 127.0.0.1:8080");
    let _ = sys.run();
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/static/comments.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/new_comment" method="post">
        Comment:<br>
        <input type="text" name="text"><br>
        <button type="submit">Add</button>
    </form>
    <div id="comments"></div>
  </body>
</html>


--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/static/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/signup" method="post">
        Email:<br>
        <input type="text" name="email"><br>
        Password<br>
        <input type="password" name="password"><br>
        <button type="submit">Signup</button>
    </form>
  </body>
</html>

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/static/login.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/signin" method="post">
        Email:<br>
        <input type="text" name="email"><br>
        Password<br>
        <input type="password" name="password"><br>
        <button type="submit">Login</button>
    </form>
  </body>
</html>


--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache/static/script.js

function create_node(text) {
    var element = document.getElementById("comments");
    var para = document.createElement("p");
    var node = document.createTextNode(text);
    para.appendChild(node);
    element.appendChild(para);
}

fetch('/api/comments')
    .then(function(response) {
        return response.json();
    })
    .then(function(data) {
        console.log(data);
        for(var i in data)
        {
            var item = data[i];
            create_node(item.uid);
            create_node(item.text);
        }
        console.log(JSON.stringify(comments));
    });

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/Cargo.toml
[package]
name = "router-cache-ws"
version = "0.1.0"
authors = ["Yusef Ulum <yusef314159@gmail.com>"]
edition = "2018"

[dependencies]
actix = "0.7"
actix-web = "0.7"
env_logger = "0.5"
failure = "0.1"
futures = "0.1"
log = "0.4"
redis = "0.9"
serde = "1.0"
serde_derive = "1.0"
serde_json = "1.0"
serde_urlencoded = "0.5"

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/src/cache.rs
use actix::prelude::*;
use failure::Error;
use futures::Future;
use redis::{Commands, Client, RedisError};

pub struct CacheActor {
    client: Client,
    expiration: usize,
}

impl CacheActor {
    pub fn new(addr: &str, expiration: usize) -> Self {
        let client = Client::open(addr).unwrap();
        Self { client, expiration }
    }
}

impl Actor for CacheActor {
    type Context = SyncContext<Self>;
}

struct SetValue {
    pub path: String,
    pub content: Vec<u8>,
}

impl Message for SetValue {
    type Result = Result<(), RedisError>;
}

impl Handler<SetValue> for CacheActor {
    type Result = Result<(), RedisError>;

    fn handle(&mut self, msg: SetValue, _: &mut Self::Context) -> Self::Result {
        self.client.set_ex(msg.path, msg.content, self.expiration)
    }
}

struct GetValue {
    pub path: String,
}

impl Message for GetValue {
    type Result = Result<Option<Vec<u8>>, RedisError>;
}

impl Handler<GetValue> for CacheActor {
    type Result = Result<Option<Vec<u8>>, RedisError>;

    fn handle(&mut self, msg: GetValue, _: &mut Self::Context) -> Self::Result {
        self.client.get(&msg.path)
    }
}

#[derive(Clone)]
pub struct CacheLink {
    addr: Addr<CacheActor>,
}

impl CacheLink {
    pub fn new(addr: Addr<CacheActor>) -> Self {
        Self { addr }
    }

    pub fn get_value(&self, path: &str) -> Box<Future<Item = Option<Vec<u8>>, Error = Error>> {
        let msg = GetValue {
            path: path.to_owned(),
        };
        let fut = self.addr.send(msg)
            .from_err::<Error>()
            .and_then(|x| x.map_err(Error::from));
        Box::new(fut)
    }

    pub fn set_value(&self, path: &str, value: &[u8]) -> Box<Future<Item = (), Error = Error>> {
        let msg = SetValue {
            path: path.to_owned(),
            content: value.to_owned(),
        };
        let fut = self.addr.send(msg)
            .from_err::<Error>()
            .and_then(|x| x.map_err(Error::from));
        Box::new(fut)
    }
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/src/main.rs
mod cache;
mod notify;
mod repeater;

use actix::{Actor, Addr, SyncArbiter};
use actix_web::{
    client, middleware, server, fs, ws, App, Error, Form, HttpMessage,
    HttpRequest, HttpResponse, FutureResponse, Result,
};
use actix_web::http::{self, header, StatusCode};
use actix_web::middleware::{Finished, Middleware, Response, Started};
use actix_web::middleware::identity::RequestIdentity;
use actix_web::middleware::identity::{CookieIdentityPolicy, IdentityService};
use crate::cache::{CacheActor, CacheLink};
use crate::notify::NotifyActor;
use crate::repeater::{RepeaterActor, RepeaterUpdate};
use failure::format_err;
use futures::{IntoFuture, Future, future};
use log::{debug, error};
use serde::{Deserialize, Serialize};
use serde_derive::{Deserialize, Serialize};
use std::cell::RefCell;

fn boxed<I, E, F>(fut: F) -> Box<Future<Item = I, Error = E>>
where
    F: Future<Item = I, Error = E> + 'static,
{
    Box::new(fut)
}

fn get_request(url: &str) -> impl Future<Item = Vec<u8>, Error = Error> {
    client::ClientRequest::get(url)
        .finish().into_future()
        .and_then(|req| {
            req.send()
                .map_err(Error::from)
                .and_then(|resp| resp.body().from_err())
                .map(|bytes| bytes.to_vec())
        })
}

fn post_request<T, O>(url: &str, params: T) -> impl Future<Item = O, Error = Error>
where
    T: Serialize,
    O: for <'de> Deserialize<'de> + 'static,
{
    client::ClientRequest::post(url)
        .form(params)
        .into_future()
        .and_then(|req| {
            req.send()
                .map_err(Error::from)
                .and_then(|resp| {
                    if resp.status().is_success() {
                        let fut = resp
                            .json::<O>()
                            .from_err();
                        boxed(fut)
                    } else {
                        error!("Microservice error: {}", resp.status());
                        let fut = Err(format_err!("microservice error"))
                            .into_future()
                            .from_err();
                        boxed(fut)
                    }
                })
        })
}


#[derive(Deserialize, Serialize)]
pub struct UserForm {
    email: String,
    password: String,
}

#[derive(Deserialize)]
pub struct UserId {
    id: String,
}

#[derive(Deserialize, Serialize)]
pub struct Comment {
    pub id: Option<i32>,
    pub uid: String,
    pub text: String,
}

#[derive(Deserialize)]
pub struct AddComment {
    pub text: String,
}

#[derive(Clone, Serialize)]
pub struct NewComment {
    pub uid: String,
    pub text: String,
}

fn signup(params: Form<UserForm>) -> FutureResponse<HttpResponse> {
    let fut = post_request("http://127.0.0.1:8001/signup", params.into_inner())
        .map(|_: ()| {
            HttpResponse::Found()
            .header(header::LOCATION, "/login.html")
            .finish()
        });
    Box::new(fut)
}

fn signin((req, params): (HttpRequest<State>, Form<UserForm>)) -> FutureResponse<HttpResponse> {
    let fut = post_request("http://127.0.0.1:8001/signin", params.into_inner())
        .map(move |id: UserId| {
            req.remember(id.id);
            HttpResponse::build_from(&req)
            .status(StatusCode::FOUND)
            .header(header::LOCATION, "/comments.html")
            .finish()
        });
    Box::new(fut)
}

fn new_comment((req, params): (HttpRequest<State>, Form<AddComment>)) -> FutureResponse<HttpResponse> {
    let repeater = req.state().repeater.clone();
    let fut = req.identity()
        .ok_or(format_err!("not authorized").into())
        .into_future()
        .and_then(move |uid| {
            let new_comment = NewComment {
                uid,
                text: params.into_inner().text,
            };
            let update = RepeaterUpdate(new_comment.clone());
            repeater
                .send(update)
                .then(move |_| Ok(new_comment))
        })
        .and_then(move |params| {
            post_request::<_, ()>("http://127.0.0.1:8003/new_comment", params)
        })
        .then(move |_| {
            let res = HttpResponse::build_from(&req)
                .status(StatusCode::FOUND)
                .header(header::LOCATION, "/comments.html")
                .finish();
            Ok(res)
        });
    Box::new(fut)
}

fn comments(req: HttpRequest<State>) -> FutureResponse<HttpResponse> {
    let fut = get_request("http://127.0.0.1:8003/list");
    let fut = req.state().cache("/list", fut)
        .map(|data| {
            HttpResponse::Ok().body(data)
        });
    Box::new(fut)
}

fn counter(req: HttpRequest<State>) -> String {
    format!("{}", req.state().counter.borrow())
}

fn ws_connect(req: &HttpRequest<State>) -> Result<HttpResponse, Error> {
    let repeater = req.state().repeater.clone().recipient();
    ws::start(req, NotifyActor::new(repeater))
}


pub struct State {
    counter: RefCell<i64>,
    cache: CacheLink,
    repeater: Addr<RepeaterActor>,
}

impl State {
    fn new(cache: CacheLink, repeater: Addr<RepeaterActor>) -> Self {
        Self {
            counter: RefCell::default(),
            cache,
            repeater,
        }
    }

    fn cache<F>(&self, path: &str, fut: F)
        -> impl Future<Item = Vec<u8>, Error = Error>
    where
        F: Future<Item = Vec<u8>, Error = Error> + 'static,
    {
        let link = self.cache.clone();
        let path = path.to_owned();
        link.get_value(&path)
            .from_err::<Error>()
            .and_then(move |opt| {
                if let Some(cached) = opt {
                    debug!("Cached value used");
                    boxed(future::ok(cached))
                } else {
                    let res = fut.and_then(move |data| {
                        link.set_value(&path, &data)
                            .then(move |_| {
                                debug!("Cache updated");
                                future::ok::<_, Error>(data)
                            })
                            .from_err::<Error>()
                    });
                    boxed(res)
                }
            })
    }
}

pub struct Counter;

impl Middleware<State> for Counter {
    fn start(&self, req: &HttpRequest<State>) -> Result<Started> {
        let value = *req.state().counter.borrow();
        *req.state().counter.borrow_mut() = value + 1;
        Ok(Started::Done)
    }

    fn response(&self, _req: &HttpRequest<State>, resp: HttpResponse) -> Result<Response> {
        Ok(Response::Done(resp))
    }

    fn finish(&self, _req: &HttpRequest<State>, _resp: &HttpResponse) -> Finished {
        Finished::Done
    }
}

fn main() {
    env_logger::init();
    let sys = actix::System::new("router");

    let addr = SyncArbiter::start(3, || {
        CacheActor::new("redis://127.0.0.1:6379/", 10)
    });
    let cache = CacheLink::new(addr);

    let repeater = RepeaterActor::new().start();

    server::new(move || {
        let state = State::new(cache.clone(), repeater.clone());
        App::with_state(state)
            .middleware(middleware::Logger::default())
            .middleware(IdentityService::new(
                    CookieIdentityPolicy::new(&[0; 32])
                    .name("auth-example")
                    .secure(false),
                    ))
            .middleware(Counter)
            .scope("/api", |scope| {
                scope
                    .route("/signup", http::Method::POST, signup)
                    .route("/signin", http::Method::POST, signin)
                    .route("/new_comment", http::Method::POST, new_comment)
                    .route("/comments", http::Method::GET, comments)
            })
            .route("/stats/counter", http::Method::GET, counter)
            .resource("/ws", |r| r.method(http::Method::GET).f(ws_connect))
            .handler(
                "/",
                fs::StaticFiles::new("./static/").unwrap().index_file("index.html")
            )
    }).workers(1)
        .bind("127.0.0.1:8080")
        .unwrap()
        .start();

    println!("Started http server: 127.0.0.1:8080");
    let _ = sys.run();
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/src/notify.rs
use actix::{Actor, ActorContext, AsyncContext, Handler, Recipient, StreamHandler};
use actix_web::ws::{Message, ProtocolError, WebsocketContext};
use crate::repeater::{RepeaterControl, RepeaterUpdate};
use std::time::{Duration, Instant};
use super::State;

const PING_INTERVAL: Duration = Duration::from_secs(20);
const PING_TIMEOUT: Duration = Duration::from_secs(60);

pub struct NotifyActor {
     last_ping: Instant,
     repeater: Recipient<RepeaterControl>,
}

impl NotifyActor {
    pub fn new(repeater: Recipient<RepeaterControl>) -> Self {
        Self {
            last_ping: Instant::now(),
            repeater,
        }
    }
}

impl Actor for NotifyActor {
    type Context = WebsocketContext<Self, State>;

    fn started(&mut self, ctx: &mut Self::Context) {
        let msg = RepeaterControl::Subscribe(ctx.address().recipient());
        self.repeater.do_send(msg).ok();
        ctx.run_interval(PING_INTERVAL, |act, ctx| {
            if Instant::now().duration_since(act.last_ping) > PING_TIMEOUT {
                ctx.stop();
                return;
            }
            ctx.ping("ping");
        });
    }

    fn stopped(&mut self, ctx: &mut Self::Context) {
        let msg = RepeaterControl::Unsubscribe(ctx.address().recipient());
        self.repeater.do_send(msg).ok();
    }
}

impl Handler<RepeaterUpdate> for NotifyActor {
    type Result = ();

    fn handle(&mut self, msg: RepeaterUpdate, ctx: &mut Self::Context) -> Self::Result {
        let RepeaterUpdate(comment) = msg;
        if let Ok(data) = serde_json::to_string(&comment) {
            ctx.text(data);
        }
    }
}

impl StreamHandler<Message, ProtocolError> for NotifyActor {
    fn handle(&mut self, msg: Message, ctx: &mut Self::Context) {
        match msg {
            Message::Ping(msg) => {
                self.last_ping = Instant::now();
                ctx.pong(&msg);
            }
            Message::Pong(_) => {
                self.last_ping = Instant::now();
            }
            Message::Text(_) => { },
            Message::Binary(_) => { },
            Message::Close(_) => {
                ctx.stop();
            }
        }
    }
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/src/repeater.rs
use actix::{Actor, Context, Handler, Message, Recipient};
use std::collections::HashSet;
use super::NewComment;

pub struct RepeaterActor {
    listeners: HashSet<Recipient<RepeaterUpdate>>,
}

impl RepeaterActor {
    pub fn new() -> Self {
        Self {
            listeners: HashSet::new(),
        }
    }
}

impl Actor for RepeaterActor {
    type Context = Context<Self>;
}

#[derive(Clone)]
pub struct RepeaterUpdate(pub NewComment);

impl Message for RepeaterUpdate {
    type Result = ();
}

impl Handler<RepeaterUpdate> for RepeaterActor {
    type Result = ();

    fn handle(&mut self, msg: RepeaterUpdate, _: &mut Self::Context) -> Self::Result {
        for listener in &self.listeners {
            listener.do_send(msg.clone()).ok();
        }
    }
}

pub enum RepeaterControl {
    Subscribe(Recipient<RepeaterUpdate>),
    Unsubscribe(Recipient<RepeaterUpdate>),
}

impl Message for RepeaterControl {
    type Result = ();
}

impl Handler<RepeaterControl> for RepeaterActor {
    type Result = ();

    fn handle(&mut self, msg: RepeaterControl, _: &mut Self::Context) -> Self::Result {
        match msg {
            RepeaterControl::Subscribe(listener) => {
                self.listeners.insert(listener);
            }
            RepeaterControl::Unsubscribe(listener) => {
                self.listeners.remove(&listener);
            }
        }
    }
}

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/static/comments.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/new_comment" method="post">
        Comment:<br>
        <input type="text" name="text"><br>
        <button type="submit">Add</button>
    </form>
    <div id="comments"></div>
  </body>
</html>


--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/static/index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/signup" method="post">
        Email:<br>
        <input type="text" name="email"><br>
        Password<br>
        <input type="password" name="password"><br>
        <button type="submit">Signup</button>
    </form>
  </body>
</html>

--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/static/login.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>title</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>
  <body>
    <form action="/api/signin" method="post">
        Email:<br>
        <input type="text" name="email"><br>
        Password<br>
        <input type="password" name="password"><br>
        <button type="submit">Login</button>
    </form>
  </body>
</html>


--#

--% C:/work/github/rust/Hands-On-Microservices-with-Rust/Chapter11/router-cache-ws/static/script.js

function create_node(text) {
    var element = document.getElementById("comments");
    var para = document.createElement("p");
    var node = document.createTextNode(text);
    para.appendChild(node);
    element.appendChild(para);
}

function add_item(item) {
    create_node(item.uid);
    create_node(item.text);
}

fetch('/api/comments')
    .then(function(response) {
        return response.json();
    })
    .then(function(data) {
        console.log(data);
        for(var i in data)
        {
            var item = data[i];
            add_item(item);
        }
        console.log(JSON.stringify(comments));
    });

var connection = new WebSocket("ws://127.0.0.1:8080/ws", "json");
connection.onmessage = function (evt) {
    var item = JSON.parse(evt.data);
    add_item(item);
};

--#

